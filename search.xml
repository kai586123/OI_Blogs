<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>19.9.14 智商不足模拟赛</title>
    <url>/2019/09/14/19-9-14-%E6%99%BA%E5%95%86%E4%B8%8D%E8%B6%B3%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p><a href="https://baka.online/wp-content/uploads/2019/09/problem-1.pdf">Click here to AK IOI</a> 果然毒瘤场的开题顺序都是231吗。。</p>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>神仙题。。来一个不完整证明吧。。。 考虑一个环的情况。对于一个环$a_1,a_2…a_k$，构造集合$\lbrace x \mid x = (2^k-1)p+2^{i-1} \rbrace \in S_{a_i}$ 证明：考虑$p=1$，可以推出，$(2^k-1)+2^{i-2} \in S_{a_{i-1&#125;&#125; \Rightarrow (2^k-1)+2^{i-1} \in S_{a_{i&#125;&#125;$。又$2^k=(2^k-1)+1 \in S_{a_1}$。 然后，采用归纳法证明。如果$&lt; x$的$p$都成立的话，可以推出$x$成立。 如果一个点上有两个环，那么显然，如$((2^{k_1}-1),(2^{k_2}-1))=1$，一定可以表示出大于某个数后的任意整数。 然后，我们还有一个结论。如果$((2^{k_1}-1),(2^{k_2}-1))=1$，只需要$(k_1,k_2)=1$。这个也可以用归纳法证明。 这样，如果两个环大小（环上点数）互质，就可以判断了。一个强连通分量内任意点都可以走到一个可行点上绕圈，再走回来，所以同一个强连通分量内答案一样。 然后，再转化问题。各种环是很难找的，所以要寻找一种等价的东西。任选一点$x$，求出每个点和$x$的最短距离$d_i$，定义一条边的权值为$\mid d_i - d_j + 1 \mid$，求出边的最大公约数即可（忽略为$0$的边）。 证明：题解里并没有。。也懒得看那个必要性证明，自己YY了一发。 寻找哪里会出现非$0$的边。实际上，我们从某个点进入一个环，在走了一圈走回这个点的时候，会产生非$0$边，大小正好为环的大小。这样，可以通过边权找出所有简单环大小。</p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>最简单的题。。。 $$a_1+a_2=a_{n-1}+a_n$$ $$a_2-a_1=a_n-a_{n-1}$$ 差分数组构成回文串。manacher。</p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>属实带模拟题。 做法：首先预处理所有可行状态。可以算出，分出一组的方法很少。令$f_i$表示状态$i$是否可行，枚举从中分出一组，就可以了。顺便预处理出每种集合的和$sum_i$。 然后，令$g_i$表示初始组合为$i$的答案。 如果$i$直接可行，$g_i=sum_i$，否则，$g_i=\sum \frac{g_j}{p-size_i}$，$j$表示$i$去掉一个元素。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>19.9.24 CSP-&gt;省选模拟赛</title>
    <url>/2019/09/25/19-9-24-csp-%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>水题。然而写挂了。对于两个点分类讨论即可，不说了。</p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>发现式子的含义，即在一个每一列$i$的每一行值都是$y_i$的方格图上，从点$(x,y)$走到$x$为$1$的地方，要求路上经过的值之和最小。 冷静分析一下，可以发现，走法一定是向左上方走一段，然后直着上去。 令$g_{y,j}(x)$，表示从$(x,y)$走到$(1,j)$，最后那一段直着上去的在$j$的答案。 $$g_{y,j}(x) = sum_y - sum_j + A_j (x - y + j)$$ $$f_{x,y} = \min g_{y,j}(x)$$ 容易发现，把$g$看作直线，最优答案一定在上凸壳的边上。如果维护出了所有的$g$，就可以斜率优化了。 考虑如何$g_{y,j} \rightarrow g_{y + 1, j}$ $$g_{y + 1, j} = sum_y + A_{y + 1} - sum_j + A_j (x - y + j - 1)$$ 其实就是把原来所有的线向右平移一格，向上平移$A_{y + 1}$格。 再考虑新加入的直线表达式到底是什么： $$g_{y + 1, y + 1} = sum_{y + 1} - sum_{y + 1} + A_{y + 1} (x - (y + 1) + (y + 1)) = A_{y + 1} x$$ 上面得出的性质是很好的。它告诉我们，每次$y+1$的时候，原来的凸壳移动了一些，同时加入了一条过原点的线。新的线加在了原来凸壳的左边。 那么如何维护这个上凸壳就很显然了：</p>
<ol>
<li>弹掉所有斜率比它大的线</li>
<li>弹掉使得相邻直线交点不单调的线</li>
</ol>
<p>对蒟蒻来说好难啊OAO <a href="https://www.luogu.org/paste/muxmjmzs">乱码了，点这里看代码</a></p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>暴力比较显然，正解不会，先咕咕了</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>19.9.7暴力打挂垫底赛</title>
    <url>/2019/09/09/19-9-7%E6%9A%B4%E5%8A%9B%E6%89%93%E6%8C%82%E5%9E%AB%E5%BA%95%E8%B5%9B/</url>
    <content><![CDATA[<p><a href="https://baka.online/wp-content/uploads/2019/09/problem.pdf">题在这里</a></p>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>一个数据结构优化DP。。。 $f_{i,j}$表示位置$i$，$A$的最大值为$j$ $$f_{i,A_i}=\max_{k&gt;B_i,k\geq A_i} f_{i-1,k}+1$$ $$f_{i,j}=f_{i-1,j}+1,B_i &lt; j \leq A_i$$</p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>离线好做很多。 每个节点挂一棵线段树，以C为下标，维护颜色在子树内出现的，深度最浅的值。 用全局的数据结构（如树状数组）维护深度区间内被选中的点数量和。 DFS，进入查询一次，出去查询一次，做差就是答案。</p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>考场写了个序列自动机。。喜提90分。。。 正解是个傻xDP： $$f_{i,j}=f_{i-1,j-1}+f_{i-1,j}-f_{lst-1,j-1}$$ 其中，$lst$是当前位置字母上一次出现的位置。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>2017国家集训队测试无限之环</title>
    <url>/2019/01/05/2017%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E6%B5%8B%E8%AF%95%E6%97%A0%E9%99%90%E4%B9%8B%E7%8E%AF/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=5120">[2017国家集训队测试]无限之环</a> 也许是费用流神题？ 说起来我玩过这游戏，打了几十关 这题有15种形状的管子，分别指向1，2，3，4个方向，要分类处理建图 黑白染色，拆成五个点（上下左右中），s，t分别向它们连边。对于每条边，流量全部是1，费用由转几下决定 指向一个方向的与四个方向的好处理，0121于0000连边即可 指向两个方向的有两种，直的不能旋转，加两条0。可以旋转的对一开始对着的方向加两条0，并且向对边分别加1。旋转管子和翻转管子等价，可以理解为把自己转了过去。 指向三个方向的，对对着的方向加0，与空边相邻的边向空边加1，空边对边向它加2，理由和两条的差不多 注意格子颜色不同，边的方向不同，需要对边进行翻转。最后把s连的格子拆出的点与t连的格子拆出的点对应连接，跑最大流就可以了 貌似费用流一般写法是EK+SPFA，然而本题不开O2会花样超时，开启后洛谷大约8000ms的样子。 蒟蒻不会写费用流，去博客翻找，发现了一个<a href="https://blog.csdn.net/jzq233jzq/article/details/73123089">比香港记者还快的费用流</a>，居然可以在建图方法效率低下的情况下达到洛谷不开O2只有2000ms，bzoj混进最优解前两页的成绩。。Orz，学习一个 附上200行丑陋代码，因为本题建图复杂（实际上是我太菜），改了一个多小时才过掉…：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10005</span>, MAXM = MAXN * <span class="number">10</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, s = MAXN - <span class="number">3</span>, t = MAXN - <span class="number">2</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">G</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt, f, c;</span><br><span class="line">&#125; g[MAXM * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAXN], tot = <span class="number">1</span>, ch[MAXM * <span class="number">2</span>][<span class="number">4</span>], pos[<span class="number">2005</span>][<span class="number">2005</span>], num, dis[MAXN], ans, tot_s;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN], rev;</span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> f, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    g[++tot].to = y, g[tot].nxt = head[x], g[tot].f = f, g[tot].c = c;</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> f, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rev) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">addedge</span>(x, y, f, c);</span><br><span class="line">    <span class="built_in">addedge</span>(y, x, <span class="number">0</span>, -c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    dis[t] = <span class="number">0</span>;</span><br><span class="line">    vis[t] = <span class="literal">true</span>;</span><br><span class="line">    que.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop_front</span>();</span><br><span class="line">        vis[x] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[i ^ <span class="number">1</span>].f &amp;&amp; dis[g[i].to] &gt; dis[x] - g[i].c) &#123;</span><br><span class="line">                dis[g[i].to] = dis[x] - g[i].c;</span><br><span class="line">                <span class="keyword">if</span> (!vis[g[i].to]) &#123;</span><br><span class="line">                    vis[g[i].to] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; dis[g[i].to] &lt; dis[que.<span class="built_in">front</span>()])</span><br><span class="line">                        que.<span class="built_in">push_front</span>(g[i].to);</span><br><span class="line">                    <span class="keyword">else</span> que.<span class="built_in">push_back</span>(g[i].to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[s] != INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> mf)</span> </span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == t) <span class="keyword">return</span> mf;</span><br><span class="line">    <span class="keyword">int</span> used = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[g[i].to] &amp;&amp; g[i].f &amp;&amp; dis[g[i].to] == dis[x] - g[i].c) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="built_in">dfs</span>(g[i].to, <span class="built_in">min</span>(mf - used, g[i].f));</span><br><span class="line">            <span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">                ans += tmp * g[i].c;</span><br><span class="line">                used += tmp;</span><br><span class="line">                g[i].f -= tmp;</span><br><span class="line">                g[i ^ <span class="number">1</span>].f += tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (used == mf) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">costflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">spfa</span>()) &#123;</span><br><span class="line">        vis[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (vis[t]) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">            ret += <span class="built_in">dfs</span>(s, INF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>(), s = ++num, t = ++num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="built_in">rd</span>(), p = ++num, cnt = <span class="number">0</span>, h[<span class="number">4</span>] = &#123;&#125;;</span><br><span class="line">            pos[i][j] = p;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k, tmp &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                ch[p][k] = ++num;</span><br><span class="line">                <span class="keyword">if</span> (tmp &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    h[k] = <span class="literal">true</span>;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rev = !((i + j) &amp; <span class="number">1</span>);</span><br><span class="line">            tot_s += cnt;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((i + j) &amp; <span class="number">1</span>) <span class="built_in">add</span>(s, p, cnt, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">add</span>(t, p, cnt, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (; k &lt; <span class="number">4</span>; ++k)</span><br><span class="line">                    <span class="keyword">if</span> (h[k])</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="built_in">add</span>(p, ch[p][k], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">add</span>(p, ch[p][(k + <span class="number">1</span>) % <span class="number">4</span>], <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">add</span>(p, ch[p][(k + <span class="number">2</span>) % <span class="number">4</span>], <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">                <span class="built_in">add</span>(p, ch[p][(k + <span class="number">3</span>) % <span class="number">4</span>], <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> k1 = <span class="number">0</span>, k2;</span><br><span class="line">                <span class="keyword">for</span> (; k1 &lt; <span class="number">4</span>; ++k1)</span><br><span class="line">                    <span class="keyword">if</span> (h[k1])</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (h[(k1 + <span class="number">2</span>) % <span class="number">4</span>]) &#123;</span><br><span class="line">                    k2 = (k1 + <span class="number">2</span>) % <span class="number">4</span>;</span><br><span class="line">                    <span class="built_in">add</span>(p, ch[p][k1], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">add</span>(p, ch[p][k2], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    k2 = h[(k1 + <span class="number">1</span>) % <span class="number">4</span>] ? (k1 + <span class="number">1</span>) % <span class="number">4</span> : (k1 + <span class="number">3</span>) % <span class="number">4</span>;</span><br><span class="line">                    <span class="built_in">add</span>(p, ch[p][k1], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">add</span>(p, ch[p][k2], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">add</span>(ch[p][k1], ch[p][(k1 + <span class="number">2</span>) % <span class="number">4</span>], <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">add</span>(ch[p][k2], ch[p][(k2 + <span class="number">2</span>) % <span class="number">4</span>], <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> nk = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (; nk &lt; <span class="number">4</span>; ++nk)</span><br><span class="line">                    <span class="keyword">if</span> (!h[nk])</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="built_in">add</span>(p, ch[p][(nk + <span class="number">1</span>) % <span class="number">4</span>], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">add</span>(p, ch[p][(nk + <span class="number">2</span>) % <span class="number">4</span>], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">add</span>(p, ch[p][(nk + <span class="number">3</span>) % <span class="number">4</span>], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">add</span>(ch[p][(nk + <span class="number">1</span>) % <span class="number">4</span>], ch[p][nk], <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">add</span>(ch[p][(nk + <span class="number">2</span>) % <span class="number">4</span>], ch[p][nk], <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">                <span class="built_in">add</span>(ch[p][(nk + <span class="number">3</span>) % <span class="number">4</span>], ch[p][nk], <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)</span><br><span class="line">                    <span class="built_in">add</span>(p, ch[p][k], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rev = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i + j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">1</span>)</span><br><span class="line">                    <span class="built_in">add</span>(ch[pos[i][j]][<span class="number">0</span>], ch[pos[i - <span class="number">1</span>][j]][<span class="number">2</span>], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">1</span>)</span><br><span class="line">                    <span class="built_in">add</span>(ch[pos[i][j]][<span class="number">3</span>], ch[pos[i][j - <span class="number">1</span>]][<span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (i != n)</span><br><span class="line">                    <span class="built_in">add</span>(ch[pos[i][j]][<span class="number">2</span>], ch[pos[i + <span class="number">1</span>][j]][<span class="number">0</span>], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (j != m)</span><br><span class="line">                    <span class="built_in">add</span>(ch[pos[i][j]][<span class="number">1</span>], ch[pos[i][j + <span class="number">1</span>]][<span class="number">3</span>], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> ret)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ret != (tot_s &gt;&gt; <span class="number">1</span>))</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; ans;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">costflow</span>();</span><br><span class="line">    <span class="built_in">write</span>(ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>20190525模拟赛</title>
    <url>/2019/05/28/20190525%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p><img src="https://baka.online/wp-content/uploads/2019/05/TIM%E6%88%AA%E5%9B%BE20190528181826.png"> 考试的时候想构造一个三个数字的答案，发现构造不出来。于是启发我答案是不是数字很少，发现是个数学题。 若$a+b\in p,b+c \in p, p&gt;2$，那么$a,b,c$中有两个肯定奇偶相同，它们的和就是偶数。所以对于$x&gt;=2$，只能选最多2个。 若存在1，可以都选。然后可以再选一个数，让它和1的和是质数。注意如果只能选2个1，还选不了别的数，要考虑能不能选其它两个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">15000000</span> * <span class="number">2</span> + <span class="number">2333</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N], cnt, a[<span class="number">1100</span>]; <span class="keyword">bool</span> pp[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pp[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pp[i]) &#123;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; ++j) &#123;</span><br><span class="line">            pp[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= 200; ++i)</span></span><br><span class="line">    <span class="comment">//     if (!pp[i])</span></span><br><span class="line">    <span class="comment">//         cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> one = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">1</span>)</span><br><span class="line">            ++one;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (one &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= one; ++i)</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; one; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pp[a[i] + <span class="number">1</span>]) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans.<span class="built_in">size</span>() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); ++i)</span><br><span class="line">                cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="number">-1</span>, n2 = <span class="number">-1</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pp[a[i] + a[j]] &amp;&amp; a[i] + a[j] &gt; sum) &#123;</span><br><span class="line">                sum = a[i] + a[j];</span><br><span class="line">                n1 = a[i]; n2 = a[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n1 &gt; n2) <span class="built_in">swap</span>(n1, n2);</span><br><span class="line">    cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl &lt;&lt; n1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;prime.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;prime.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="keyword">return</span> kai586123::<span class="built_in">main</span>(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p><img src="https://baka.online/wp-content/uploads/2019/05/TIM%E6%88%AA%E5%9B%BE20190528181935.png"> 和这题差不多，不说了。代码不小心删了… <a href="https://baka.online/apio-ctsc-2007%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/">[APIO/CTSC 2007]数据备份</a></p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p><img src="https://baka.online/wp-content/uploads/2019/05/TIM%E6%88%AA%E5%9B%BE20190528181941.png"> 很有意思的题。枚举拿了50分跑路。 树形DP可以做。记录每个点的最远点，次远点，次次远点，子树内直径，然后可以一大波分类讨论做。嫌麻烦果断放弃。 然后还有一个做法。线段树可以维护树的直径。给树标一下dfs序，记录区间内距离最远的两个点。如果有多对，记录一对就行了。合并两个区间的时候，四个点中的最远点对就是新直径。 证明：新直径是原来的两个直径之一，或者经过两部分之间的路。然后有个性质，一棵树上一个点到直径的某一端点一定是最远点。就很显然了。 线段树维护树直径，然后枚举删边，把剩下两部分的直径都求出来。如果用ST表求LCA，是$O(nlogn)$。本菜用的树剖，$O(nlog^2n)$，也过了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">2333</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt, cost;</span><br><span class="line">&#125; g[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n, head[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    g[++tot].to = y, g[tot].nxt = head[x],</span><br><span class="line">    g[tot].cost = c, head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, v;</span><br><span class="line">&#125; t[N * <span class="number">4</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(p) p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(p) p &lt;&lt; 1  1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N], size[N], son[N], dep[N], top[N],</span><br><span class="line">    id[N], dfn[N], num, dis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    size[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="keyword">if</span> (y == fa[x])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        fa[y] = x; dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        dis[y] = dis[x] + g[i].cost;</span><br><span class="line">        <span class="built_in">dfs1</span>(y);</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">        <span class="keyword">if</span> (size[y] &gt; size[son[x]])</span><br><span class="line">            son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line">    top[x] = topf; dfn[x] = ++num; id[num] = x;</span><br><span class="line">    <span class="keyword">if</span> (!son[x])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], topf);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="keyword">if</span> (y == fa[x]  y == son[x])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(y, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>  y == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]])</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; dep[y])</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>  y == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> dis[x] + dis[y] - <span class="number">2</span> * dis[<span class="built_in">get_lca</span>(x, y)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Segment_Tree <span class="title">new_tree</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v = <span class="number">-1</span>)</span> </span>&#123;</span><br><span class="line">    Segment_Tree ret;</span><br><span class="line">    ret.x = x;</span><br><span class="line">    ret.y = y;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">-1</span>)</span><br><span class="line">        ret.v = <span class="built_in">get_dis</span>(x, y);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret.v = v;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Segment_Tree <span class="title">max</span><span class="params">(<span class="keyword">const</span> Segment_Tree &amp;a, <span class="keyword">const</span> Segment_Tree &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.v &gt; b.v ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt; y ? x : y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Segment_Tree <span class="title">merge</span><span class="params">(<span class="keyword">const</span> Segment_Tree &amp;a, <span class="keyword">const</span> Segment_Tree &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(</span><br><span class="line">        <span class="built_in">max</span>(a, b), <span class="built_in">max</span>(</span><br><span class="line">        <span class="built_in">max</span>(<span class="built_in">new_tree</span>(a.x, b.x), <span class="built_in">new_tree</span>(a.x, b.y)),</span><br><span class="line">        <span class="built_in">max</span>(<span class="built_in">new_tree</span>(a.y, b.x), <span class="built_in">new_tree</span>(a.y, b.y))</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        t[p] = <span class="built_in">new_tree</span>(id[l], id[l], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(p), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">    t[p] = <span class="built_in">merge</span>(t[<span class="built_in">ls</span>(p)], t[<span class="built_in">rs</span>(p)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Segment_Tree <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R)</span><br><span class="line">        <span class="keyword">return</span> t[p];</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    Segment_Tree ret = <span class="built_in">new_tree</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-233</span>);</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">        ret = <span class="built_in">merge</span>(ret, <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r, L, mid));</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">        ret = <span class="built_in">merge</span>(ret, <span class="built_in">query</span>(<span class="built_in">rs</span>(p), l, r, mid + <span class="number">1</span>, R));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>(), c = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">addedge</span>(x, y, c);</span><br><span class="line">        <span class="built_in">addedge</span>(y, x, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>); <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        Segment_Tree x = <span class="built_in">query</span>(<span class="number">1</span>, dfn[i], dfn[i] + size[i] - <span class="number">1</span>, <span class="number">1</span>, n),</span><br><span class="line">            y = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, dfn[i] - <span class="number">1</span>, <span class="number">1</span>, n),</span><br><span class="line">            z = <span class="built_in">query</span>(<span class="number">1</span>, dfn[i] + size[i], n, <span class="number">1</span>, n);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, x.v + <span class="built_in">merge</span>(y, z).v);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> kai586123::<span class="built_in">main</span>(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>20190601欢乐六一模拟赛</title>
    <url>/2019/06/01/20190601%E6%AC%A2%E4%B9%90%E5%85%AD%E4%B8%80%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p><img src="https://baka.online/wp-content/uploads/2019/06/TIM%E6%88%AA%E5%9B%BE20190601172756.png"> 水题。枚举单峰函数的峰，然后把剩下的数放在两边，分别单调排列。$ans=\sum_{i=1}^nC_{n-1}^{i-1}$。 观察到右边这玩意就是$2^{n-1}$，于是快速幂，做完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">fpow</span><span class="params">(LL x, LL y)</span> </span>&#123;</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * x % MOD;</span><br><span class="line">        x = x * x % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;unimodal.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;unimodal.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    LL n; cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">fpow</span>(<span class="number">2</span>, n - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p><img src="https://baka.online/wp-content/uploads/2019/06/TIM%E6%88%AA%E5%9B%BE20190601172815.png"> 状压DP。然而不想状压DP，写了个搜索。 搜索预处理：预处理出每个积木三种摆放方式的$x,y,h$。并且让$x\leq y$。这样可以减少运算量。 然后这个搜索的最坏情况，其实也就是枚举了所有摆放方式。最坏复杂度$O(3^n)$，能过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">20</span>]; <span class="keyword">int</span> n, ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> <span class="keyword">int</span> mx, x[<span class="number">3</span>], y[<span class="number">3</span>], h[<span class="number">3</span>]; &#125; a[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)</span><br><span class="line">                <span class="keyword">if</span> (a[i].x[j] &lt;= x &amp;&amp; a[i].y[j] &lt;= y)</span><br><span class="line">                    <span class="built_in">dfs</span>(a[i].x[j], a[i].y[j], h + a[i].h[j]);</span><br><span class="line">            vis[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;brick.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;brick.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        a[i].x[<span class="number">0</span>] = <span class="built_in">min</span>(x, y); a[i].y[<span class="number">0</span>] = <span class="built_in">max</span>(x, y);</span><br><span class="line">        a[i].h[<span class="number">0</span>] = z;</span><br><span class="line">        a[i].x[<span class="number">1</span>] = <span class="built_in">min</span>(x, z); a[i].y[<span class="number">1</span>] = <span class="built_in">max</span>(x, z);</span><br><span class="line">        a[i].h[<span class="number">1</span>] = y;</span><br><span class="line">        a[i].x[<span class="number">2</span>] = <span class="built_in">min</span>(y, z); a[i].y[<span class="number">2</span>] = <span class="built_in">max</span>(y, z);</span><br><span class="line">        a[i].h[<span class="number">2</span>] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        vis[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)</span><br><span class="line">            <span class="built_in">dfs</span>(a[i].x[j], a[i].y[j], a[i].h[j]);</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p><img src="https://baka.online/wp-content/uploads/2019/06/TIM%E6%88%AA%E5%9B%BE20190601172826.png"> 先考虑一个简化的问题：给定整个序列，在整个序列上进行查询。 观察到$p$不大，$\leq 10000$。把$p$分块讨论。 如果$p \leq 100$： 用$f[i][j]$表示$\mod i \equiv j$的数的个数。我们向序列中添加单个数的时候，这玩意可以$O(\sqrt p)$处理出来。扫一遍数组，$O(n\sqrt p)$预处理。每次查询显然$O(1)$。 如果$p &gt; 100$： $a \equiv q \pmod p$，变形，$a = pk + q$。因为$p &gt; 100$，可以在$O(\sqrt p)$的时间内枚举$k$，查询$pk + q$的数有多少。$O(n)$预处理每个数有多少，每次$O(\sqrt p)$查询。 如果对于整个序列呢？ 方法1：一开始想到的，开vector，把两个数组里的某种数有多少改成在哪里出现了，然后每次二分查有多少个。总复杂度变成$O(n\sqrt p log n)$，TLE。 方法2：两种询问都需要把序列扫一遍的预处理。离线操作，把所有询问存下来。$[l,r]$的询问，可以化为$[1,r]-[1,l-1]$。对于一个$[1,x]$的询问，可以在扫描到$x$的时候执行上面讨论的对于全序列的查询操作，得到的就是到这里的答案。 总复杂度：$O(m\sqrt p)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">233</span>, P = <span class="number">1e4</span> + <span class="number">233</span>, LIM = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> p, q, id, t;</span><br><span class="line">    <span class="built_in">Node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span> (<span class="keyword">int</span> _p, <span class="keyword">int</span> _q, <span class="keyword">int</span> _id, <span class="keyword">int</span> <span class="keyword">_t</span>) &#123;</span><br><span class="line">        p = _p; q = _q;</span><br><span class="line">        id = _id; t = <span class="keyword">_t</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Node&gt; q_less[N], q_more[N];</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], ans[N], cnt[N], mod[LIM + <span class="number">10</span>][LIM + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(); m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">rd</span>(), r = <span class="built_in">rd</span>(), p = <span class="built_in">rd</span>(), q = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">if</span> (p * p &lt;= LIM) &#123;</span><br><span class="line">            q_less[l - <span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">Node</span>(p, q, i, <span class="number">-1</span>));</span><br><span class="line">            q_less[r].<span class="built_in">push_back</span>(<span class="built_in">Node</span>(p, q, i, <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            q_more[l - <span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">Node</span>(p, q, i, <span class="number">-1</span>));</span><br><span class="line">            q_more[r].<span class="built_in">push_back</span>(<span class="built_in">Node</span>(p, q, i, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= LIM; ++j)</span><br><span class="line">            ++mod[j][a[i] % j];</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;Node&gt;::iterator j = q_less[i].<span class="built_in">begin</span>(); j != q_less[i].<span class="built_in">end</span>(); ++j)</span><br><span class="line">            ans[j-&gt;id] += j-&gt;t * mod[j-&gt;p][j-&gt;q];</span><br><span class="line">        ++cnt[a[i]];</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;Node&gt;::iterator j = q_more[i].<span class="built_in">begin</span>(); j != q_more[i].<span class="built_in">end</span>(); ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; j-&gt;p * k &lt; P; ++k)</span><br><span class="line">                ans[j-&gt;id] += j-&gt;t * cnt[j-&gt;p * k + j-&gt;q];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;congruence.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;congruence.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>20190607普通高等OIer全团队统一考试题解</title>
    <url>/2019/06/07/20190607%E6%99%AE%E9%80%9A%E9%AB%98%E7%AD%89oier%E5%85%A8%E5%9B%A2%E9%98%9F%E7%BB%9F%E4%B8%80%E8%80%83%E8%AF%95%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p><img src="https://baka.online/wp-content/uploads/2019/06/60288.jpg"> 踢人的方式看似很复杂，其实热动分析一下，就是随机踢掉$n-k$个人，那么显然留下的概率就是$k/n$了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, id, g;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;k, &amp;id);</span><br><span class="line">    g = std::__gcd(n, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d/%d\n&quot;</span>, k / g, n / g);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p><img src="https://baka.online/wp-content/uploads/2019/06/60292.png"> <img src="https://baka.online/wp-content/uploads/2019/06/60296.png"> 都知道数字三角形是个普及都会做的题。刚学DP的时候都研究过，数字三角形有两种解法：从上往下，从下往上。 这题是删点的数字三角形。我们预处理出来从上往下，从下往上到每个点的距离，就可以求出来经过某个点的答案。 进一步，扫描一行的所有点，可以求出来分别必须过这些点的答案。记录每一行的最大与次大值。删掉一个点之后，这一行的最大和次大答案里肯定至少还有一个能用。直接用就行了。 当删掉起点的时候无解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N][N];</span><br><span class="line"><span class="comment">// from_top, from_bottom</span></span><br><span class="line"><span class="keyword">int</span> ft[N][N], fb[N][N];</span><br><span class="line"><span class="comment">// max first, max second</span></span><br><span class="line"><span class="keyword">int</span> mxf[N], mxs[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(); m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            a[i][j] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            ft[i][j] = <span class="built_in">max</span>(ft[i - <span class="number">1</span>][j], ft[i - <span class="number">1</span>][j - <span class="number">1</span>]) + a[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            fb[i][j] = <span class="built_in">max</span>(fb[i + <span class="number">1</span>][j], fb[i + <span class="number">1</span>][j + <span class="number">1</span>]) + a[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> dis = ft[i][j] + fb[i][j] - a[i][j];</span><br><span class="line">            <span class="keyword">if</span> (dis &gt; mxf[i]) mxs[i] = mxf[i], mxf[i] = dis;</span><br><span class="line">            <span class="keyword">else</span> mxs[i] = <span class="built_in">max</span>(mxs[i], dis);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span> &amp;&amp; y == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> dis = ft[x][y] + fb[x][y] - a[x][y];</span><br><span class="line">            <span class="keyword">if</span> (dis == mxf[x]) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mxs[x]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mxf[x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p><img src="https://baka.online/wp-content/uploads/2019/06/60294.png"> <img src="https://baka.online/wp-content/uploads/2019/06/60296.png"> <img src="https://baka.online/wp-content/uploads/2019/06/60298.png"> 由同学实践可知，暴力能拿50分。具体来讲就是建一棵长这样的线段树出来就完事。</p>
<h4 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h4><p>一个区间$[l,r]$，长度记为$k=r-l+1$。最坏情况下，会被划分成$t=k$块。$ans=k$。一个事实：线段树是二叉树。给这$k$块里某两块加个爸爸，这个区间内的总节点数变成了$k+1$，而$ans=k-(t-n)=2k-t$。 总结一下：只需要数出来区间内有多少个线段树节点就行了。 一个节点可以表示为$[x,y]$，对于询问$[l,r]$，我们要求的是$l&lt;=x,r&gt;=y$的节点数。这是个二维数点。树套树解决，log带个方。-&gt;主席树解决，log带个大常数。 后来发现离线排序+树状数组就过了。。。。。。$O(nlogn)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, tot, c[N], ans[N];</span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; x &lt;= n; x += <span class="built_in">lowbit</span>(x))</span><br><span class="line">        c[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; x; x -= <span class="built_in">lowbit</span>(x))</span><br><span class="line">        ret += c[x];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    a[r].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(l, <span class="number">233</span>));</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(l, mid); <span class="built_in">dfs</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(); m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">rd</span>(), r = <span class="built_in">rd</span>();</span><br><span class="line">        b[r].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(l, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; a[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            <span class="built_in">add</span>(a[i][j].first, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; b[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            ans[b[i][j].second] = (i - b[i][j].first + <span class="number">1</span>) * <span class="number">2</span> - (<span class="built_in">ask</span>(n) - <span class="built_in">ask</span>(b[i][j].first - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>20190614无限垫底赛</title>
    <url>/2019/06/15/20190614%E6%97%A0%E9%99%90%E5%9E%AB%E5%BA%95%E8%B5%9B/</url>
    <content><![CDATA[<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p><img src="https://baka.online/wp-content/uploads/2019/06/TIM%E6%88%AA%E5%9B%BE20190615175638.png"> 几分钟敲了个70分的暴力。 一个结论，当前鼎面还剩下1中，左上角的只能由铜模最左上角去印。所以暴判就行。</p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p><img src="https://baka.online/wp-content/uploads/2019/06/TIM%E6%88%AA%E5%9B%BE20190615175644.png"> 先编一个$O(n^3)$的DP。$f[i][j]$表示算到$i,j$，以$j$结尾的LCIS。$f[i][j]=f[i-1][j],a[i]!=a[j],f[i][j]=max(f[i-1][k]+1),a[i]==a[j],a[j]&gt;a[k]$。 优化到$O(n^2)$。$s[i]==s[j]$的时候才会去扫$k$，那么，直接用$a[i]$和$a[k]$比就行了。扫的时候记录一下这个最大值即可。 这题重点是输出方案……考场记录了转移来的$i$，挂了。std的写法是记录转移来的j，dfs输出，传入i，j在哪，还剩多少个没输出。一直减i直到数字相等，再递归。</p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p><img src="https://baka.online/wp-content/uploads/2019/06/TIM%E6%88%AA%E5%9B%BE20190615175651.png"> 分块。离散化吗。f[i][j]，i块到结尾，j的前缀和。g[i][j]，i到j块的答案。枚举起点块，$O(n\sqrt n)$预处理。 一个区间$[l,r]$，$l$在$x$块，$r$在$y$块。答案要么和$g[x+1][y-1]$一样，要么由两边剩下的元素的决定。扫剩下的元素，开一个cnt数组，加上已经有的前缀和可以求出来每种元素出现多少次。$O(n\sqrt n)$。 每次询问完清空cnt数组，memset复杂度不对，用栈记录一下操作，撤销即可。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>20190610提高组爆零赛</title>
    <url>/2019/06/10/20190610%E6%8F%90%E9%AB%98%E7%BB%84%E7%88%86%E9%9B%B6%E8%B5%9B/</url>
    <content><![CDATA[<p>感觉考试中考到的算法在提高组里一次也没考到过。被打爆了。</p>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p><img src="https://baka.online/wp-content/uploads/2019/06/TIM%E6%88%AA%E5%9B%BE20190610091719.png"> 我个人感觉最难的题…这个故事告诉我们开题顺序不对是会挂考试的…考场上推到了正解的一半多。 $(-1)^k$的答案是$1$还是$-1$，只取决于$k$的奇偶性。大部分数字的约数个数都是偶数。实际上，只有完全平方数的约数个数是奇数，即，对于每个$i$只需要求出来有多少$j$，使得$ij$为完全平方数就可以了。 令$i=p*q_1^2$，$p$没有平方因子，符合条件的$j$一定可以表示为$p*q_2^2$。在$1$到$m$中，符合条件的$j$有$\lfloor \sqrt \frac{m}{p} \rfloor$个。 分解$n$可以做到$O(n\sqrt n)$。线性筛可以做到$O(n)$。 大概讲一下怎么筛。 记录每个数字的答案$a[i]$，由于线性筛筛到一个数字的时候，这个数字会被表示为$i*p[j]$，即在$i$的基础上增加了质因子$p[j]$，我们判断$a[i]$里有没有它，处理就行了。见代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000000</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> p[N], cnt, a[N]; <span class="keyword">bool</span> v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;math.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;math.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    LL n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!v[i]) &#123;</span><br><span class="line">            p[++cnt] = i;</span><br><span class="line">            a[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * p[j] &lt;= n; ++j) &#123;</span><br><span class="line">            v[i * p[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[i] % p[j] == <span class="number">0</span>)</span><br><span class="line">                a[i * p[j]] = a[i] / p[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                a[i * p[j]] = a[i] * p[j];</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        LL sum = <span class="built_in">sqrt</span>(m / a[i]);</span><br><span class="line">        ans += (sum &amp; <span class="number">1</span>) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p><img src="https://baka.online/wp-content/uploads/2019/06/TIM%E6%88%AA%E5%9B%BE20190610091726.png"> 部分分算法就是$O(n^3)$的DP，都能想到不说了。 这题问题的形式就像要二分的，但是答案的形式让我们二分不能。实际上可以二分。答案只可能与某两点之间速度相同，算出所有速度，在里面二分就行了。 $f[i]$表示选了$i$最多得分。 $f[i]=max(f[j]+1 dis(i,j)\leq mid)$ $O(n^2logn)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, f[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> t, x, y;</span><br><span class="line">&#125; c[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Number</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, yy;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Number</span>(<span class="keyword">int</span> _x = <span class="number">0</span>, <span class="keyword">int</span> _y = <span class="number">0</span>) &#123;</span><br><span class="line">        x = _x; y = _y; yy = y * y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Number &amp;num) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="comment">//double val1 = sqrt(x) / (double)y, val2 = sqrt(num.x) / (double)num.y;</span></span><br><span class="line">        <span class="comment">//return val1 &lt; val2;</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>)x * num.yy &lt; (<span class="keyword">long</span> <span class="keyword">long</span>)yy * num.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> Number &amp;num) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="comment">//double val1 = sqrt(x) / (double)y, val2 = sqrt(num.x) / (double)num.y;</span></span><br><span class="line">        <span class="comment">//return val1 &lt;= val2;</span></span><br><span class="line">    <span class="built_in"><span class="keyword">return</span></span> (<span class="keyword">long</span> <span class="keyword">long</span>)x * num.yy &lt;= (<span class="keyword">long</span> <span class="keyword">long</span>)yy * num.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Number &amp;num) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (<span class="keyword">long</span> <span class="keyword">long</span>)x * num.yy == (<span class="keyword">long</span> <span class="keyword">long</span>)yy * num.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; speed[N * N], sp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = c[a].x - c[b].x, y = c[a].y - c[b].y;</span><br><span class="line">    <span class="keyword">return</span> x * x + y * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_time</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = c[a].t - c[b].t;</span><br><span class="line">    <span class="keyword">return</span> t &lt; <span class="number">0</span> ? -t : t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Number <span class="title">get_speed</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(<span class="built_in">get_dis</span>(a, b), <span class="built_in">get_time</span>(a, b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        f[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            <span class="keyword">if</span> (sp[j][i] &lt;= speed[x])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">        ret = <span class="built_in">max</span>(ret, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = speed[x].x, c = speed[x].y, a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= b; ++i)</span><br><span class="line">        <span class="keyword">if</span> (b % (i * i) == <span class="number">0</span>)</span><br><span class="line">            a = i;</span><br><span class="line">    b /= a * a;</span><br><span class="line">    <span class="keyword">int</span> g = <span class="built_in">gcd</span>(a, c);</span><br><span class="line">    a /= g; c /= g;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//O(n^2logn)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;osu.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;osu.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="keyword">clock_t</span> st = <span class="built_in">clock</span>();</span><br><span class="line">    n = <span class="built_in">rd</span>(); m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        c[i].t = <span class="built_in">rd</span>(), c[i].x = <span class="built_in">rd</span>(), c[i].y = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            sp[i][j] = speed[++tot] = <span class="built_in">get_speed</span>(i, j);</span><br><span class="line">    <span class="built_in">sort</span>(speed + <span class="number">1</span>, speed + tot + <span class="number">1</span>);</span><br><span class="line">    tot = <span class="built_in">unique</span>(speed + <span class="number">1</span>, speed + tot + <span class="number">1</span>) - speed - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">clock_t</span> ed = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="comment">//cout &lt;&lt; (double)(ed - st) / CLOCKS_PER_SEC &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = tot, ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid) &gt;= m) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p><img src="https://baka.online/wp-content/uploads/2019/06/TIM%E6%88%AA%E5%9B%BE20190610091735.png"> 个人认为T3最水。如果有一坨点可以形成一堆安全点对，那么它们一定在一个边双联通分量里。Tarjan求边双，把原图缩成一棵树。 加边的时候，会在树上形成一个环。现在环里的所有点都在一个边双里了。求出来增加了多少对就行。 增加的对数等于总对数减去原总对数。一共有$x$个点的话，总对数为$x(x-1)$。 两点间答案为$a[x]+a[y]-a[lca]-a[fa[lca]]$。 $O(n+qlogn)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125; g[N * <span class="number">2</span>], gg[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ghead[N], gtot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    g[++tot].to = y, g[tot].nxt = head[x],</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gaddedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    gg[++gtot].to = y, gg[gtot].nxt = ghead[x],</span><br><span class="line">    ghead[x] = gtot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[N], low[N], num;</span><br><span class="line"><span class="keyword">bool</span> bri[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y, i);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">            <span class="keyword">if</span> (low[y] &gt; low[x])</span><br><span class="line">                bri[i] = bri[i ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i != (fa ^ <span class="number">1</span>))</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[N], dcc, geshu[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    c[x] = dcc; ++geshu[c[x]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="keyword">if</span> (c[y]  bri[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id[N], son[N], father[N], top[N], snum, sz[N], dep[N];</span><br><span class="line"></span><br><span class="line">LL sum[N], lian_sum[N], lian_geshu[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    father[x] = fa; dep[x] = dep[fa] + <span class="number">1</span>; sz[x] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    sum[x] = geshu[x] * (geshu[x] - <span class="number">1</span>);</span><br><span class="line">    lian_sum[x] = lian_sum[fa] + sum[x];</span><br><span class="line"></span><br><span class="line">    lian_geshu[x] = lian_geshu[fa] + geshu[x];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ghead[x]; i; i = gg[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = gg[i].to;</span><br><span class="line">        <span class="keyword">if</span> (y == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y, x);</span><br><span class="line">        sz[x] += sz[y];</span><br><span class="line">        <span class="keyword">if</span> (sz[y] &gt; sz[son[x]])</span><br><span class="line">            son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line">    top[x] = topf; id[x] = ++num;</span><br><span class="line">    <span class="keyword">if</span> (!son[x]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], topf);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ghead[x]; i; i = gg[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = gg[i].to;</span><br><span class="line">        <span class="keyword">if</span> (y == father[x]  y == son[x])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(y, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]])</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">        x = father[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &lt; dep[y]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;map.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;map.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">rd</span>(); m = <span class="built_in">rd</span>(); q = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">addedge</span>(x, y);</span><br><span class="line">        <span class="built_in">addedge</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!c[i]) ++dcc, <span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">            <span class="keyword">if</span> (c[x] != c[y])</span><br><span class="line">                <span class="built_in">gaddedge</span>(c[x], c[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = c[<span class="built_in">rd</span>()], y = c[<span class="built_in">rd</span>()];</span><br><span class="line">        <span class="keyword">int</span> lca = <span class="built_in">get_lca</span>(x, y);</span><br><span class="line"></span><br><span class="line">        LL tmp_geshu = lian_geshu[x] + lian_geshu[y] - lian_geshu[lca] - lian_geshu[father[lca]],</span><br><span class="line">            tmp_sum = lian_sum[x] + lian_sum[y] - lian_sum[lca] - lian_sum[father[lca]];</span><br><span class="line">        ans += tmp_geshu * (tmp_geshu - <span class="number">1</span>) - tmp_sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>20190612垫底赛</title>
    <url>/2019/06/15/20190612%E5%9E%AB%E5%BA%95%E8%B5%9B/</url>
    <content><![CDATA[<p>最近的模拟赛越来越不NOIP了</p>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p><img src="https://baka.online/wp-content/uploads/2019/06/TIM%E6%88%AA%E5%9B%BE20190615174556.png"> 本次考试唯一水题。 可能在公共子序列里的数肯定在两个数列里都出现过。保留下都出现过的数。此时裸DP$O(n^2)$。 优化，在第二个数列里标出每个数在第一个数列里出现的位置。对于这个位置数列求最长上升子序列就是答案。树状数组优化，$O(nlogn)$。</p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p><img src="https://baka.online/wp-content/uploads/2019/06/TIM%E6%88%AA%E5%9B%BE20190615174607.png"> 洛谷上有，写了个没上密码的<a href="https://baka.online/%e8%b7%b3%e6%a5%bc%e6%9c%ba/">博客</a>。</p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p><img src="https://baka.online/wp-content/uploads/2019/06/TIM%E6%88%AA%E5%9B%BE20190615174613.png"> <img src="https://baka.online/wp-content/uploads/2019/06/TIM%E6%88%AA%E5%9B%BE20190615174627.png"> $O(n\sqrt n)$：求原数组和斐波那契数列前缀和之后，如果已经记录了$n$次修改，可以在$O(n)$的时间内进行一次查询（每次修改算一下对答案的贡献）。 把修改分成$\sqrt n$块，每块块内暴力查询，总复杂度$O(n\sqrt n)$。每块结束后把操作直接应用到原数组上，$O(n \sqrt n)$。 $O(nlogn)$：两种解法，蒟蒻觉得第一种好理解。斐波那契算出来通项，发现有根号，找出一个数使得$x^2 \equiv a \pmod p$，用$x$计算就可以了。通项的式子是可以叠加的，线段树+lazy tag维护。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>3-idiots</title>
    <url>/2019/07/01/3-idiots/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4609">3-idiots</a> 要找组成三角形的方案，就求总方案，减去不合法方案。 枚举三角形最长边，如果其它两条边之和小于它，那么不合法。 总方案数明显是$C_n^3$。 求所有两边之和，可以FFT。 FFT搞完之后，自己加自己被算了两次，减去。$i+j$和$j+i$都被计算了，减半。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123  &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">2333</span>, P = <span class="number">998244353</span>, G = <span class="number">3</span>, Gi = <span class="number">332748118</span>;</span><br><span class="line"><span class="keyword">int</span> sti[N]; LL cnt[N];</span><br><span class="line"><span class="keyword">int</span> lim, L, rev[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">fpow</span><span class="params">(LL x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    LL ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = x * x % P)</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = ret * x % P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Noob_TLE_TLE</span><span class="params">(LL f[], <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i])</span><br><span class="line">            std::<span class="built_in">swap</span>(f[i], f[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        LL T = <span class="built_in">fpow</span>(o == <span class="number">1</span> ? G : Gi, (P - <span class="number">1</span>) / (i &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += (i &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            LL w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k, w = w * T % P) &#123;</span><br><span class="line">                LL nx = f[j + k], ny = w * f[i + j + k] % P;</span><br><span class="line">                f[j + k] = (nx + ny) % P;</span><br><span class="line">                f[i + j + k] = (nx - ny + P) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lim = <span class="number">1</span>; L = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">rd</span>(), max_val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ++cnt[sti[i] = <span class="built_in">rd</span>()];</span><br><span class="line">        max_val = std::<span class="built_in">max</span>(max_val, sti[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lim &lt;= max_val &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; ++i)</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>)  ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Noob_TLE_TLE</span>(cnt, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        cnt[i] = cnt[i] * cnt[i] % P;</span><br><span class="line">    <span class="built_in">Noob_TLE_TLE</span>(cnt, <span class="number">-1</span>);</span><br><span class="line">    LL inv = <span class="built_in">fpow</span>(lim, P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        cnt[i] = cnt[i] * inv % P;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        --cnt[sti[i] &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max_val; ++i)</span><br><span class="line">        cnt[i] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max_val; ++i)</span><br><span class="line">        cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    LL all = (LL)n * (n - <span class="number">1</span>) * (n - <span class="number">2</span>) / <span class="number">6</span>, ans = all;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ans -= cnt[sti[i]];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.7f\n&quot;</span>, (<span class="keyword">double</span>)ans / all);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">love</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">love</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>Ahoi2008紧急集合</title>
    <url>/2019/02/16/ahoi2008%E7%B4%A7%E6%80%A5%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1787">[Ahoi2008]Meet 紧急集合</a> 随便选一个点做根，跑出每个点的深度。对于每次查询，找出三个点中深度最深的那个，因为比较深的点离两个点近一个远，剩下的两远一近，所以即为答案。 写了个树剖，一开始写线段树几十行= =….后来发现ans直接把三个点深度加起来减去三个点lca深度就行了….日常愚蠢1/1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123&#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">0</span>;<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))a=c==<span class="string">&#x27;-&#x27;</span>?<span class="number">0</span>:<span class="number">1</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))b=b*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> a?b:-b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">500000</span>+<span class="number">2333</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> to,nxt;</span><br><span class="line">    &#125;g[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> n,m,head[N],tot;</span><br><span class="line">    <span class="keyword">int</span> fa[N],top[N],son[N],dis[N],size[N],id[N],num;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> l,r,sum;</span><br><span class="line">    &#125;t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        g[++tot].to=y,g[tot].nxt=head[x],head[x]=tot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">        fa[x]=f,dis[x]=dis[f]+<span class="number">1</span>,size[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxson=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x],y=g[i].to;i;i=g[i].nxt,y=g[i].to)</span><br><span class="line">            <span class="keyword">if</span>(y!=f)&#123;</span><br><span class="line">                <span class="built_in">dfs1</span>(y,x),size[x]+=size[y];</span><br><span class="line">                <span class="keyword">if</span>(size[y]&gt;maxson)maxson=size[y],son[x]=y;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> topf)</span></span>&#123;</span><br><span class="line">        id[x]=++num,top[x]=topf;</span><br><span class="line">        <span class="keyword">if</span>(son[x])&#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(son[x],topf);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x],y=g[i].to;i;i=g[i].nxt,y=g[i].to)</span><br><span class="line">                <span class="keyword">if</span>(y!=fa[x]&amp;&amp;y!=son[x])</span><br><span class="line">                    <span class="built_in">dfs2</span>(y,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">queryLca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[top[x]]&lt;dis[top[y]])<span class="built_in">swap</span>(x,y);</span><br><span class="line">            x=fa[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dis[x]&lt;dis[y])<span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=<span class="built_in">rd</span>(),y=<span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">addedge</span>(x,y),<span class="built_in">addedge</span>(y,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>),<span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=<span class="built_in">rd</span>(),y=<span class="built_in">rd</span>(),z=<span class="built_in">rd</span>();</span><br><span class="line">            <span class="keyword">int</span> a=<span class="built_in">queryLca</span>(x,y),b=<span class="built_in">queryLca</span>(x,z),c=<span class="built_in">queryLca</span>(y,z),lca=a;</span><br><span class="line">            <span class="keyword">if</span>(dis[b]&gt;dis[lca])lca=b;</span><br><span class="line">            <span class="keyword">if</span>(dis[c]&gt;dis[lca])lca=c;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,lca,dis[x]+dis[y]+dis[z]-dis[a]-dis[b]-dis[c]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>AH2017/HNOI2017影魔</title>
    <url>/2019/06/10/ah2017-hnoi2017%E5%BD%B1%E9%AD%94/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3722">[AH2017/HNOI2017]影魔</a> 如果可以求出来所有对答案有贡献的区间，原问题就是一个二维数点。 题目中对区间的判断很麻烦。首先，一个区间，需要两个端点，$O(n^2)$。所以需要用其它东西表示区间。 用区间内最高的点表示区间。用$L[i],R[i]$分别表示$i$左右第一个比它高的点的位置。由题意，对于$p1$，$[L[i],R[i]]$是满足条件的。对于$p2$，$[L[i]+1 \sim i - 1,R[i]]$和$[L[i],i+1 \sim R[i]-1]$是满足条件的。 用单调栈$O(n)$求出$L[i],R[i]$。因为本题只有询问，离线做就可以。 对于前两种区间，可以从左向右扫，扫到$R[i]$时，处理$L[i]$方向的贡献。第三种区间可以从右向左扫。 也可以扫一次解决。具体来说，就是把一个询问拆成两个询问，在$l-1$处与$r$处分别减加。 本题中，相邻的两个数字可以产生一对$p1$贡献，上述方法中并没有处理，这个直接加上就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200000</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> val[N * <span class="number">4</span>], lazy[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lazy[p]) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        val[p * <span class="number">2</span>] += lazy[p] * (mid - l + <span class="number">1</span>);</span><br><span class="line">        val[p * <span class="number">2</span> + <span class="number">1</span>] += lazy[p] * (r - mid);</span><br><span class="line">        lazy[p * <span class="number">2</span>] += lazy[p];</span><br><span class="line">        lazy[p * <span class="number">2</span> + <span class="number">1</span>] += lazy[p];</span><br><span class="line">        lazy[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    val[p] = val[p * <span class="number">2</span>] + val[p * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v, <span class="keyword">int</span> sl, <span class="keyword">int</span> sr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= sl &amp;&amp; r &gt;= sr) &#123;</span><br><span class="line">        val[p] += v * (sr - sl + <span class="number">1</span>);</span><br><span class="line">        lazy[p] += v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(p, sl, sr);</span><br><span class="line">        <span class="keyword">int</span> mid = (sl + sr) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">            <span class="built_in">add</span>(p * <span class="number">2</span>, l, r, v, sl, mid);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">            <span class="built_in">add</span>(p * <span class="number">2</span> + <span class="number">1</span>, l, r, v, mid + <span class="number">1</span>, sr);</span><br><span class="line">        <span class="built_in">pushup</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> sl, <span class="keyword">int</span> sr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= sl &amp;&amp; r &gt;= sr)</span><br><span class="line">        <span class="keyword">return</span> val[p];</span><br><span class="line">    <span class="built_in">pushdown</span>(p, sl, sr);</span><br><span class="line">    <span class="keyword">int</span> mid = (sl + sr) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">        ret += <span class="built_in">query</span>(p * <span class="number">2</span>, l, r, sl, mid);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">        ret += <span class="built_in">query</span>(p * <span class="number">2</span> + <span class="number">1</span>, l, r, mid + <span class="number">1</span>, sr);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p1, p2;</span><br><span class="line"><span class="keyword">int</span> power[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(); m = <span class="built_in">rd</span>(); p1 = <span class="built_in">rd</span>(); p2 = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        power[i] = <span class="built_in">rd</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> st[N], top;</span><br><span class="line"><span class="keyword">int</span> L[N], R[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c, d;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _a = <span class="number">0</span>, <span class="keyword">int</span> _b = <span class="number">0</span>, <span class="keyword">int</span> _c = <span class="number">0</span>, <span class="keyword">int</span> _d = <span class="number">0</span>) &#123;</span><br><span class="line">        a = _a; b = _b; c = _c; d = _d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Node&gt; c[N], q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    st[top = <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; power[i] &gt; power[st[top]])</span><br><span class="line">            --top;</span><br><span class="line">        L[i] = st[top];</span><br><span class="line">        st[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    st[top = <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; power[i] &gt; power[st[top]])</span><br><span class="line">            --top;</span><br><span class="line">        R[i] = st[top];</span><br><span class="line">        st[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L[i] &gt;= <span class="number">1</span> &amp;&amp; R[i] &lt;= n)</span><br><span class="line">            c[R[i]].<span class="built_in">push_back</span>(<span class="built_in">Node</span>(L[i], L[i], p1));</span><br><span class="line">        <span class="keyword">if</span> (L[i] &lt; i - <span class="number">1</span> &amp;&amp; R[i] &lt;= n)</span><br><span class="line">            c[R[i]].<span class="built_in">push_back</span>(<span class="built_in">Node</span>(L[i] + <span class="number">1</span>, i - <span class="number">1</span>, p2));</span><br><span class="line">        <span class="keyword">if</span> (L[i] &gt;= <span class="number">1</span> &amp;&amp; R[i] &gt; i + <span class="number">1</span>)</span><br><span class="line">            c[L[i]].<span class="built_in">push_back</span>(<span class="built_in">Node</span>(i + <span class="number">1</span>, R[i] - <span class="number">1</span>, p2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">rd</span>(), r = <span class="built_in">rd</span>();</span><br><span class="line">        q[l - <span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">Node</span>(l, r, i, <span class="number">-1</span>));</span><br><span class="line">        q[r].<span class="built_in">push_back</span>(<span class="built_in">Node</span>(l, r, i, <span class="number">1</span>));</span><br><span class="line">        ans[i] += (<span class="keyword">long</span> <span class="keyword">long</span>)(r - l) * p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; c[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            Node o = c[i][j];</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">1</span>, o.a, o.b, o.c, <span class="number">1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; q[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            Node o = q[i][j];</span><br><span class="line">            ans[o.c] += o.d * <span class="built_in">query</span>(<span class="number">1</span>, o.a, o.b, <span class="number">1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>AHOI2009中国象棋</title>
    <url>/2019/02/10/ahoi2009%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2051">[AHOI2009]中国象棋</a> 我可能学了假DP…我好菜 因为方案数与具体摆放方案无关，f[i][j][k][t]表示前i行，此时有j列0个，k1个，t2个。因为t可由jk算出，省略这一维。 分别考虑放0个，1个，2个，转移。具体看代码注释…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">110</span>][<span class="number">110</span>][<span class="number">110</span>], n, m, ans;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MOD = <span class="number">9999973</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    f[<span class="number">0</span>][m][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; j + k &lt;= m; ++k) &#123;</span><br><span class="line">                <span class="comment">// 0个</span></span><br><span class="line">                f[i][j][k] += f[i - <span class="number">1</span>][j][k];</span><br><span class="line">                <span class="comment">// 1个</span></span><br><span class="line">                <span class="keyword">if</span> (k - <span class="number">1</span> &gt;= <span class="number">0</span>) <span class="comment">// 放在0</span></span><br><span class="line">                    f[i][j][k] += f[i - <span class="number">1</span>][j + <span class="number">1</span>][k - <span class="number">1</span>] * (j + <span class="number">1</span>);</span><br><span class="line">                f[i][j][k] += f[i - <span class="number">1</span>][j][k + <span class="number">1</span>] * (k + <span class="number">1</span>); <span class="comment">// 放在1</span></span><br><span class="line">                <span class="comment">// 2个</span></span><br><span class="line">                <span class="keyword">if</span> (k - <span class="number">2</span> &gt;= <span class="number">0</span>) <span class="comment">// 放在0 0</span></span><br><span class="line">                    f[i][j][k] += f[i - <span class="number">1</span>][j + <span class="number">2</span>][k - <span class="number">2</span>] * (j + <span class="number">2</span>) * (j + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                f[i][j][k] += f[i - <span class="number">1</span>][j][k + <span class="number">2</span>] * (k + <span class="number">2</span>) * (k + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 放在1 1</span></span><br><span class="line">                f[i][j][k] += f[i - <span class="number">1</span>][j + <span class="number">1</span>][k] * (j + <span class="number">1</span>) * k; <span class="comment">// 放在0 1</span></span><br><span class="line">                f[i][j][k] %= MOD;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; i + j &lt;= m; ++j)</span><br><span class="line">            ans += f[n][i][j];</span><br><span class="line">    cout &lt;&lt; ans % MOD &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>AHOI2013连通图</title>
    <url>/2019/07/02/ahoi2013%E8%BF%9E%E9%80%9A%E5%9B%BE/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P5227">[AHOI2013]连通图</a> 线段树分治，先把不存在于任何集合的边加上，然后处理左边的时候把右边出现左边没出现的边加上，以此类推。分治到底的时候并查集判一下。判断很简单，随便一个点find一下，size是n就联通。并查集需要可撤销操作的，记录每次unite操作，栈存一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123  &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">2333</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; edge[N];</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; exist[N];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; set[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N], size[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, fa_x, size_y;</span><br><span class="line">    <span class="built_in">Change</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Change</span>(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y, <span class="keyword">int</span> _fa_x, <span class="keyword">int</span> _size_y) &#123;</span><br><span class="line">        x = _x; y = _y;</span><br><span class="line">        fa_x = _fa_x;</span><br><span class="line">        size_y = _size_y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Change stack[N];</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (size[x] &gt; size[y])</span><br><span class="line">        std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    stack[++top] = <span class="built_in">Change</span>(x, y, fa[x], size[y]);</span><br><span class="line">    fa[x] = y; size[y] += size[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">undo</span><span class="params">(<span class="keyword">int</span> ver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; ver) &#123;</span><br><span class="line">        fa[stack[top].x] = stack[top].fa_x;</span><br><span class="line">        size[stack[top].y] = stack[top].size_y;</span><br><span class="line">        --top;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(size[<span class="built_in">find</span>(<span class="number">1</span>)] == n ? <span class="string">&quot;Connected&quot;</span> : <span class="string">&quot;Disconnected&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, ver = top;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; set[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            std::vector&lt;<span class="keyword">int</span>&gt;::iterator x</span><br><span class="line">                = std::<span class="built_in">lower_bound</span>(exist[set[i][j]].<span class="built_in">begin</span>(), exist[set[i][j]].<span class="built_in">end</span>(), l);</span><br><span class="line">            <span class="keyword">if</span> (x != exist[set[i][j]].<span class="built_in">end</span>() &amp;&amp; *x &lt;= mid)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">unite</span>(edge[set[i][j]].x, edge[set[i][j]].y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(l, mid);</span><br><span class="line">    <span class="built_in">undo</span>(ver);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= mid; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; set[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            std::vector&lt;<span class="keyword">int</span>&gt;::iterator x</span><br><span class="line">                = std::<span class="built_in">upper_bound</span>(exist[set[i][j]].<span class="built_in">begin</span>(), exist[set[i][j]].<span class="built_in">end</span>(), mid);</span><br><span class="line">            <span class="keyword">if</span> (x != exist[set[i][j]].<span class="built_in">end</span>() &amp;&amp; *x &lt;= r)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">unite</span>(edge[set[i][j]].x, edge[set[i][j]].y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">undo</span>(ver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">love</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(); m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        edge[i].x = <span class="built_in">rd</span>();</span><br><span class="line">        edge[i].y = <span class="built_in">rd</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    k = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">rd</span>(); j; --j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">rd</span>();</span><br><span class="line">            set[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">            exist[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">            vis[x] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        std::<span class="built_in">sort</span>(exist[i].<span class="built_in">begin</span>(), exist[i].<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        size[fa[i] = i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            <span class="built_in">unite</span>(edge[i].x, edge[i].y);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">love</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>AHOI2014/JSOI2014宅男计划</title>
    <url>/2019/06/08/ahoi2014-jsoi2014%E5%AE%85%E7%94%B7%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4040">[AHOI2014/JSOI2014]宅男计划</a> 又是不会做的题呢… 点外卖次数和存活时间是一个单峰函数…虽然大概能猜出来，可是不会证啊…网上看了一圈也没发现证明，算了…听说这题出题人说要猜结论…… 已知它是单峰函数，就可以三分点外卖次数。然后贪心求最长存活时间。 因为每天都要吃东西，应该先买最便宜的。把食物按价格排序，然后有以下贪心结论： 把钱均分给每一次点外卖，效果最好。 从价格小到大考虑每种物品，买到不能再多买最好。 剩下的钱凑在一起，给每一次点外卖加食物，能买多少买多少，买到没钱就行了。 就可做了。这题有个小坑点，保存0天的食物==可以当天吃的食物。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Food</span> &#123;</span> LL p, s; &#125; food[<span class="number">210</span>];</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Food &amp;x, <span class="keyword">const</span> Food &amp;y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x.p == y.p ? x.s &gt; y.s : x.p &lt; y.p;</span><br><span class="line">&#125;</span><br><span class="line">LL m, f; <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">check</span><span class="params">(LL tot)</span> </span>&#123;</span><br><span class="line">    LL money = m - tot * f, per = money / tot, left = money % tot,</span><br><span class="line">        day = <span class="number">0</span>, extension = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (money &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (food[i].s &gt;= day &amp;&amp; per &gt;= food[i].p) &#123;</span><br><span class="line">            LL buy = <span class="built_in">min</span>(food[i].s - day + <span class="number">1</span>, per / food[i].p);</span><br><span class="line">            day += buy;</span><br><span class="line">            per -= food[i].p * buy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    left += per * tot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (food[i].s &gt;= day &amp;&amp; left &gt;= food[i].p) &#123;</span><br><span class="line">            LL buy = <span class="built_in">min</span>(tot, left / food[i].p);</span><br><span class="line">            extension += buy;</span><br><span class="line">            left -= buy * food[i].p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> day * tot + extension;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; f &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; food[i].p &gt;&gt; food[i].s;</span><br><span class="line">    <span class="built_in">sort</span>(food + <span class="number">1</span>, food + n + <span class="number">1</span>);</span><br><span class="line">    LL l = <span class="number">1</span>, r = m / f + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        LL delta = r - l, mid_l = l + delta / <span class="number">3</span>, mid_r = r - delta / <span class="number">3</span>,</span><br><span class="line">            ans_l = <span class="built_in">check</span>(mid_l), ans_r = <span class="built_in">check</span>(mid_r);</span><br><span class="line">        <span class="keyword">if</span> (ans_l &lt; ans_r) l = mid_l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid_r - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (LL i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        LL day = <span class="built_in">check</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (day &gt;= ans) ans = day;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>APIO2010特别行动队</title>
    <url>/2019/05/17/apio2010%E7%89%B9%E5%88%AB%E8%A1%8C%E5%8A%A8%E9%98%9F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3628">[APIO2010]特别行动队</a> 斜率优化DP。 求个前缀和，然后由题意，$f[i]=max(f[j]+a(sum[i]-sum[j])^2+b(sum[i]-sum[j])+c)$。 拆开，变成$f[j]+asum[j]^2-bsum[j]=2asum[i]sum[j]+f[i]-asum[i]^2-bsum[i]-c$。这题要求的是最大值，所以维护的是上凸包。 写这个博客主要是因为，突然发现，写个$slope$函数求斜率，代码特别短23333333333。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">233</span>;</span><br><span class="line">LL n, f[N], a, b, c, sum[N], que[N], l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">pow</span><span class="params">(LL x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="function">LL <span class="title">X</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> f[x] + a * <span class="built_in">pow</span>(sum[x]) - b * sum[x]; &#125;</span><br><span class="line"><span class="function">LL <span class="title">Y</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> sum[x]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> (<span class="keyword">double</span>)(<span class="built_in">X</span>(x) - <span class="built_in">X</span>(y)) / (<span class="built_in">Y</span>(x) - <span class="built_in">Y</span>(y)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;n, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, sum + i);</span><br><span class="line">        sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">slope</span>(que[l], que[l + <span class="number">1</span>]) &gt; <span class="number">2</span> * a * sum[i])</span><br><span class="line">            ++l;</span><br><span class="line">        f[i] = f[que[l]] + a * <span class="built_in">pow</span>(sum[i] - sum[que[l]]) + b * (sum[i] - sum[que[l]]) + c;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">slope</span>(que[r - <span class="number">1</span>], que[r]) &lt; <span class="built_in">slope</span>(que[r], i))</span><br><span class="line">            --r;</span><br><span class="line">        que[++r] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>APIO2014回文串</title>
    <url>/2019/06/18/apio2014%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3649">[APIO2014]回文串</a> 回文自动机裸题，我写了，一次秒了，有什么好说的 实际上蒟蒻并不会回文自动机……….manacher也能过….. manacher求出所有回文串。把每个回文串都求一下出现了多少次就行。 求法1：SA 二分求height边界就行了。 求法2：SAM 暴力跑，然后显然TLE了。考虑在parent树上倍增，跳到不能跳为止（条件是len&gt;=r-l+1）。此时这个点的size就是出现次数。 前两种都是$O(nlogn)$。 求法3：Hash 复杂度多个$log$……..，据说有人用Hash卡过去了……….. SA做法的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300000</span> + <span class="number">2333</span>;</span><br><span class="line"><span class="keyword">char</span> str[N]; <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[N], y[N], sa[N], ht[N], rk[N], c[N], st[N][<span class="number">25</span>], top, lg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_sa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i] = str[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;z&#x27;</span>; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>, k = <span class="number">1</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>, p = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; ++i) y[++p] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt; k) y[++p] = sa[i] - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[y[i]]]--] = y[i];</span><br><span class="line">        <span class="built_in">swap</span>(x, y); x[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            x[sa[i]] = y[sa[i]] == y[sa[i - <span class="number">1</span>]]</span><br><span class="line">                &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]</span><br><span class="line">                ? p : ++p;</span><br><span class="line">        <span class="keyword">if</span> (p == n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rk[sa[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, p = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (p) --p;</span><br><span class="line">        j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (str[i + p] == str[j + p])</span><br><span class="line">            ++p;</span><br><span class="line">        ht[rk[i]] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) st[i][<span class="number">0</span>] = ht[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i)</span><br><span class="line">            st[i][j] = <span class="built_in">min</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[N * <span class="number">2</span>], s[N * <span class="number">2</span>] = &#123; <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;#&#x27;</span> &#125;, tot = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = lg[y - x + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(st[x][t], st[y - (<span class="number">1</span> &lt;&lt; t) + <span class="number">1</span>][t]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r, left, right, mid;</span><br><span class="line">    <span class="keyword">if</span> (ht[pos + <span class="number">1</span>] &lt; len)</span><br><span class="line">        right = pos;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        l = pos + <span class="number">1</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">lcp</span>(pos + <span class="number">1</span>, mid) &gt;= len)</span><br><span class="line">                right = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ht[pos] &lt; len) left = pos;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        l = <span class="number">1</span>, r = pos - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">lcp</span>(mid + <span class="number">1</span>, pos) &gt;= len)</span><br><span class="line">                left = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        s[++tot] = str[i], s[++tot] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, mid = <span class="number">0</span>, r = <span class="number">0</span>; i &lt;= tot; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; r) p[i] = <span class="built_in">min</span>(p[mid * <span class="number">2</span> - i], r - i);</span><br><span class="line">        <span class="keyword">else</span> p[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s[i - p[i]] == s[i + p[i]])</span><br><span class="line">            ++p[i];</span><br><span class="line">        <span class="keyword">if</span> (p[i] + i &gt; r) r = p[i] + i, mid = i;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, (<span class="keyword">long</span> <span class="keyword">long</span>)(p[i] - <span class="number">1</span>) *</span><br><span class="line">            <span class="built_in">calc</span>(rk[(i - p[i] + <span class="number">2</span>) / <span class="number">2</span>], p[i] - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>); n = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build_sa</span>(); <span class="built_in">build_height</span>(); <span class="built_in">manacher</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>APIO2016划艇 离散化DP</title>
    <url>/2019/12/18/apio2016%E5%88%92%E8%89%87-%E7%A6%BB%E6%95%A3%E5%8C%96dp/</url>
    <content><![CDATA[<p><a href="http://uoj.ac/problem/204">[APIO2016]划艇</a> 考虑一个大暴力：令$f_{i,j}$表示前$i$个，强制选$i$，选的数是$j$的答案 $$f_{i,j} = \sum_{a &lt; i, b &lt; j} f_{a,b}$$ 值域很大，离散化。为了方便表示，把区间表示为$[l,r)$的形式。 那么定义$f_{i,j}$表示前$i$个，选择了$[w_j,w_{j+1})$这段区间。 $$f_{i,j} = \sum_{a &lt; i, b &lt; j} f_{a,b} ?$$ $?$是一个数。把这个DP式子的含义记为，钦定了$a$位置选在$b$区间，$a$位置之前选的是$ &lt; j $的，$a$位置之后选$j$区间或不选的方案数。 考虑$n$个数里选一些，再选一些$0$，排成非$0$位置递增序列的方案数。 $$\binom{n + m}{m}$$ 意思是说，我们把$n$个数和$m$个$0$放在一起，选$m$个出来。如果是选了第$i$个$0$，就把位置$i$方成$0$。剩下取出来的数字显然确定了放在哪里和怎么放。 $$f_{i,j} = \sum_{a &lt; i, b &lt; j} f_{i,j} \binom{w_{j+1} - w_j - 1 + k}{k}$$ 其中，$k$是有几个数可选区间包含当前考虑的区间。 其实这个方案数也可以直接算（范德蒙德卷积）： $$\sum_{i=0}^m \binom{n}{i} \binom{m}{i} = \binom{n+m}{n}$$ 前缀和优化一下就$O(n^3)$了</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>APIO2016烟火表演 可并堆</title>
    <url>/2020/08/12/apio2016%E7%83%9F%E7%81%AB%E8%A1%A8%E6%BC%94-%E5%8F%AF%E5%B9%B6%E5%A0%86/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3642">[APIO2016]烟火表演</a> 大约是退役前最后一篇题解，把之前的坑填上。只说一下思路，细节可以看其它题解 首先考虑一个DP：令$f_{x,i}$表示$x$点，到叶子的长度为$i$的最小代价。那么考虑合并，有$f_{x,i} = \min_{j \leq i} f_{y,j} + i-(j+c)$。 考虑把这个DP分步进行：首先把到父亲的边加上，之后合并。令加上到父亲边后的函数为$g$ 可以注意到，$f$是一个凸函数。并且这个函数的斜率是整数。可以感性理解这个结论：当长度变化时到一定阶段时，需要调整更多的边。并且每条边的代价都是$1$。 那么考虑对$g$的求解：小于$\min f$时，只调整父亲边，大于时使用$\min f$并调整父亲边。中间部分是平的。核心思想就是使用靠近$\min f$的值 注意到分界点数量是$O(n)$的，可以维护分界点。每次合并分为以下过程：找到平的一段，把它后面的删掉，在平的前后各插入一条线。 于是用可并堆维护分界点即可。有几个地方：</p>
<ol>
<li>如何维护分界点：假设每个点都让斜率+1即可</li>
<li>如何找到平的一段：根据做法归纳可知只需弹掉度数-1个</li>
<li>如何修改分界点：注意到需要做的操作是加入斜率为-1的一段，可以平移它后面的一段（即min）实现</li>
<li>如何求答案：答案即到父亲边权为0的值，即根平的那一段的值。用边权和可以推出</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p[N], c[N], deg[N];</span><br><span class="line"><span class="keyword">int</span> ls[N], rs[N], root[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> val[N];</span><br><span class="line"><span class="keyword">int</span> now;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!x  !y) <span class="keyword">return</span> x + y;</span><br><span class="line">  <span class="keyword">if</span> (val[x] &lt; val[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">  rs[x] = <span class="built_in">merge</span>(rs[x], y);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">rand</span>() &amp; <span class="number">1</span>) std::<span class="built_in">swap</span>(ls[x], rs[x]);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">merge</span>(ls[x], rs[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">srand</span>(<span class="number">114514</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n + m; ++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, p + i, c + i), ++deg[p[i]];</span><br><span class="line">  now = n + m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x = n + m; x &gt; <span class="number">1</span>; --x) &#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= n) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; deg[x]; ++i)</span><br><span class="line">        root[x] = <span class="built_in">pop</span>(root[x]);</span><br><span class="line">      r = val[root[x]], root[x] = <span class="built_in">pop</span>(root[x]);</span><br><span class="line">      l = val[root[x]], root[x] = <span class="built_in">pop</span>(root[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    val[++now] = l + c[x];</span><br><span class="line">    val[++now] = r + c[x];</span><br><span class="line">    root[p[x]] = <span class="built_in">merge</span>(root[p[x]], <span class="built_in">merge</span>(root[x], <span class="built_in">merge</span>(now - <span class="number">1</span>, now)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= deg[<span class="number">1</span>]; ++i)</span><br><span class="line">    root[<span class="number">1</span>] = <span class="built_in">pop</span>(root[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n + m; ++i)</span><br><span class="line">    ans += c[i];</span><br><span class="line">  <span class="keyword">while</span> (root[<span class="number">1</span>])</span><br><span class="line">    ans -= val[root[<span class="number">1</span>]], root[<span class="number">1</span>] = <span class="built_in">pop</span>(root[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>APIO2018 铁人两项</title>
    <url>/2019/07/22/apio2018-%E9%93%81%E4%BA%BA%E4%B8%A4%E9%A1%B9/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4630">[APIO2018] 铁人两项</a> 实际上一个点双内任意指定三个点，都可以找出经过这三个点的一条道路。证明很神仙，看到一个用网络流，最大流最小割证明的。 有了这个性质，建圆方树，给方点赋值为点双大小，圆点为$-1$，这样两点间路径就是方案数了。 变枚举路径为枚举中间点。$O(n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200000</span> + <span class="number">2333</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125; g[N * <span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> ghead[N], thead[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> head[], <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    g[++tot].to = y, g[tot].nxt = head[x],</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> all, dfn[N], low[N], cnt, num, stk[N], top, val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++num;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">    ++all;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ghead[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">            <span class="keyword">if</span> (low[y] == dfn[x]) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">0</span>; z != y; --top) &#123;</span><br><span class="line">                    z = stk[top];</span><br><span class="line">                    <span class="built_in">addedge</span>(thead, cnt, z);</span><br><span class="line">                    <span class="built_in">addedge</span>(thead, z, cnt);</span><br><span class="line">                    ++val[cnt];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">addedge</span>(thead, cnt, x);</span><br><span class="line">                <span class="built_in">addedge</span>(thead, x, cnt);</span><br><span class="line">                ++val[cnt];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="keyword">int</span> siz[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    siz[x] = x &lt;= n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = thead[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="keyword">if</span> (y != fa) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(y, x);</span><br><span class="line">            ans += <span class="number">2LL</span> * siz[x] * siz[y] * val[x];</span><br><span class="line">            siz[x] += siz[y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += <span class="number">2LL</span> * siz[x] * (all - siz[x]) * val[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        val[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">addedge</span>(ghead, x, y);</span><br><span class="line">        <span class="built_in">addedge</span>(ghead, y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) &#123;</span><br><span class="line">            all = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line">            <span class="built_in">dfs</span>(i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>Beauty Contest</title>
    <url>/2019/01/05/beauty-contest/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1452">Beauty Contest</a> 给定平面上很多点，求最远两点之间距离的平方 凸包是可以把平面上所有点包起来的凸多边形，可以想象为用橡皮筋在外面套了一圈 最远两点一定在凸包上，因为如果不在凸包上的话可以被凸包上更远的点替代 所以，这道题首先要找出凸包 凸包满足斜率单调的性质，Graham扫描法用一个栈来维护答案，把点排序，最左下方的点一定在凸包中。按顺序扫描，加入新点后弹出之前的点，直到满足斜率单调 如果按照坐标排序，这样会只取到凸包的一半，所以分成上下两部分跑两次即可（当然也可以用极角排序 <a href="https://oi.men.ci/geometry-notes/">计算几何学习笔记</a> 本题数据较弱且随机，所以求解最远距离时可以直接枚举两点，虽然理论上会被卡到$O(N^2)$，但是在本题表现良好，复杂度很低 第二种求解最远距离的方法叫旋转卡壳，用两条平行线卡住凸包上两个相对的点求解最大值 <a href="https://blog.csdn.net/u012328159/article/details/50809014">旋转卡壳–求凸包最大直径</a> 实现时让一条线与一条边重合，面积最大距离最远求最远点，而面积可以直接用叉积计算，因为只扫一遍整个凸包，可以快速解决问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123&#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">0</span>;<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))a=c==<span class="string">&#x27;-&#x27;</span>?<span class="number">0</span>:<span class="number">1</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))b=b*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> a?b:-b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">50000</span>+<span class="number">233</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="built_in">Vec</span>(<span class="keyword">int</span> _x=<span class="number">0</span>,<span class="keyword">int</span> _y=<span class="number">0</span>)&#123;x=_x;y=_y;&#125;</span><br><span class="line">        Vec <span class="keyword">operator</span>-(<span class="keyword">const</span> Vec &amp;p)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="built_in">Vec</span>(x-p.x,y-p.y);&#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Vec &amp;p)<span class="keyword">const</span>&#123;<span class="keyword">return</span> x==p.x?y&lt;p.y:x&lt;p.x;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Vec pt[MAXN];</span><br><span class="line">    <span class="keyword">int</span> n,stack[MAXN],top,ab[MAXN],tot2,ans;</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Vec &amp;a,<span class="keyword">const</span> Vec &amp;b)</span></span>&#123;<span class="keyword">return</span> a.x*b.y-a.y*b.x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cross</span>(pt[b]-pt[a],pt[c]-pt[b])&lt;=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">const</span> Vec &amp;a,<span class="keyword">const</span> Vec &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(a.x-b.x)+<span class="built_in">pow</span>(a.y-b.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        n=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            pt[i].x=<span class="built_in">rd</span>(),pt[i].y=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">sort</span>(pt+<span class="number">1</span>,pt+n+<span class="number">1</span>);</span><br><span class="line">        stack[++top]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(top&gt;<span class="number">1</span>&amp;&amp;<span class="built_in">check</span>(stack[top<span class="number">-1</span>],stack[top],i))--top;</span><br><span class="line">            stack[++top]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=top;++i)&#123;</span><br><span class="line">            ab[++tot2]=stack[i];</span><br><span class="line">            vis[stack[i]]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack[top=<span class="number">1</span>]=n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;--i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(top&gt;<span class="number">1</span>&amp;&amp;<span class="built_in">check</span>(stack[top<span class="number">-1</span>],stack[top],i))--top;</span><br><span class="line">            stack[++top]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=top;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[stack[i]])</span><br><span class="line">                ab[++tot2]=stack[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tot2==<span class="number">2</span>)</span><br><span class="line">            ans=<span class="built_in">get_dis</span>(pt[ab[<span class="number">1</span>]],pt[ab[<span class="number">2</span>]]);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ab[tot2+<span class="number">1</span>]=ab[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(;i&lt;=tot2;++i)&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="built_in">cross</span>(pt[ab[i]]-pt[ab[i+<span class="number">1</span>]],pt[ab[i]]-pt[ab[j]])&lt;</span><br><span class="line">                <span class="built_in">cross</span>(pt[ab[i]]-pt[ab[i+<span class="number">1</span>]],pt[ab[i]]-pt[ab[j+<span class="number">1</span>]]))</span><br><span class="line">                    j=j%tot2+<span class="number">1</span>;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,<span class="built_in">max</span>(<span class="built_in">get_dis</span>(pt[ab[i]],pt[ab[j]]),<span class="built_in">get_dis</span>(pt[ab[i+<span class="number">1</span>]],pt[ab[j]])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 这一段是暴力求法</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;=tot2;++i)&#123;</span></span><br><span class="line"><span class="comment">            for(int j=i+1;j&lt;=tot2;++j)&#123;</span></span><br><span class="line"><span class="comment">                ans=max(ans,get_dis(pt[ab[i]],pt[ab[j]]));</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>BeiJing wc2012冻结</title>
    <url>/2019/02/16/beijing-wc2012%E5%86%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2662">[BeiJing wc2012]冻结</a> 这种对边有限制的题一般都是套路题。。。然而昨考试的时候刚想出来就到时间了。。。果然我还是young &amp; naive。。。 言归正传，对于这种题，一般有一种特点：要求的数量都很小。比如这道题，最多只能缩短50条边。 于是有两种套路，一种是dp，开个二维数组dis[x][k]，表示x点使用k张卡的最优状态，跑最短路转移即可。 另一种在网络流里比较常见：拆点。具体说，就是把这张图拆成50张图，构成分层图，连有向的长度为一半的边，直接跑最短路。 写的时候采用了第二种做法，感觉良好= =</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123&#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">0</span>;<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))a=c==<span class="string">&#x27;-&#x27;</span>?<span class="number">0</span>:<span class="number">1</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))b=b*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> a?b:-b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n,m,k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5000</span>,M=<span class="number">100000</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> to,nxt,c;</span><br><span class="line">    &#125;g[M*<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N],tot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        g[++tot].to=y,g[tot].c=c,g[tot].nxt=head[x],head[x]=tot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> id[<span class="number">60</span>][<span class="number">60</span>], num;</span><br><span class="line">    <span class="keyword">int</span> dis[M];</span><br><span class="line">    <span class="keyword">bool</span> vis[M];</span><br><span class="line">    <span class="keyword">int</span> que[M*<span class="number">100</span>],l,r;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">        dis[que[++r]=id[<span class="number">1</span>][<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=que[++l];</span><br><span class="line">            vis[x]=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x],y=g[i].to;i;i=g[i].nxt,y=g[i].to)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[y]&gt;dis[x]+g[i].c)&#123;</span><br><span class="line">                    dis[y]=dis[x]+g[i].c;</span><br><span class="line">                    <span class="keyword">if</span>(!vis[y])&#123;</span><br><span class="line">                        vis[y]=<span class="literal">true</span>;</span><br><span class="line">                        que[++r]=y;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>(),k=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=k;++j)</span><br><span class="line">                id[i][j]=++num;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=<span class="built_in">rd</span>(),y=<span class="built_in">rd</span>(),c=<span class="built_in">rd</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=k;++j)&#123;</span><br><span class="line">                <span class="built_in">addedge</span>(id[x][j],id[y][j],c);</span><br><span class="line">                <span class="built_in">addedge</span>(id[y][j],id[x][j],c);</span><br><span class="line">                <span class="keyword">if</span>(j!=k)&#123;</span><br><span class="line">                    <span class="comment">// cout&lt;&lt;&quot;?&quot;;</span></span><br><span class="line">                    <span class="built_in">addedge</span>(id[x][j],id[y][j+<span class="number">1</span>],c/<span class="number">2</span>);</span><br><span class="line">                    <span class="comment">// addedge(id[y][j+1],id[x][j],c/2);</span></span><br><span class="line">                    <span class="built_in">addedge</span>(id[y][j],id[x][j+<span class="number">1</span>],c/<span class="number">2</span>);</span><br><span class="line">                    <span class="comment">// addedge(id[x][j+1],id[y][j],c/2);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">spfa</span>();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;++i)&#123;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,dis[id[n][i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=n;++i)</span></span><br><span class="line">            <span class="comment">// cout&lt;&lt;dis[id[i][0]]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>APIO/CTSC 2007数据备份</title>
    <url>/2019/01/05/apio-ctsc-2007%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<p>这两个题思路是一样的，都要用到优先队列和链表 <a href="https://www.luogu.org/problemnew/show/P3620">[APIO/CTSC 2007]数据备份</a> <a href="https://www.luogu.org/problemnew/show/P1484">种树</a> 就以数据备份这个题为例： 首先我们可以知道，要取得最短配对方案，一定是相邻的楼相连，并且每对之间有空隙 可以把所有两个楼之间空隙放进数组中处理，即在数组中不能相邻取数 对于一个最小的空隙，在最优方案中它要么被选取，要么两边的空隙被选取。这是因为如果上述都不满足的话，任意少取一个空隙换成最小空隙，都可以让答案更小 所以，我们使用一个优先队列和一个链表：每次取出最小值和两边的数$d[i],d[i-1],d[i+1]$，在答案中加上$d[i]$，然后将$d[i-1]+d[i+1]-d[i]$放在原$d[i]$的位置并更新链表 如果之后使用到了这个新值，即抛弃了使用$d[i]$，选取了$d[i-1]+d[i+1]$，满足最优方案 注意边界，设成$INF$ PS：我自己都嫌弃自己代码丑……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span>  c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) a = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500000</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> L[MAXN], R[MAXN];</span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tree[MAXN];</span><br><span class="line"><span class="keyword">int</span> dis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Pair;</span><br><span class="line">priority_queue&lt;Pair, vector&lt;Pair&gt;, greater&lt;Pair&gt; &gt; que;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> del[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    N = <span class="built_in">read</span>(); K = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        dis[i] = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        tree[i] = dis[i] - dis[i - <span class="number">1</span>];</span><br><span class="line">        que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(tree[i], i));</span><br><span class="line">        L[i] = i - <span class="number">1</span>;</span><br><span class="line">        R[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tree[<span class="number">0</span>] = tree[<span class="number">1</span>] = tree[N + <span class="number">1</span>] = tree[N + <span class="number">2</span>] = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    L[N + <span class="number">1</span>] = N;</span><br><span class="line">    R[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (K--) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = que.<span class="built_in">top</span>().first, p = que.<span class="built_in">top</span>().second;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (del[p]) &#123;</span><br><span class="line">            ++K;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += v;</span><br><span class="line">        del[L[p]] = del[R[p]] = <span class="literal">true</span>;</span><br><span class="line">        tree[p] = tree[L[p]] + tree[R[p]] - tree[p];</span><br><span class="line">        que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(tree[p], p));</span><br><span class="line">        L[p] = L[L[p]];</span><br><span class="line">        R[L[p]] = p;</span><br><span class="line">        R[p] = R[R[p]];</span><br><span class="line">        L[R[p]] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>BeiJing2011梦想封印 线性基</title>
    <url>/2019/10/01/beijing2011%E6%A2%A6%E6%83%B3%E5%B0%81%E5%8D%B0-%E7%BA%BF%E6%80%A7%E5%9F%BA/</url>
    <content><![CDATA[<p><a href="http://darkbzoj.tk/problem/2322">[BeiJing2011]梦想封印</a> 关于bzoj：她死了 首先有个全世界都知道的结论：图中路径异或值，可以用无环路径与任意环异或出来。 本题要求删边，倒序处理改成加边。DFS，求出DFS树，把非树边构成的环插入线性基。 分类讨论新增一条边的影响：</p>
<ol>
<li>两个端点都没有被访问过：直接加上就可以了</li>
<li>两个端点都被访问过：产生新环，插入线性基</li>
<li>一个端点被访问过：从另一个端点开始DFS，扩展DFS树</li>
</ol>
<p>因为本题中可以走到任意点结束，即从1出发的任意DFS树上走出的值都可以放进线性基查询，需要去重。放进线性基里跑一下，丢进set就可以。注意线性基更新后要更新set内所有值。 <a href="https://www.luogu.org/paste/0wvgin20">在线丢人代码</a></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>AHOI2012 信号塔 计算几何最小圆覆盖</title>
    <url>/2019/08/07/ahoi2012-%E4%BF%A1%E5%8F%B7%E5%A1%94-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%9C%80%E5%B0%8F%E5%9C%86%E8%A6%86%E7%9B%96/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P2533">[AHOI2012]信号塔</a> 用一个圆覆盖所有点，求最小半径的问题叫做最小圆覆盖，有一个神奇的解法。 首先是一个性质：最小圆要么直径上有两个点，要么有三个点在圆上。 基于这个性质，有了一个算法： 三层循环，第一层枚举点，如果不在圆内，设为圆心，第二层如果不在圆内，把圆半径设为两层选的点，第三层如果不在圆内，把圆设为这三个点在圆上。 正确性显然，复杂度看似是$O(n^3)$，但是是期望$O(n)$的。 不严谨简略证明：因为答案的圆上最多有三个点，所以，随机数据下，每个点在圆上的几率都是很小的，所以循环进入的次数也很少。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; <span class="keyword">double</span> r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">fabs</span>(x - y) &lt; eps ? <span class="number">0</span> : x &lt; y ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125; p[N], o;</span><br><span class="line"></span><br><span class="line">Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;a, <span class="keyword">const</span> Point &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; a.x + b.x, a.y + b.y &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point &amp;a, <span class="keyword">const</span> Point &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; a.x - b.x, a.y - b.y &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point <span class="keyword">operator</span>*(<span class="keyword">const</span> Point &amp;a, <span class="keyword">double</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; a.x * b, a.y * b &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point <span class="keyword">operator</span>/(<span class="keyword">const</span> Point &amp;a, <span class="keyword">double</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; a.x / b, a.y / b &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> <span class="keyword">operator</span>^(<span class="keyword">const</span> Point &amp;a, <span class="keyword">const</span> Point &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">const</span> Point &amp;a, <span class="keyword">const</span> Point &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(std::<span class="built_in">pow</span>(a.x - b.x, <span class="number">2</span>) + std::<span class="built_in">pow</span>(a.y - b.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in_circle</span><span class="params">(<span class="keyword">const</span> Point &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dcmp</span>(<span class="built_in">get_dis</span>(a, o), r) != <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get_intersection</span></span><br><span class="line"><span class="function">Point <span class="title">get_is</span><span class="params">(<span class="keyword">const</span> Point &amp;a, <span class="keyword">const</span> Point &amp;b, <span class="keyword">const</span> Point &amp;c, <span class="keyword">const</span> Point &amp;d)</span> </span>&#123;</span><br><span class="line">    Point e = a - c;</span><br><span class="line">    <span class="keyword">return</span> a + b * ((d ^ e) / (b ^ d));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">    std::<span class="built_in">random_shuffle</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">in_circle</span>(p[i]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        o = p[i]; r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">in_circle</span>(p[j]))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            o = (p[i] + p[j]) / <span class="number">2</span>;</span><br><span class="line">            r = <span class="built_in">get_dis</span>(p[i], p[j]) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; j; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">in_circle</span>(p[k]))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                Point vec1 = p[i] - p[j], vec2 = p[j] - p[k],</span><br><span class="line">                    mid1 = (p[i] + p[j]) / <span class="number">2</span>, mid2 = (p[j] + p[k]) / <span class="number">2</span>;</span><br><span class="line">                std::<span class="built_in">swap</span>(vec1.x, vec1.y), std::<span class="built_in">swap</span>(vec2.x, vec2.y);</span><br><span class="line">                vec1.x = -vec1.x, vec2.x = -vec2.x;</span><br><span class="line">                o = <span class="built_in">get_is</span>(mid1, vec1, mid2, vec2);</span><br><span class="line">                r = <span class="built_in">get_dis</span>(p[i], o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf %.2lf %.2lf\n&quot;</span>, o.x, o.y, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>BZOJ2702 金融风暴 决策单调性</title>
    <url>/2020/04/22/bzoj2702-%E9%87%91%E8%9E%8D%E9%A3%8E%E6%9A%B4-%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/</url>
    <content><![CDATA[<p><a href="https://darkbzoj.tk/problem/2702">金融风暴</a> 先orz Claris 好像是很经典的做法。考虑一行左边两个点的答案更新右边的某个点。不难发现是有决策单调性的。右边更新左边同理。那么把每个点的初始距离设置为上方/下方最近的点，并对每一行分分治即可。至于查询用二维ST表就可以。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w, h, n, q, map[N][N], st[<span class="number">11</span>][N][N];</span><br><span class="line"><span class="keyword">int</span> up[N], f[N], lg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, pos = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = ql; i &lt;= qr; ++i) <span class="keyword">if</span> (~up[i]) &#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = (mid - i) * (mid - i) + up[i] * up[i];</span><br><span class="line">    <span class="keyword">if</span> (f[mid] &gt; tmp) &#123;</span><br><span class="line">      f[mid] = tmp;</span><br><span class="line">      pos = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pos &amp;&amp; l != mid)</span><br><span class="line">    <span class="built_in">solve</span>(l, mid - <span class="number">1</span>, ql, pos);</span><br><span class="line">  <span class="keyword">if</span> (pos &amp;&amp; r != mid)</span><br><span class="line">    <span class="built_in">solve</span>(mid + <span class="number">1</span>, r, pos, qr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> t = lg[d];</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">max</span>(&#123;</span><br><span class="line">    st[t][x][y], st[t][x + d - (<span class="number">1</span> &lt;&lt; t)][y + d - (<span class="number">1</span> &lt;&lt; t)],</span><br><span class="line">    st[t][x + d - (<span class="number">1</span> &lt;&lt; t)][y], st[t][x][y + d - (<span class="number">1</span> &lt;&lt; t)]</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i)</span><br><span class="line">    lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">  w = <span class="built_in">rd</span>() + <span class="number">1</span>, h = <span class="built_in">rd</span>() + <span class="number">1</span>, n = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">rd</span>() + <span class="number">1</span>, y = <span class="built_in">rd</span>() + <span class="number">1</span>;</span><br><span class="line">    map[x][y] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(up, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(up));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= w; ++i) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= h; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (map[i][j]) up[j] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (~up[j]) ++up[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>, h, <span class="number">1</span>, h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= h; ++j)</span><br><span class="line">      st[<span class="number">0</span>][i][j] = f[j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(up, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(up));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= h; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (map[i][j]) up[j] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (~up[j]) ++up[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>, h, <span class="number">1</span>, h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= h; ++j)</span><br><span class="line">      st[<span class="number">0</span>][i][j] = std::<span class="built_in">min</span>(st[<span class="number">0</span>][i][j], f[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">10</span>; ++k)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span> &lt;= w; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j + (<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span> &lt;= h; ++j)</span><br><span class="line">        st[k][i][j] = std::<span class="built_in">max</span>(&#123;</span><br><span class="line">          st[k - <span class="number">1</span>][i][j], st[k - <span class="number">1</span>][i][j + (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))],</span><br><span class="line">          st[k - <span class="number">1</span>][i + (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))][j],</span><br><span class="line">          st[k - <span class="number">1</span>][i + (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))][j + (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))]</span><br><span class="line">        &#125;);</span><br><span class="line">  q = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">rd</span>() + <span class="number">1</span>, y = <span class="built_in">rd</span>() + <span class="number">1</span>, d = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">if</span> (x - d &lt; <span class="number">1</span>  x + d &gt; w  y - d &lt; <span class="number">1</span>  y + d &gt; h) &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">query</span>(x - d, y - d, d * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>, std::<span class="built_in">sqrt</span>(ans));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>BeiJing2006狼抓兔子</title>
    <url>/2019/02/07/beijing2006%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1001">[BeiJing2006]狼抓兔子</a> 一看题：这不是最小割嘛，于是怒码几十行Dinic，提交！ 如果你以为这是一个悲伤的故事，那么就错了，交上去就AC了，跑的还很快。 本题使用最小割，只要Dinic写的漂亮，的确可以过去…不过正解是对偶图： 对偶图可以理解为把原来平面中的面看作点，对于一条把两个平面切开的边，在对偶图中把两个点之间连上这条边。 对偶图有个很好的性质：最大流 = 最小割 = 对偶图最短路。 可以脑部一下在原图切一刀的样子，切断的边就是在对偶图上跑一次最短路的结果。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>CCC 2016合并饭团</title>
    <url>/2019/01/23/ccc-2016%E5%90%88%E5%B9%B6%E9%A5%AD%E5%9B%A2/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4805">[CCC 2016]合并饭团</a> 看到题目中的合并，可以发现本题是一道区间DP。 将合并分为合并两个饭团和合并三个饭团分开讨论。合并两个饭团的操作如同<a href="https://www.luogu.org/problemnew/show/P1880">石子合并</a>这道题，复杂度$O(N^3)$，不再讨论。显然，合并两个饭团不是解决本题的瓶颈。 考虑合并三个饭团的暴力做法。在区间内枚举中间区间的左右端点，判断可否合并，复杂度$O(N^4)$，无法通过本题。</p>
<hr>
<p>观察本题的特殊性质（下面提到的区间都是可由子区间合并而来的，即值非0）：</p>
<ul>
<li>对于区间$[l, r]$，合并后区间$[l, r]$的值必为<strong>原输入中的$[l, r]$段之和</strong>。因为区间和一定，所以区间越长，区间值越大。</li>
<li>确定一个左端点$l$，那么对于右端点$r1 &lt; r2 &lt; r3 &lt; …$，有$[l, r1] &lt; [l, r2] &lt; [l, r3] &lt; … $，即<strong>区间值具有单调性</strong>。确定右端点同理。</li>
</ul>
<p>所以，我们可以得到以下结论与方案：</p>
<ul>
<li>在一个区间内，只要找到一种满足题目要求的合并方案，就可确定这段区间的值。可以以此减少循环次数。</li>
<li>在合并三个饭团时，若枚举到的中间区间为$[k, t]$，随着$k$与$t$向中间靠近，$[l, k - 1]$与$[t + 1, r]$逐渐增大。可以使用<strong>双指针</strong>，减少一层循环。</li>
</ul>
<p>于是本题得解，时间复杂度$O(N^3)$。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, f[<span class="number">500</span>][<span class="number">500</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; f[i][i];</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[i][i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; ++len) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = len; r &lt;= n; ++l, ++r) &#123;</span><br><span class="line">            <span class="comment">// 两个合并</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt; r; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[l][k] &amp;&amp; f[k + <span class="number">1</span>][r] &amp;&amp; f[l][k] == f[k + <span class="number">1</span>][r]) &#123;</span><br><span class="line">                    f[l][r] = f[l][k] + f[k + <span class="number">1</span>][r];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 双指针，三个合并</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = l, t = r; k &lt; t - <span class="number">1</span>; ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[l][r]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (!f[l][k]) ++k;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!f[t][r]) --t;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (f[l][k] == f[t][r]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (f[k + <span class="number">1</span>][t - <span class="number">1</span>])</span><br><span class="line">                        f[l][r] = f[l][k] + f[k + <span class="number">1</span>][t - <span class="number">1</span>] + f[t][r];</span><br><span class="line">                    <span class="keyword">else</span> ++k, --t;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (f[l][k] &lt; f[t][r]) ++k;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (f[l][k] &gt; f[t][r]) --t;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, f[l][r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>CEOI2017Building Bridges 斜率优化DPCDQ分治</title>
    <url>/2019/10/03/ceoi2017building-bridges-%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dpcdq%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P4655">[CEOI2017]Building Bridges</a> <a href="https://www.luogu.org/problemnew/solution/P4655">首先奉上神仙题解%%%%%（第一篇）</a> 从这题解里学到好多新姿势啊。。 令$f_x$表示建到$x$的代价。 $$f_x = \min \lbrace f_j+s_{i-1}-s_j+(h_i-h_j)^2 \rbrace$$ 显然要斜率优化，$h$是横坐标。那么令$h_j &gt; h_k$，如果$j$比$k$优 $$2h_i \leq \frac{(f_j - s_j + h^2_j) - (f_k - s_k + h^2_k)}{h_j - h_k}$$ 令$X_i = h_i,Y_i = f_i - s_i + h^2_i$，发现$X$不单调，考虑CDQ分治。 之前在这里写过如何CDQ优化斜率优化，再总结下<a href="https://baka.online/noi2007-%e8%b4%a7%e5%b8%81%e5%85%91%e6%8d%a2/">[NOI2007] 货币兑换</a> 凸包上某个位置$j$要对后面$i$产生贡献，那么有$id_j &lt; id_i,X_j &lt; X_i$。这是一个二维偏序。 我们首先按斜率排序，然后进行CDQ。每一层，先按照$id$稳定排序，然后分治左边。左边返回的是按$X$排好序的，所以可以维护左边的凸包。然后更新右边答案，分治右边，按$X$排序，返回。 从题解里学到很多小技巧： STL的使用： std::stable_partition()，可以把满足比较条件的放在前面，其它的放在后面，并且是稳定的。 std::inplace_merge()，数组前后两部分可以用这个函数合并成有序的一大段。 指针的应用：用指针维护里面的队列真的优美 <a href="https://www.luogu.org/paste/cqmgy77w">代码点这里</a></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>CERC2017Intrinsic Interval Tarjan线段树建图</title>
    <url>/2019/08/05/cerc2017intrinsic-interval-tarjan%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%BB%BA%E5%9B%BE/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P4747">[CERC2017]Intrinsic Interval</a> Orz ywy Orz i207M Orz两个人的神奇做法（推荐看洛谷题解） 不过这题还有一种更神奇的做法，线段树建图+缩点。 Orz <a href="https://www.cnblogs.com/yqgAKIOI/p/10087038.html">fwat</a>的本题题解 我们考虑位置$i-1,i$，它们的值分别为$val[i-1],val[i]$。如果$i-1,i$这两个位置可以出现在一段“好”的区间中，那么，由好区间的定义，$[val[i],val[i+1]]$内的所有值，都需要在区间中出现。即，令$L,R$为$[val[i],val[i+1]]$内的所有值出现位置的左右端点，$[L,R]$都要在区间中出现。 用图中的边表示这个限制关系。$x \to y$的一条边，表示$x$出现的时候，$y$也要出现。 线段树优化建图，然后缩点。在DAG上DFS，求出每个点存在的时候，要求出现区间的范围。 对于一次询问$l,r$，$[l,r]$内每个范围的并就是答案。 这个需要用以下性质证明：</p>
<ol>
<li> 如果有$a \leq b \leq c \leq d$，$[a,c],[b,d]$是好区间，那么$[a,d]$也是好区间。</li>
</ol>
<p>考虑把好区间内部排序，那么它一定是个差为$1$的等差数列。所以，我们可以认为好区间就是区间内差为$1$的无序对$(i,j)$数量为$r-l$的区间。这么看就显然了。</p>
<ol start="2">
<li> $i-1,i$和$i,i+1$所限制范围是有交的。</li>
</ol>
<p>由于两端区间有共同的数，这个性质也一定是成立的。 $O(nlogn)$。理论上比分治跑得快（</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(p) p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(p) p &lt;&lt; 1  1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400000</span> + <span class="number">2333</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, val[N], pos[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="built_in">Node</span>() &#123; l = <span class="number">1e9</span>; r = -l; &#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _l, <span class="keyword">int</span> _r) &#123;</span><br><span class="line">        l = _l; r = _r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node <span class="keyword">operator</span>+(<span class="keyword">const</span> Node &amp;x, <span class="keyword">const</span> Node &amp;y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Node</span>(std::<span class="built_in">min</span>(x.l, y.l), std::<span class="built_in">max</span>(x.r, y.r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegTree</span> &#123;</span></span><br><span class="line">    Node t[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, Node y, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) <span class="keyword">return</span> (<span class="keyword">void</span>)(t[p] = y);</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">change</span>(<span class="built_in">ls</span>(p), x, y, L, mid);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">change</span>(<span class="built_in">rs</span>(p), x, y, mid + <span class="number">1</span>, R);</span><br><span class="line">        t[p] = t[<span class="built_in">ls</span>(p)] + t[<span class="built_in">rs</span>(p)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R) <span class="keyword">return</span> t[p];</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid &amp;&amp; r &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r, L, mid) + <span class="built_in">query</span>(<span class="built_in">rs</span>(p), l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r, L, mid);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(p), l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; seg[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; G1[N], G2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> (<span class="keyword">void</span>)(pos[L] = p);</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(p), L, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, R);</span><br><span class="line">    G1[p].<span class="built_in">push_back</span>(<span class="built_in">ls</span>(p));</span><br><span class="line">    G1[p].<span class="built_in">push_back</span>(<span class="built_in">rs</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R) <span class="keyword">return</span> (<span class="keyword">void</span>)(G1[q].<span class="built_in">push_back</span>(p));</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">addedge</span>(<span class="built_in">ls</span>(p), l, r, L, mid, q);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) <span class="built_in">addedge</span>(<span class="built_in">rs</span>(p), l, r, mid + <span class="number">1</span>, R, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node t1[N], t2[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[N], low[N], ins[N], scc[N], stk[N], top, cnt, num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++num;</span><br><span class="line">    ins[stk[++top] = x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : G1[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ins[y])</span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low[x] == dfn[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y; ++cnt;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ins[y = stk[top--]] = <span class="number">0</span>;</span><br><span class="line">            scc[y] = cnt;</span><br><span class="line">        &#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x]) <span class="keyword">return</span>;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : G2[x]) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">        t2[x] = t2[x] + t2[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(); <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        val[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        seg[<span class="number">0</span>].<span class="built_in">change</span>(<span class="number">1</span>, val[i], &#123; i, i &#125;, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = std::<span class="built_in">min</span>(val[i - <span class="number">1</span>], val[i]), y = std::<span class="built_in">max</span>(val[i - <span class="number">1</span>], val[i]);</span><br><span class="line">        t1[pos[i]] = seg[<span class="number">0</span>].<span class="built_in">query</span>(<span class="number">1</span>, x, y, <span class="number">1</span>, n);</span><br><span class="line">        <span class="built_in">addedge</span>(<span class="number">1</span>, t1[pos[i]].l + <span class="number">1</span>, t1[pos[i]].r, <span class="number">1</span>, n, pos[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; N; ++x)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y : G1[x]) <span class="keyword">if</span> (scc[x] != scc[y])</span><br><span class="line">            G2[scc[x]].<span class="built_in">push_back</span>(scc[y]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">        t2[scc[i]] = t2[scc[i]] + t1[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">        <span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        seg[<span class="number">1</span>].<span class="built_in">change</span>(<span class="number">1</span>, i, t2[scc[pos[i]]], <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">rd</span>(), r = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, l, r);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node ans = seg[<span class="number">1</span>].<span class="built_in">query</span>(<span class="number">1</span>, l + <span class="number">1</span>, r, <span class="number">1</span>, n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, ans.l, ans.r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>CF1028G Guess the number DP交互</title>
    <url>/2019/11/08/cf1028g-guess-the-number-dp%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/CF1028G">CF1028G Guess the number</a> 神仙交互题… 我们考虑如果已经可以确定答案$\geq l$,可以问$q$次,那么可以确定的$r$最大是什么. 令$f_{l,q}$表示这个值.实际上询问一些位置就是在把序列分段,我们考虑一段一段处理.令$r_i$表示第$i$个数可以确定的$r$ $$r_0 = l, r_i = r_{i-1}+f_{r_{i-1},q-1} + 1$$ $$f_{l,q}=r_{l+1}-l-1$$ (边界区间开闭什么的感性理解一下…) 用$r$表示当前可以确定的右端点,用$f$构造询问,交互即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[K + <span class="number">10</span>][<span class="number">6</span>];</span><br><span class="line">std::vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; query;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> l, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (q == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  l = std::<span class="built_in">min</span>(l, (<span class="keyword">long</span> <span class="keyword">long</span>)K);</span><br><span class="line">  <span class="keyword">if</span> (f[l][q])</span><br><span class="line">    <span class="keyword">return</span> f[l][q];</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> r = l;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l + <span class="number">1</span>; ++i)</span><br><span class="line">    r += <span class="built_in">dfs</span>(r, q - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  f[l][q] = r - l - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> f[l][q];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> r = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    query.<span class="built_in">clear</span>();</span><br><span class="line">    query.<span class="built_in">push_back</span>(r - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lim = std::<span class="built_in">min</span>(r, (<span class="keyword">long</span> <span class="keyword">long</span>)K);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lim; ++j) &#123;</span><br><span class="line">      <span class="keyword">int</span> _lim = std::<span class="built_in">min</span>(r, (<span class="keyword">long</span> <span class="keyword">long</span>)K);</span><br><span class="line">      r += f[_lim][<span class="number">5</span> - i];</span><br><span class="line">      query.<span class="built_in">push_back</span>(r++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; query.<span class="built_in">size</span>() - <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> j = <span class="number">1</span>; j &lt; query.<span class="built_in">size</span>(); ++j)</span><br><span class="line">      std::cout &lt;&lt; query[j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c; std::cin &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    r = query[c] + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>CF1270H Number of Components 线段树</title>
    <url>/2020/01/02/cf1270h-number-of-components-%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1270/problem/H">Number of Components</a> 神仙题。。。 观察可以发现，如果图分成了两个联通块，一定存在$i$，使得$\min_{ j \leq i } A_j &gt; \max_{j &gt; i} A_j$ 我们称这个位置为分界点。那么只需找出有多少分界点。 考虑分界点$A_i = x$，令$ &gt; x $的数为$1$，$ \leq x $的为$0$，形成$01$序列。特别的，令$A_0 = + \infty, A_{n+1} = 0$ 可以发现，如果$x$是分界点的数，那么原数列为$11110000$的形式。 因为$A_0 = + \infty, A_{n+1} = 0$，在序列为$11110000$时，$0,1$的分界点最少，是$1$个。 所以只需找出有多少个$x$，满足代入后分界点是一个即可。 这个东西是可以用线段树维护的。具体来说就是在插入删除的时候分类讨论进行$+1,-1$。实现非常巧妙，可以看代码…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, A[N], pos[N], val[N], lim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(p) p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(p) p &lt;&lt; 1  1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> min[N * <span class="number">4</span>], cnt[N * <span class="number">4</span>], tag[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (min[<span class="built_in">ls</span>(p)] == min[<span class="built_in">rs</span>(p)]) &#123;</span><br><span class="line">    min[p] = min[<span class="built_in">ls</span>(p)];</span><br><span class="line">    cnt[p] = cnt[<span class="built_in">ls</span>(p)] + cnt[<span class="built_in">rs</span>(p)];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (min[<span class="built_in">ls</span>(p)] &lt; min[<span class="built_in">rs</span>(p)]) &#123;</span><br><span class="line">    min[p] = min[<span class="built_in">ls</span>(p)];</span><br><span class="line">    cnt[p] = cnt[<span class="built_in">ls</span>(p)];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    min[p] = min[<span class="built_in">rs</span>(p)];</span><br><span class="line">    cnt[p] = cnt[<span class="built_in">rs</span>(p)];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  min[p] += v;</span><br><span class="line">  tag[p] += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tag[p]) &#123;</span><br><span class="line">    <span class="built_in">push</span>(<span class="built_in">ls</span>(p), tag[p]);</span><br><span class="line">    <span class="built_in">push</span>(<span class="built_in">rs</span>(p), tag[p]);</span><br><span class="line">    tag[p] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> v, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">    cnt[p] += v;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pushdown</span>(p);</span><br><span class="line">  <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">    <span class="built_in">modify</span>(<span class="built_in">ls</span>(p), x, v, L, mid);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">modify</span>(<span class="built_in">rs</span>(p), x, v, mid + <span class="number">1</span>, R);</span><br><span class="line">  <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">push</span>(p, v);</span><br><span class="line">  <span class="built_in">pushdown</span>(p);</span><br><span class="line">  <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">    <span class="built_in">add</span>(<span class="built_in">ls</span>(p), l, r, v, L, mid);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">    <span class="built_in">add</span>(<span class="built_in">rs</span>(p), l, r, v, mid + <span class="number">1</span>, R);</span><br><span class="line">  <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R) &#123;</span><br><span class="line">    <span class="keyword">if</span> (min[p] == <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> cnt[p];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pushdown</span>(p);</span><br><span class="line">  <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">    ret = <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r, L, mid);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">    ret += <span class="built_in">query</span>(<span class="built_in">rs</span>(p), l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; y) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">  <span class="built_in">add</span>(<span class="number">1</span>, x, y - <span class="number">1</span>, v, <span class="number">0</span>, lim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">rd</span>(), q = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    A[i] = <span class="built_in">rd</span>();</span><br><span class="line">    lim = std::<span class="built_in">max</span>(lim, A[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">    pos[i] = <span class="built_in">rd</span>();</span><br><span class="line">    val[i] = <span class="built_in">rd</span>();</span><br><span class="line">    lim = std::<span class="built_in">max</span>(lim, val[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  A[<span class="number">0</span>] = ++lim;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">update</span>(A[i], A[i + <span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">1</span>, A[i], <span class="number">1</span>, <span class="number">0</span>, lim);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> p = pos[i], v = val[i];</span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">1</span>, A[p], <span class="number">-1</span>, <span class="number">0</span>, lim);</span><br><span class="line">    <span class="built_in">update</span>(A[p - <span class="number">1</span>], A[p], <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">update</span>(A[p], A[p + <span class="number">1</span>], <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">1</span>, v, <span class="number">1</span>, <span class="number">0</span>, lim);</span><br><span class="line">    <span class="built_in">update</span>(A[p - <span class="number">1</span>], v, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">update</span>(v, A[p + <span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">    A[p] = v;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, lim - <span class="number">1</span>, <span class="number">0</span>, lim));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>CF100958I Substring Pairs DP</title>
    <url>/2020/03/25/cf100958i-substring-pairs-dp/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/gym/100958">[Makoto Soejima Contest 1, Japanese Grand Prix, by rng_58][CF100958I] Substring Pairs</a> 上面的来源有长长的一串，是因为在陈老师WC课件里见过这个题，来源很迷，全粘贴上了… 考虑一下给定$T$怎么求有多少个$S$，令$f_i$表示$i$处，$[i-m+1,i]$是$T$第一次出现的方案。$f_i=A^{i-m}-\sum_{j &lt; i} f_j W_{i,j} $，意思是枚举上一次出现的位置。$W$的值取决于两个串是否相交，如果相交要求交的部分是Border。 可以看出，这个DP只和$T$的Border集合有关。那么考虑枚举集合并DP即可。这里有一个貌似好几道题都用到的结论：$\sum_{i \leq 50} border \ cnt_i \leq 30000$。那么暴搜出所有Border就行了。 爆搜的方法也很简单：维护一个当前的Border，扩展串的长度，使得当前Border是新的串的Border，递归即可。当前串的新的串的Border的条件是，如果当前串长度大于新串的一半，那么需要判断重复的部分是不是Border。另外由于不能重复，需要去重。考虑重复的条件：考虑扩展后长度小于二分之一，中间随便放，那么可能存在一种放法，使得中间位置也有Border，显然已经被算过，所以减去之前的答案和就行了。 为什么CF非&gt;=紫名的用户不能看Gym别人代码啊啊啊啊想找个程序对拍都找不到</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">205</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, A;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> powA[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; border;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, __int128 S)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y &lt; x - m + <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> powA[x - m - y];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (S &gt;&gt; (y - x + m)) &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dp</span><span class="params">(__int128 S)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(((__int128)<span class="number">1</span> &lt;&lt; m) &amp; S))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (S &gt;&gt; (m + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">f</span><span class="params">(N)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= n; ++i) &#123;</span><br><span class="line">    f[i] = powA[i - m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &lt; i; ++j)</span><br><span class="line">      f[i] = (f[i] + P - f[j] * <span class="built_in">calc</span>(i, j, S) % P);</span><br><span class="line">    f[i] %= P;</span><br><span class="line">    ret = (ret + f[i] * powA[n - i]) % P;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">dfs</span><span class="params">(__int128 S, <span class="keyword">int</span> ways)</span> </span>&#123;</span><br><span class="line">  ans = (ans + <span class="built_in">dp</span>(S) * ways) % P;</span><br><span class="line">  <span class="keyword">int</span> last = border.<span class="built_in">back</span>();</span><br><span class="line">  <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(N)</span></span>;</span><br><span class="line">  ret[last] = (ret[last] + ways) % P;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x = last + <span class="number">1</span>; x &lt;= m; ++x) &#123;</span><br><span class="line">    border.<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="keyword">int</span> tmp = ways;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; border.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = border[i];</span><br><span class="line">      <span class="keyword">if</span> (v + v &gt; x &amp;&amp; !(S &amp; ((__int128)<span class="number">1</span> &lt;&lt; (v + v - x))))</span><br><span class="line">        <span class="keyword">goto</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (last + last &lt; x)</span><br><span class="line">      tmp = tmp * powA[x - last - last] % P;</span><br><span class="line">    tmp = (tmp - ret[x] + P) % P;</span><br><span class="line">    <span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">      std::vector&lt;<span class="keyword">int</span>&gt; vec = <span class="built_in">dfs</span>(<span class="built_in">S</span>  ((__int128)<span class="number">1</span> &lt;&lt; x), tmp);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)</span><br><span class="line">        ret[i] = (ret[i] + vec[i]) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    next:</span><br><span class="line">    border.<span class="built_in">pop_back</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; A;</span><br><span class="line">  powA[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">    powA[i] = powA[i - <span class="number">1</span>] * A % P;</span><br><span class="line">  border.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>CF1336E2 Chiori and Doll Picking FWT线性基</title>
    <url>/2020/04/29/cf1336e2-chiori-and-doll-picking-fwt%E7%BA%BF%E6%80%A7%E5%9F%BA/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/problemset/problem/1336/E2">CF1336E2 Chiori and Doll Picking</a> 求一个线性基出来，求一下线性基可以表出多少数就好了。那么有一种简单暴力：直接枚举。加上折半搜索就可以过弱化版，不加折半搜索的复杂度是$O(2^r)$的。 还可以构造另一种算法：考虑令$f_{i,j}=f_{i-1,j}+f_{i-1,j \oplus A_i}$，那么构造序列$y$，使得$y_{i,0}=y_{i,a_i}=1,y_{i,j}=0$，那么答案就是$\prod y_i$。 那么考虑${\rm FWT}(y_i)_k$，它的值是$1+(-1)^{A_i \And w}$。那么$\Gamma_k = 2^n[ \forall i, A_i \And k \equiv 0 \pmod 2]$。 最终结果就是$f_i=\frac{1}{2^r} \sum_{j} \Gamma_j (-1)^{i \And j} $。 考虑计算答案$g$，$g_c=\sum_{s=c}f_s=\frac{1}{2^m} \sum_{t} \Gamma_t \sum_{s=c} (-1)^{s \And t}$ 后面这个$\sum$可以用组合数计算。确定了$t$，考虑$t=x$，那么钦定$x$中有$i$个产生贡献，剩下的$m-x$个位置一定是$0$，就可以确定$s$。$\sum_{i}\binom{x}{i}\binom{m-x}{c-i}(-1)^i$ 可以发现这个式子和$t$是什么无关，只和$t$有关。 那么问题就变成了求$\sum_{t=c} \Gamma_t$ 考虑什么时候$\Gamma_k$有值，即每一位，都有$A_i \And k \equiv 0 \pmod p$。 把$A_i \And k$写成矩阵，则每一行的和都为$0$。 与操作其实就是选其中的一些列，所以问题就变成了选一些列，使得和为$0$。 那么把线性基消成最简行阶梯矩阵，考虑在右边钦定一些列，那么存在唯一的方案，从左边的单位矩阵中选列，使它们的异或和为$0$。暴力枚举右边即可。复杂度$O(2^{m-r})$ 之后有一些细节，有关线性基的,新的线性基长什么样子。直接从题解里找图了，B就是： <img src="https://baka.online/wp-content/uploads/2020/04/wKc3le9s8vBzQYr.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cerr;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">60</span>, P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fpow</span>(<span class="built_in">fpow</span>(x, -y), P - <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = x * x % P)</span><br><span class="line">    <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = ret * x % P;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, rank;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> C[N][N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> lb[N], nlb[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = m; ~i; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &amp; (<span class="number">1ll</span> &lt;&lt; i)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!lb[i]) &#123; lb[i] = x; <span class="keyword">break</span>; &#125;</span><br><span class="line">      <span class="keyword">else</span> x ^= lb[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> s, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pos == rank)</span><br><span class="line">    ++p[__builtin_popcountll(s)];</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(s, pos + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(s ^ lb[pos], pos + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x; std::cin &gt;&gt; x;</span><br><span class="line">    <span class="built_in">insert</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!lb[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">      <span class="keyword">if</span> (lb[i] &amp; (<span class="number">1ll</span> &lt;&lt; j))</span><br><span class="line">        lb[i] ^= lb[j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">      <span class="keyword">if</span> (!lb[j])</span><br><span class="line">        nlb[rank] = (nlb[rank] &lt;&lt; <span class="number">1</span>)  ((lb[i] &gt;&gt; j) &amp; <span class="number">1</span>);</span><br><span class="line">    nlb[rank] = <span class="number">1ll</span> &lt;&lt; (m - rank - <span class="number">1</span>);</span><br><span class="line">    ++rank;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rank; ++i)</span><br><span class="line">    lb[i] = nlb[i], nlb[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = rank; i &lt; N; ++i)</span><br><span class="line">    lb[i] = <span class="number">0</span>, nlb[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (rank &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">      <span class="keyword">long</span> <span class="keyword">long</span> ans = p[i] * <span class="built_in">fpow</span>(<span class="number">2</span>, n - rank) % P;</span><br><span class="line">      std::cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    rank = m - rank;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rank; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m - rank; ++j)</span><br><span class="line">        <span class="keyword">if</span> (lb[j] &amp; (<span class="number">1ll</span> &lt;&lt; i))</span><br><span class="line">          nlb[i] = <span class="number">1ll</span> &lt;&lt; j;</span><br><span class="line">      nlb[i] = <span class="number">1ll</span> &lt;&lt; (m - i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">swap</span>(lb, nlb);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C[<span class="number">0</span>][<span class="number">0</span>] = C[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>; i + <span class="number">1</span> &lt; N; ++i, C[i][<span class="number">0</span>] = <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">        C[i][j] = (C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j]) % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">      <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= i; ++k)</span><br><span class="line">          tmp = (tmp + (k &amp; <span class="number">1</span> ? P - <span class="number">1</span> : <span class="number">1</span>) * C[j][k] % P * C[m - j][i - k]) % P;</span><br><span class="line">        ans = (ans + tmp * p[j]) % P;</span><br><span class="line">      &#125;</span><br><span class="line">      ans = ans * <span class="built_in">fpow</span>(<span class="number">2</span>, n - m) % P;</span><br><span class="line">      std::cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>CF183D T-shirt 期望DP贪心</title>
    <url>/2019/11/07/cf183d-t-shirt-%E6%9C%9F%E6%9C%9Bdp%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/CF183D">CF183D T-shirt</a> 考虑一个暴力一些的DP.钦定当前正在考虑第$x$件衣服,那么设计$f_{i,j}$,表示选$i$个,送$j$个的期望 $$f_{i,j} = f_{i-1,j-1}p_{i,x} + f_{i-1,j}(1-p_{i,x})$$ 然后考虑计算对答案贡献的期望 $$E_i = \sum_{j=0}^i jf_{n,j} + \sum_{j=i+1}^n if_{n,j}$$ 有了$E$,可以背包求解. 考虑对$E$作差 $$delta=E_{i+1} - E_i = \sum_{j=i+1}^n f_{n,j} = 1-\sum_{j=0}^i f_{n,j}$$ 显然$f$递增,即差越来越小.所以,可以考虑求出所有$x$,选$0$个的$delta$,贪心选取最优$x$,然后更新$delta$.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3010</span>, M = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m; <span class="keyword">double</span> p[N][M];</span><br><span class="line"><span class="keyword">double</span> f[M][N], g[N], delta[M];</span><br><span class="line"><span class="keyword">double</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> op = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">    g[i] = f[x][i];</span><br><span class="line">  f[x][<span class="number">0</span>] = op;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    f[x][i] = g[i - <span class="number">1</span>] * p[i][x] + f[x][i - <span class="number">1</span>] * (<span class="number">1</span> - p[i][x]);</span><br><span class="line">  delta[x] -= f[x][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">      <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">      p[i][j] = (<span class="keyword">double</span>)x / <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    delta[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">calc</span>(i, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">      <span class="keyword">if</span> (delta[j] &gt; delta[pos])</span><br><span class="line">        pos = j;</span><br><span class="line">    ans += delta[pos];</span><br><span class="line">    <span class="built_in">calc</span>(pos);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%.12lf\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>CF264D Colorful Stones</title>
    <url>/2019/10/15/cf264d-colorful-stones/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/CF264D">CF264D Colorful Stones</a> 神仙题。记录当前状态为$(x,y)$，有一个显然的事实：固定$y_i$，可以到达的$x$是一个区间，记为$[l_i,r_i]$，那么当$y_i \rightarrow y_{i+1}$，区间向前单调移动。 不过区间中可能会有无法到达的状态。如果存在字符对$(AB,BA)$，位置是$(x_ax_{a+1},y_a,y_{a+1})$，那么$(a+1,b+1)$是无法到达的。 于是可以预处理出某一个串中，这样字符的前缀和，双指针扫另一个串统计答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, A[N], B[N];</span><br><span class="line"><span class="keyword">char</span> sA[N], sB[N];</span><br><span class="line"><span class="keyword">int</span> sum[N][<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_int</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c == <span class="string">&#x27;R&#x27;</span> ? <span class="number">0</span> : c == <span class="string">&#x27;G&#x27;</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>, sA + <span class="number">1</span>, sB + <span class="number">1</span>);</span><br><span class="line">  n = <span class="built_in">strlen</span>(sA + <span class="number">1</span>);</span><br><span class="line">  m = <span class="built_in">strlen</span>(sB + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    A[i] = <span class="built_in">get_int</span>(sA[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    B[i] = <span class="built_in">get_int</span>(sB[i]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k)</span><br><span class="line">        sum[i][j][k] = sum[i - <span class="number">1</span>][j][k];</span><br><span class="line">    <span class="keyword">if</span> (A[i] != A[i - <span class="number">1</span>])</span><br><span class="line">      ++sum[i][A[i]][A[i - <span class="number">1</span>]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l = <span class="number">1</span>, r = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (r &lt; n &amp;&amp; A[r] != B[i])</span><br><span class="line">        ++r;</span><br><span class="line">      ans += r - l + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (r &lt; n) &#123;</span><br><span class="line">        ++r;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n &amp;&amp; A[r] != B[i])</span><br><span class="line">          ++r;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (A[l] == B[i - <span class="number">1</span>])</span><br><span class="line">        ++l;</span><br><span class="line">      <span class="keyword">if</span> (l &gt; n)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      ans += r - l + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (B[i] != B[i - <span class="number">1</span>])</span><br><span class="line">        ans -= sum[r][B[i - <span class="number">1</span>]][B[i]] - sum[l][B[i - <span class="number">1</span>]][B[i]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>CF525E Anya and Cubes</title>
    <url>/2019/01/05/cf525e-anya-and-cubes/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/CF525E">CF525E Anya and Cubes</a> 人生第一道紫题（某愚人节题目不算 题目大意为每个数a，可以sum+=a,sum+=a!,sum+=0，求有几种sum==S的方案 本题用到了一种叫做meet in the middle的搜索方法，即把从0<del>n的搜索改为0</del>n/2，n/2+1<del>n的搜索，搜完之后合并答案以减少时间复杂度 可以看出，合并部分的速度决定了最终算法的时间复杂度，如何合并是本题的关键，我使用了stl::map解决此问题 将枚举a[0]!-a[n]!改为分别枚举a[0]-a[n/2]!与a[n/2+1]</del>a[n]，用map储存前半部分的结果。ans[k][sum]表示当使用k个!时和为sum的方案总数 在枚举后半部分时，找到sum时，加上所有方案数：ans[i][S-sum]，0&lt;=i&lt;=K-k即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll a = <span class="number">0</span>; <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">do</span> &#123; c = <span class="built_in">getchar</span>(); &#125; <span class="keyword">while</span> (c&gt;<span class="string">&#x27;9&#x27;</span>  c&lt;<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123; a = a * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>; c = <span class="built_in">getchar</span>(); &#125; <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;c &lt;= <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll N, K, S;</span><br><span class="line">ll jc[<span class="number">21</span>] = &#123; <span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">120</span>,<span class="number">720</span>,<span class="number">5040</span>,<span class="number">40320</span>,<span class="number">362880</span>,</span><br><span class="line"><span class="number">3628800</span>,<span class="number">39916800</span>,<span class="number">479001600</span>,<span class="number">6227020800</span>,</span><br><span class="line"><span class="number">87178291200</span>,<span class="number">1307674368000</span>,<span class="number">20922789888000</span>,</span><br><span class="line"><span class="number">355687428096000</span>,<span class="number">6402373705728000</span>,<span class="number">121645100408832000</span>,</span><br><span class="line"><span class="number">2432902008176640000</span></span><br><span class="line">&#125;;</span><br><span class="line">ll a[<span class="number">30</span>];</span><br><span class="line">map&lt;ll, ll&gt; ans[<span class="number">30</span>];</span><br><span class="line">ll tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(ll n, ll k, ll sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum&gt;S  sum&lt;<span class="number">0</span>  k == K + <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == N / <span class="number">2</span>) &#123;</span><br><span class="line">        ++ans[k][sum];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(n + <span class="number">1</span>, k, sum);</span><br><span class="line">    <span class="built_in">dfs1</span>(n + <span class="number">1</span>, k, sum + a[n]);</span><br><span class="line">    <span class="keyword">if</span> (a[n] &lt;= <span class="number">20</span>) <span class="built_in">dfs1</span>(n + <span class="number">1</span>, k + <span class="number">1</span>, sum + jc[a[n]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(ll n, ll k, ll sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum&gt;S  sum&lt;<span class="number">0</span>  k == K + <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == N) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= K - k; ++i)</span><br><span class="line">            <span class="keyword">if</span> (ans[i].<span class="built_in">find</span>(S - sum) != ans[i].<span class="built_in">end</span>())</span><br><span class="line">                tot += ans[i][S - sum];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs2</span>(n + <span class="number">1</span>, k, sum);</span><br><span class="line">    <span class="built_in">dfs2</span>(n + <span class="number">1</span>, k, sum + a[n]);</span><br><span class="line">    <span class="keyword">if</span> (a[n] &lt;= <span class="number">20</span>) <span class="built_in">dfs2</span>(n + <span class="number">1</span>, k + <span class="number">1</span>, sum + jc[a[n]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = <span class="built_in">read</span>(); K = <span class="built_in">read</span>(); S = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;N; ++i) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(N / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; tot;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>CF559C Gerald and Giant Chess</title>
    <url>/2019/05/08/cf559c-gerald-and-giant-chess/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/CF559C">Gerald and Giant Chess</a> DP+组合。首先从(1,1)走到(x,y)，没有障碍的方案数是C(x+y-2,x-1)。这个求一下阶乘逆元秒出。令f[i]表示起点到第i个障碍点，不经过其它障碍点的方案数。我们添加一个“障碍”点f[n+1]：终点。那么f[n+1]就是答案。 用一根扫描线扫所有的点，即把点按x排序。考虑到点i时，如果j在i与起点形成的矩形内，那么f[i]要减去f[j]*j到i的方案数。 $O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2100</span>, M = <span class="number">1e6</span> + <span class="number">233</span>, MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h, w, n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span> <span class="keyword">int</span> x, y; &#125; p[<span class="number">2100</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p1.x == p2.x) <span class="keyword">return</span> p1.y &lt; p2.y;</span><br><span class="line">    <span class="keyword">return</span> p1.x &lt; p2.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL jc[M], ny[M], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">fpow</span><span class="params">(LL x, LL y)</span> </span>&#123;</span><br><span class="line">    LL xx = x % MOD, ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = ret * xx % MOD;</span><br><span class="line">        xx = xx * xx % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; h &gt;&gt; w &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">    p[++n].x = h; p[n].y = w;</span><br><span class="line">    <span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    jc[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; M; ++i)</span><br><span class="line">        jc[i] = jc[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">    ny[M - <span class="number">1</span>] = <span class="built_in">fpow</span>(jc[M - <span class="number">1</span>], MOD - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        ny[i] = (i + <span class="number">1</span>) * ny[i + <span class="number">1</span>] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jc[n] * ny[m] % MOD * ny[n - m] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        f[i] = <span class="built_in">C</span>(p[i].x + p[i].y - <span class="number">2</span>, p[i].x - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j].y &lt;= p[i].y) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = p[i].x - p[j].x, y = p[i].y - p[j].y;</span><br><span class="line">                f[i] -= f[j] * <span class="built_in">C</span>(x + y, x) % MOD;</span><br><span class="line">                f[i] = (f[i] % MOD + MOD) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">dp</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>CF590E Birthday Dilworth定理构造</title>
    <url>/2020/04/10/cf590e-birthday-dilworth%E5%AE%9A%E7%90%86%E6%9E%84%E9%80%A0/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF590E">CF590E Birthday</a> 首先字符串的包含关系可以直接AC自动机。需要找出每个串能匹配到的所有子串。根据下文中提到的东西，只需要找出每个位置为结尾，能匹配到的最长串，即$fail_x$能匹配到的串即可（传递性）。 之后，得到偏序关系。要求的就是它的最长反链，也就是最小链覆盖。注意Dilworth定理中的覆盖是可重的。 这里的偏序关系是DAG，传递闭包后可以当作不可重的。那么跑一个二分图匹配。 然后构造方案，就是这个题<a href="https://www.luogu.com.cn/problem/P4298">[CTSC2008]祭祀</a>。开始补习二分图基础知识： 首先DAG二分图匹配的原理： 首先构造最大独立集$I$。后面说怎么构造，假装已经有了。 那么选取两个点都在独立集内的点为答案就行了。它们构成最大反链$A$集合。 证明大概是这样的：首先这肯定是反链，因为是独立集里选的。令有$n$个点，匹配为$m$，则独立集大小为$2n-m$。其中$\notin A$的点，一定是只有一端$\in I$的，不超过$n$个。也就是说选取的集合$ \geq n-m$。而反链大小就是这个数，说明构造出的就是反链。 关于怎么选独立集：选最小点覆盖的补集即可 关于怎么选最小点覆盖： 从任意没有被选取的右边的点开始DFS。去左边只能走没选的边，去右边只能走选了的边。选取左边被访问，右边没有被访问的点集就是最小点覆盖。 （左右换一下当然没关系，网上都是这么写的而已） 证明大概是这样的（<a href="http://www.matrix67.com/blog/archives/116">这里</a>）： 这个叫König定理。两件事：有$m$个点，这$m$个点独立。 第一件事是这样的：每个点都是匹配边的一个端点。右边被选的点一定是被匹配过的。左边被选的点的右边一定是不选的。 第二件事是这样的：如果有一条边没被覆盖，讨论一下发现不管这条边是不是匹配边，都不可能左边没标记右边有标记。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cerr;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">233</span>, M = <span class="number">755</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, st[N], len[N], size; <span class="keyword">char</span> str[N], buc[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch[N][<span class="number">2</span>], fail[N], tot, end[N];</span><br><span class="line">std::queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len[id]; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!ch[now][c])</span><br><span class="line">      ch[now][c] = ++tot;</span><br><span class="line">    now = ch[now][c];</span><br><span class="line">  &#125;</span><br><span class="line">  end[now] = id;</span><br><span class="line">  <span class="comment">// cerr &lt;&lt; now &lt;&lt; &quot; &quot; &lt;&lt; id &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ch[<span class="number">0</span>][<span class="number">0</span>]) que.<span class="built_in">push</span>(ch[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">if</span> (ch[<span class="number">0</span>][<span class="number">1</span>]) que.<span class="built_in">push</span>(ch[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!ch[x][i])</span><br><span class="line">        ch[x][i] = ch[fail[x]][i];</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        fail[ch[x][i]] = ch[fail[x]][i];</span><br><span class="line">        que.<span class="built_in">push</span>(ch[x][i]);</span><br><span class="line">        <span class="keyword">if</span> (!end[ch[x][i]])</span><br><span class="line">          end[ch[x][i]] = end[fail[ch[x][i]]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> G[M][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len[id]; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    now = ch[now][c];</span><br><span class="line">    <span class="keyword">if</span> (end[now])</span><br><span class="line">      G[id][end[now]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (end[fail[now]])</span><br><span class="line">      G[id][end[fail[now]]] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[M * <span class="number">2</span>], mat[M * <span class="number">2</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungry</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> tag)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n; ++y) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!G[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (vis[y + n] != tag) &#123;</span><br><span class="line">      vis[y + n] = tag;</span><br><span class="line">      <span class="keyword">if</span> (!mat[y + n]  <span class="built_in">hungry</span>(mat[y + n], tag)) &#123;</span><br><span class="line">        mat[x] = y + n, mat[y + n] = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pick[M * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vis[x]) <span class="keyword">return</span>;</span><br><span class="line">  vis[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n; ++y)</span><br><span class="line">    <span class="keyword">if</span> (G[x][y] &amp;&amp; !vis[y + n])</span><br><span class="line">      vis[y + n] = <span class="number">1</span>, <span class="built_in">dfs</span>(mat[y + n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line">    len[i] = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">    st[i] = size + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len[i]; ++j)</span><br><span class="line">      buc[++size] = str[j];</span><br><span class="line">    <span class="built_in">insert</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">build</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">match</span>(buc + st[i] - <span class="number">1</span>, i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        G[i][j] = G[i][k] &amp; G[k][j];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    G[i][i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    cnt += <span class="built_in">hungry</span>(i, i);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n - cnt);</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (!mat[i])</span><br><span class="line">      <span class="built_in">dfs</span>(i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (vis[i] &amp;&amp; !vis[i + n])</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>CF888G Xor-MST BoruvkaTrie</title>
    <url>/2020/02/22/cf888g-xor-mst-boruvkatrie/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/problemset/problem/888/G">CF888G Xor-MST</a> 求奇怪边权的MST，考虑Boruvka。 考虑第一次Boruvka的过程。每个点选最小边，合并。把所有点放在Trie上，则体现为叶子处的点合并。 合并叶子后，Trie产生了新的叶子，进行下一次Boruvka即可。 考虑Trie上一个点，可以计算合并它左右儿子的贡献。只需从左右儿子的集合中连一条最小边。这个可以在Trie上直接查询。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, A[N], ch[N * <span class="number">40</span>][<span class="number">2</span>], tot;</span><br><span class="line"><span class="keyword">int</span> L[N], R[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; ~i; --i) &#123;</span><br><span class="line">    <span class="keyword">int</span> t = (v &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!ch[x][t])</span><br><span class="line">      ch[x][t] = ++tot;</span><br><span class="line">    x = ch[x][t];</span><br><span class="line">    L[x] = std::<span class="built_in">min</span>(L[x], id);</span><br><span class="line">    R[x] = std::<span class="built_in">max</span>(R[x], id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = d; ~i; --i) &#123;</span><br><span class="line">    <span class="keyword">int</span> t = (v &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch[x][t])</span><br><span class="line">      x = ch[x][t];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      x = ch[x][t ^ <span class="number">1</span>];</span><br><span class="line">      ret = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dep &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (ch[x][<span class="number">0</span>] &amp;&amp; ch[x][<span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L[ch[x][<span class="number">0</span>]]; i &lt;= R[ch[x][<span class="number">0</span>]]; ++i)</span><br><span class="line">      min = std::<span class="built_in">min</span>(min, <span class="built_in">query</span>(ch[x][<span class="number">1</span>], A[i], dep - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">solve</span>(ch[x][<span class="number">0</span>], dep - <span class="number">1</span>) + <span class="built_in">solve</span>(ch[x][<span class="number">1</span>], dep - <span class="number">1</span>)</span><br><span class="line">      + min + (<span class="number">1</span> &lt;&lt; dep);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch[x][<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">solve</span>(ch[x][<span class="number">0</span>], dep - <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch[x][<span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">solve</span>(ch[x][<span class="number">1</span>], dep - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, A + i);</span><br><span class="line">  std::<span class="built_in">sort</span>(A + <span class="number">1</span>, A + n + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">memset</span>(L, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(L));</span><br><span class="line">  L[<span class="number">0</span>] = <span class="number">1</span>, R[<span class="number">0</span>] = n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">insert</span>(A[i], i);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">solve</span>(<span class="number">0</span>, <span class="number">30</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>Coloring</title>
    <url>/2019/03/31/coloring/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3936">Coloring</a> 第一道AC的模拟退火。。。退火这玩意，复杂度O(玄学)，找到玄学参数之后就能过。。。 这题直接随便生成一种情况，然后随机交换两个位置，计算一下差。交换之后不用重新计算，计算两个格子就行了。然后如果更优就接受交换，不更优就用一定几率接受交换。 开小号交了十多次没过，从题解里找到个玄学式子，一次AC。貌似退火的式子都长这样来着？ exp(-delta / T) * RAND_MAX &gt; (rand() % 1000000) / 1000000.0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> TEMP = <span class="number">1</span>, eps = <span class="number">1e-5</span>, COOL = <span class="number">0.99999</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, c, p[N], ans[N][N], tmp[N][N], best[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, now = <span class="number">1</span>, cnt = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            ans[i][j] = now;</span><br><span class="line">            <span class="keyword">if</span> (++cnt == p[now]) &#123;</span><br><span class="line">                ++now;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc1</span><span class="params">(<span class="keyword">int</span> a[N][N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> delta = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] != a[i][j + <span class="number">1</span>]) ++delta;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] != a[i][j - <span class="number">1</span>]) ++delta;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] != a[i + <span class="number">1</span>][j]) ++delta;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] != a[i - <span class="number">1</span>][j]) ++delta;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> delta = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (tmp[x][y] != tmp[x - <span class="number">1</span>][y]) ++delta;</span><br><span class="line">    <span class="keyword">if</span> (tmp[x][y] != tmp[x][y - <span class="number">1</span>]) ++delta;</span><br><span class="line">    <span class="keyword">if</span> (tmp[x][y] != tmp[x + <span class="number">1</span>][y]) ++delta;</span><br><span class="line">    <span class="keyword">if</span> (tmp[x][y] != tmp[x][y + <span class="number">1</span>]) ++delta;</span><br><span class="line">    <span class="keyword">return</span> delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> T = TEMP;</span><br><span class="line">    <span class="keyword">int</span> baka = <span class="built_in">calc1</span>(best);</span><br><span class="line">    <span class="built_in">memcpy</span>(tmp, ans, <span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">    <span class="keyword">while</span> (T &gt; eps) &#123;</span><br><span class="line">        T *= COOL;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="built_in">rand</span>() % n + <span class="number">1</span>, x2 = <span class="built_in">rand</span>() % n + <span class="number">1</span>,</span><br><span class="line">            y1 = <span class="built_in">rand</span>() % m + <span class="number">1</span>, y2 = <span class="built_in">rand</span>() % m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> delta = -(<span class="built_in">calc2</span>(x1, y1) + <span class="built_in">calc2</span>(x2, y2));</span><br><span class="line">        <span class="built_in">swap</span>(tmp[x1][y1], tmp[x2][y2]);</span><br><span class="line">        delta += <span class="built_in">calc2</span>(x1, y1) + <span class="built_in">calc2</span>(x2, y2);</span><br><span class="line">        <span class="comment">// 玄学参数强无敌= =</span></span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>  <span class="built_in">exp</span>(-delta / T) * RAND_MAX &gt; (<span class="built_in">rand</span>() % <span class="number">1000000</span>) / <span class="number">1000000.0</span>)</span><br><span class="line">            <span class="built_in">swap</span>(ans[x1][y1], ans[x2][y2]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">swap</span>(tmp[x1][y1], tmp[x2][y2]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">calc1</span>(ans) &lt; <span class="built_in">calc1</span>(best))</span><br><span class="line">        <span class="built_in">memcpy</span>(best, ans, <span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">srand</span>(<span class="number">894</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++i)</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            best[i][j] = <span class="built_in">rand</span>();</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i)</span><br><span class="line">        <span class="built_in">sa</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            cout &lt;&lt; best[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>Common Substrings</title>
    <url>/2019/06/14/common-substrings/</url>
    <content><![CDATA[<p>求两个字符串长度不小于 k 的公共子串的个数（可以相同）。 <a href="http://poj.org/problem?id=3415">Common Substrings</a> 终于刷完论文里的题了。事实证明还是什么都不会。 应该论文里是最难的一道。 题目要求的是$\sum_i \sum_j \sum_{k=K} [A[i…k]=B[j…k]]$。换句话说，就是$\sum_i \sum_j (lcp(i,j)-K+1)$。 枚举就凉了。利用sa性质。对在sa中A串在B串后和B串在A串后分别考虑。 假设现在统计B串在A串后对答案产生的贡献。按height&gt;=K把sa分开，处理每一块。维护一个单调栈，维护单增的height。因为lcp是区间min，如果加入小值，会影响新加入串和之前的lcp。 维护一个变量，表示扫过的所有B串子串对新增加进来的A的贡献。 每次把单调栈中元素合并，记录每个值代表几个串。如果扫到A串就更新答案。 另一种情况同理。 $O(nlogn)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">2333</span>, S = <span class="number">666</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, s[N], bl[N]; <span class="keyword">char</span> ch[N];</span><br><span class="line"><span class="keyword">int</span> x[N], y[N], c[N], ht[N], rk[N], sa[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(s)); n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ch + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(ch + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len; ++j)</span><br><span class="line">            s[++n] = ch[j], bl[n] = i;</span><br><span class="line">        s[++n] = i + <span class="number">233</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i] = s[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) sa[c[x[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, p = <span class="number">0</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>, p = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; ++i) y[++p] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt; k) y[++p] = sa[i] - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[y[i]]]--] = y[i];</span><br><span class="line">        <span class="built_in">swap</span>(x, y); x[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            x[sa[i]] = y[sa[i]] == y[sa[i - <span class="number">1</span>]]</span><br><span class="line">                &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]</span><br><span class="line">                ? p : ++p;</span><br><span class="line">        <span class="keyword">if</span> (p == n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, p = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (p) --p;</span><br><span class="line">        <span class="keyword">while</span> (s[i + p] == s[j + p]) ++p;</span><br><span class="line">        ht[rk[i]] = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL ans, sum;</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">2</span>], top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// push the first string in, calc the second one</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ht[i] &lt; m)</span><br><span class="line">            sum = top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (bl[sa[i - <span class="number">1</span>]] == <span class="number">1</span>) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                sum += ht[i] - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (top &amp;&amp; ht[i] &lt;= st[top][<span class="number">0</span>]) &#123;</span><br><span class="line">                sum -= st[top][<span class="number">1</span>] * (st[top][<span class="number">0</span>] - ht[i]);</span><br><span class="line">                cnt += st[top--][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            st[++top][<span class="number">0</span>] = ht[i];</span><br><span class="line">            st[top][<span class="number">1</span>] = cnt;</span><br><span class="line">            <span class="keyword">if</span> (bl[sa[i]] == <span class="number">2</span>)</span><br><span class="line">                ans += sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push the second string in, calc the first one</span></span><br><span class="line">    top = sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ht[i] &lt; m)</span><br><span class="line">            sum = top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (bl[sa[i - <span class="number">1</span>]] == <span class="number">2</span>) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                sum += ht[i] - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (top &amp;&amp; ht[i] &lt;= st[top][<span class="number">0</span>]) &#123;</span><br><span class="line">                sum -= st[top][<span class="number">1</span>] * (st[top][<span class="number">0</span>] - ht[i]);</span><br><span class="line">                cnt += st[top--][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            st[++top][<span class="number">0</span>] = ht[i];</span><br><span class="line">            st[top][<span class="number">1</span>] = cnt;</span><br><span class="line">            <span class="keyword">if</span> (bl[sa[i]] == <span class="number">1</span>)</span><br><span class="line">                ans += sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m), m) &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">SA</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>CQOI2011动态逆序对</title>
    <url>/2019/06/01/cqoi2011%E5%8A%A8%E6%80%81%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<p>[[CQOI2011]动态逆序对] 一对点$i,j$如果对答案产生贡献，那么$pos_i&lt;pos_j,val_i&gt;val_j$，是二维偏序。这题带上了修改，变成三维偏序。 不带修改的逆序对，树状数组求一下就行了。带删除点的话，每次删完之后把答案里这个点产生的贡献删掉就行。一个点的贡献，取决于在它前面，且值比它大的数数量，与在它后面，且比它小的数数量。 用树套树维护这玩意。具体来说，树状数组套线段树。树状数组维护位置，线段树维护值。线段树可以求出比某个数大/小的数字数量，两个位置减一下，就是区间比某个数大/小的数量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">233</span>, M = N * <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, num[N], pos[N], ls[M], rs[M], rt[N],</span><br><span class="line">    v[M], tot, que_a[N], que_b[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) p = ++tot;</span><br><span class="line">    v[p] += y;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">        <span class="built_in">change</span>(ls[p], x, y, L, mid);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">change</span>(rs[p], x, y, mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    que_a[<span class="number">0</span>] = que_b[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">        que_a[++que_a[<span class="number">0</span>]] = rt[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">        que_b[++que_b[<span class="number">0</span>]] = rt[i];</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">1</span>, R = n, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L != R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= que_a[<span class="number">0</span>]; ++i)</span><br><span class="line">                    ret -= v[rs[que_a[i]]];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= que_b[<span class="number">0</span>]; ++i)</span><br><span class="line">                    ret += v[rs[que_b[i]]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= que_a[<span class="number">0</span>]; ++i)</span><br><span class="line">                que_a[i] = ls[que_a[i]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= que_b[<span class="number">0</span>]; ++i)</span><br><span class="line">                que_b[i] = ls[que_b[i]];</span><br><span class="line">            R = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= que_a[<span class="number">0</span>]; ++i)</span><br><span class="line">                    ret -= v[ls[que_a[i]]];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= que_b[<span class="number">0</span>]; ++i)</span><br><span class="line">                    ret += v[ls[que_b[i]]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= que_a[<span class="number">0</span>]; ++i)</span><br><span class="line">                que_a[i] = rs[que_a[i]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= que_b[<span class="number">0</span>]; ++i)</span><br><span class="line">                que_b[i] = rs[que_b[i]];</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        pos[num[i] = <span class="built_in">rd</span>()] = i;</span><br><span class="line">        ans += <span class="built_in">query</span>(<span class="number">1</span>, i - <span class="number">1</span>, num[i], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += <span class="built_in">lowbit</span>(j))</span><br><span class="line">            <span class="built_in">change</span>(rt[j], num[i], <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>();</span><br><span class="line">        ans -= <span class="built_in">query</span>(<span class="number">1</span>, pos[x] - <span class="number">1</span>, x, <span class="number">0</span>);</span><br><span class="line">        ans -= <span class="built_in">query</span>(pos[x] + <span class="number">1</span>, n, x, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = pos[x]; j &lt;= n; j += <span class="built_in">lowbit</span>(j))</span><br><span class="line">            <span class="built_in">change</span>(rt[j], x, <span class="number">-1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>CQOI2009跳舞</title>
    <url>/2019/03/27/cqoi2009%E8%B7%B3%E8%88%9E/</url>
    <content><![CDATA[<p>友情链接：<a href="https://gekoo.xyz/">附中舞王cwy的博客</a> <a href="https://www.luogu.org/problemnew/show/P3153">[CQOI2009]跳舞</a> 没跳过舞。。。几首舞曲的意思是所有人都跳这么多。。。孤陋寡闻是我。 网络流题，每个人拆成喜欢不喜欢的点分别连接。S向男生喜欢连边，男喜欢向不喜欢，女不喜欢向喜欢连边，女喜欢向T连边。这样就用拆点限制了不喜欢的人数。 然后就不会了…看了题解发现是二分答案。二分出mid，S向男女向T连这么大的边，然后最大流，如果maxflow==mid*n，那么说明是可行的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">60</span>,M=N*N*<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt,flow;</span><br><span class="line">&#125;g[M*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[M],tot=<span class="number">1</span>,dep[M],n,m,num,s=++num,t=++num,id[N][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> ch[N][N];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    g[++tot].to=y,g[tot].nxt=head[x],</span><br><span class="line">    g[tot].flow=f,head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="built_in">addedge</span>(x,y,f);</span><br><span class="line">    <span class="built_in">addedge</span>(y,x,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dep));</span><br><span class="line">    dep[s]=<span class="number">1</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=que.<span class="built_in">front</span>();que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=g[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!g[i].flowdep[g[i].to])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            dep[g[i].to]=dep[x]+<span class="number">1</span>;</span><br><span class="line">            que.<span class="built_in">push</span>(g[i].to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> mf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==t)<span class="keyword">return</span> mf;</span><br><span class="line">    <span class="keyword">int</span> used=<span class="number">0</span>,tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=g[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!g[i].flowdep[g[i].to]!=dep[x]+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        tmp=<span class="built_in">dfs</span>(g[i].to,<span class="built_in">min</span>(g[i].flow,mf-used));</span><br><span class="line">        <span class="keyword">if</span>(tmp)&#123;</span><br><span class="line">            g[i].flow-=tmp;</span><br><span class="line">            g[i^<span class="number">1</span>].flow+=tmp;</span><br><span class="line">            used+=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> dep[g[i].to]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(used==mf)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!used)dep[x]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())ans+=<span class="built_in">dfs</span>(s,INF);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0-&gt;yes 1-&gt;no</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head)); tot=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">add</span>(s,id[i][<span class="number">0</span>][<span class="number">0</span>],mid);</span><br><span class="line">        <span class="built_in">add</span>(id[i][<span class="number">1</span>][<span class="number">0</span>],t,mid);</span><br><span class="line">        <span class="built_in">add</span>(id[i][<span class="number">0</span>][<span class="number">0</span>],id[i][<span class="number">0</span>][<span class="number">1</span>],m);</span><br><span class="line">        <span class="built_in">add</span>(id[i][<span class="number">1</span>][<span class="number">1</span>],id[i][<span class="number">1</span>][<span class="number">0</span>],m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[i][j]==<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">                <span class="built_in">add</span>(id[i][<span class="number">0</span>][<span class="number">0</span>],id[j][<span class="number">1</span>][<span class="number">0</span>],<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">add</span>(id[i][<span class="number">0</span>][<span class="number">1</span>],id[j][<span class="number">1</span>][<span class="number">1</span>],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)cin&gt;&gt;(ch[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;++k)</span><br><span class="line">                id[i][j][k]=++num;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,l=<span class="number">0</span>,r=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">build</span>(mid);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dinic</span>()==mid*n)ans=mid,l=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>CQOI2016手机号码</title>
    <url>/2019/05/17/cqoi2016%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4124">[CQOI2016]手机号码</a> 数位DP题。数位DP挺恶心的，正好总结一下。 数位DP记搜写起来爽。搜索的时候要记录位置，是否有限制，是否有前导0，以及题目要求的一些限制。如果搜到头返回的不一定是1，那么把返回值放在函数参数里。 如果要求的东西很难搜，可以拆解成多个子问题一个一个搜。 本题要记录有没有8，有没有4，前两位数字，整个数字里有没有出现过连续三位。前导0有点麻烦，拆解问题，枚举首位数字搜就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dig[<span class="number">20</span>];</span><br><span class="line"><span class="comment">// pos last1 last2 8 4 st</span></span><br><span class="line">LL f[<span class="number">15</span>][<span class="number">15</span>][<span class="number">15</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> last1, <span class="keyword">int</span> last2, <span class="keyword">bool</span> eight, <span class="keyword">bool</span> four, <span class="keyword">bool</span> lim, <span class="keyword">bool</span> st)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (eight &amp;&amp; four)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!pos)</span><br><span class="line">        <span class="keyword">return</span> st;</span><br><span class="line">    <span class="keyword">if</span> (!lim &amp;&amp; f[pos][last1][last2][eight][four][st] != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> f[pos][last1][last2][eight][four][st];</span><br><span class="line">    <span class="keyword">int</span> up = lim ? dig[pos] : <span class="number">9</span>;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= up; ++i)</span><br><span class="line">        ret += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, i, last1, <span class="built_in">eight</span>  (i == <span class="number">8</span>), <span class="built_in">four</span>  (i == <span class="number">4</span>), lim &amp;&amp; (i == dig[pos]), <span class="built_in">st</span>  (i == last1 &amp;&amp; i == last2));</span><br><span class="line">    <span class="keyword">if</span> (!lim)</span><br><span class="line">        f[pos][last1][last2][eight][four][st] = ret;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        dig[++len] = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len != <span class="number">11</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dig[len]; ++i)</span><br><span class="line">        ret += <span class="built_in">dfs</span>(len - <span class="number">1</span>, i, <span class="number">0</span>, i == <span class="number">8</span>, i == <span class="number">4</span>, i == dig[len], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL a, b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">solve</span>(b) - <span class="built_in">solve</span>(a - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>Cqoi2014数三角形</title>
    <url>/2019/02/14/cqoi2014%E6%95%B0%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3505">[Cqoi2014]数三角形</a> 平面内任选三个点，只有共线时才不能组成三角形。组成三角方案数=总方案-三点平行于xy轴-三点斜着共线。 枚举x, y，将其视为三角形存在一条边，从(1, 1)到(x, y)。在此线上的点数量为gcd(x, y) - 1，即可算出答案。此处仅给出直觉上的原因：令(x’, y’)尽可能小，若g = gcd(x, y)，x’ = x / g, y’ = y / g。其它点为(kx’, ky’)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">    ll a, b, ans; cin &gt;&gt; a &gt;&gt; b; ++a, ++b;</span><br><span class="line">    ans = (a * b) * (a * b - <span class="number">1</span>) * (a * b - <span class="number">2</span>) / <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= <span class="number">3</span>) ans -= a * (a - <span class="number">1</span>) * (a - <span class="number">2</span>) / <span class="number">6</span> * b;</span><br><span class="line">    <span class="keyword">if</span> (b &gt;= <span class="number">3</span>) ans -= b * (b - <span class="number">1</span>) * (b - <span class="number">2</span>) / <span class="number">6</span> * a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; b; ++j)</span><br><span class="line">            ans -= (a - i) * (b - j) * (__gcd(i, j) - <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>CSP-S 2019 题解</title>
    <url>/2019/12/02/csp-s-2019-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="格雷码"><a href="#格雷码" class="headerlink" title="格雷码"></a>格雷码</h3><p>签到题。模拟题意，递归做就行了。</p>
<h3 id="括号树"><a href="#括号树" class="headerlink" title="括号树"></a>括号树</h3><p>考虑序列上的DP 令$f_i,g_i$分别表示$[1,i]$的答案和以$i$的括号结尾的合法对有多少。用栈维护括号序列。如果是左括号，继承之前的$f$，否则记栈顶为$j$ $$g_i = g_{j-1} + 1$$ $$f_i=f_{i-1}+g_i$$ 把这个序列上的简单DP丢到树上即可。因为每次只对栈操作一下，用一个变量记录操作即可。</p>
<h3 id="树上的数"><a href="#树上的数" class="headerlink" title="树上的数"></a>树上的数</h3><p>神仙题，先咕了。</p>
<h3 id="Emiya家今天的饭"><a href="#Emiya家今天的饭" class="headerlink" title="Emiya家今天的饭"></a>Emiya家今天的饭</h3><p>我们记$S_i= \sum_{j=1}^n A_{i,j}$ 考虑一个$O(n^3m)$的DP。先求出总方案数，减去不合法方案。发现只会有一列超出限制。枚举列$x$，令$f_{i,j,k}$表示前$i$行，总共，这一列分别选了$j,k$个的方案数。 $$f_{i,j,k}=f_{i-1,j,k}+f_{i-1,j-1,k-1} A_{i,x} + f_{i-1,j-1,k} (S_i-A_{i,x})$$ 实际上并不需要知道两种具体有多少，只需要知道差值。考虑$O(n^2m)$，定义$f_{i,j}$为前$i$行，$x$列减其他列为$j$： $$f_{i,j}=f_{i-1,j}+ f_{i-1,j-1}A_{i,x}+f_{i-1,j+1}(S_i-A_{i,x})$$</p>
<h3 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h3><p>可以猜到一个结论：最优方案中，最后一段的和最小。结论看上去是比较显然的，然而具体证明比较麻烦。可以考虑使用反证+数学归纳，或者用<a href="http://matthew99.blog.uoj.ac/blog/5299">毛爷爷的官方题解的方法</a> 有了这个结论，就可以考虑DP了。定义$f_i$为以$i$结尾的最优方案，最后一段的开始位置$-1$的位置。 记前缀和为$s$，如果$j$可以转移到$i$，有 $$s_i - s_j \geq s_j - s_{f_j} \rightarrow s_i \geq 2s_j - s_{f_j}$$ 用单调队列维护就行了。 因为卡空间，最后用$f$构造答案。用两个long long压在一起当高精度。考完写的时候我直接用了__int128。</p>
<h3 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h3><p>一种思路是发现重心在重链上，考虑倍增，枚举断边，分成子树和非子树计算。 另一种思路，是枚举每个点，计算它是多少方案的重心。记录枚举的点的最大，次大儿子为$x,y$。记子树大小为$S$，删掉了$k$个点。如果删去的是非$x$内的边，有： $$S_x \leq \lfloor \frac{n-k}{2} \rfloor \rightarrow k \leq n - 2 S_x$$ 如果删的是$x$内的边，最大的儿子可能变成$y$。有： $$S_x - k \leq \lfloor \frac{n-k}{2} \rfloor, S_y \leq \lfloor \frac{n-k}{2} \rfloor$$ $$\rightarrow 2S_x - n \leq k \leq n - 2 S_y$$ 于是可以考虑维护每个子树内可以删的点大小是什么。这个可以通过线段树合并简单维护。 考虑计算原树子树内的一个点，它的儿子会加上父亲所在的那个树。所有子树可用的大小，可以通过树状数组动态维护。父亲的即是删掉其它儿子剩下的那一部分。</p>
<hr>
<h3 id="下面是Day2三道题的代码"><a href="#下面是Day2三道题的代码" class="headerlink" title="下面是Day2三道题的代码"></a>下面是Day2三道题的代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>, M = <span class="number">2005</span>, P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, A[N][M], S[N], f[N][N * <span class="number">2</span>], ans = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">  f[<span class="number">0</span>][n + <span class="number">10</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n + <span class="number">10</span> - i; j &lt;= n + <span class="number">10</span> + i; ++j)</span><br><span class="line">      f[i][j] = ((f[i - <span class="number">1</span>][j] + (ll)f[i - <span class="number">1</span>][j - <span class="number">1</span>] * A[i][x] % P</span><br><span class="line">        + (ll)f[i - <span class="number">1</span>][j + <span class="number">1</span>] * (S[i] - A[i][x]) % P) % P + P) % P;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    ret = (ret + f[n][i + n + <span class="number">10</span>]) % P;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">      S[i] = (S[i] + (A[i][j] = <span class="built_in">rd</span>())) % P;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    ans = (ll)ans * (S[i] + <span class="number">1</span>) % P;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    ans = (ans - <span class="built_in">calc</span>(i) + P) % P;</span><br><span class="line">  ans = (ans - <span class="number">1</span> + P) % P;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(__int128 x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">write</span>(x / <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e7</span> + <span class="number">233</span>, M = <span class="number">1e5</span> + <span class="number">233</span>, MOD = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, type, P[M], L[M], R[M];</span><br><span class="line">ll sum[N], B[N]; <span class="keyword">int</span> que[N], head, tail, f[N];</span><br><span class="line">__int128 ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">rd</span>(), type = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      sum[i] = sum[i - <span class="number">1</span>] + <span class="built_in">rd</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>(), z = <span class="built_in">rd</span>(), m, now = <span class="number">1</span>;</span><br><span class="line">    B[<span class="number">1</span>] = <span class="built_in">rd</span>(), B[<span class="number">2</span>] = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">      P[i] = <span class="built_in">rd</span>(), L[i] = <span class="built_in">rd</span>(), R[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i)</span><br><span class="line">      B[i] = (x * B[i - <span class="number">1</span>] + y * B[i - <span class="number">2</span>] + z) % MOD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; P[now]) ++now;</span><br><span class="line">      sum[i] = sum[i - <span class="number">1</span>] + (B[i] % (R[now] - L[now] + <span class="number">1</span>)) + L[now];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (head != tail &amp;&amp; sum[i] &gt;= <span class="number">2</span> * sum[que[head + <span class="number">1</span>]] - sum[f[que[head + <span class="number">1</span>]]])</span><br><span class="line">      ++head;</span><br><span class="line">    f[i] = que[head];</span><br><span class="line">    <span class="keyword">while</span> (head != tail &amp;&amp; <span class="number">2</span> * sum[i] - sum[f[i]] &lt;= <span class="number">2</span> * sum[que[tail]] - sum[f[que[tail]]])</span><br><span class="line">      --tail;</span><br><span class="line">    que[++tail] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( ; n; n = f[n])</span><br><span class="line">    ans += (__int128)(sum[n] - sum[f[n]]) * (sum[n] - sum[f[n]]);</span><br><span class="line">  <span class="built_in">write</span>(ans), <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">2333</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125; G[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  G[++tot].to = y, G[tot].nxt = head[x],</span><br><span class="line">  head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ls[N * <span class="number">50</span>], rs[N * <span class="number">50</span>], sum[N * <span class="number">50</span>], num, root[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> L = <span class="number">1</span>, <span class="keyword">int</span> R = n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = ++num; sum[p] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (L != R) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) ls[p] = <span class="built_in">insert</span>(x, L, mid);</span><br><span class="line">    <span class="keyword">else</span> rs[p] = <span class="built_in">insert</span>(x, mid + <span class="number">1</span>, R);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!x  !y) <span class="keyword">return</span> x + y;</span><br><span class="line">  <span class="keyword">int</span> p = ++num;</span><br><span class="line">  sum[p] = sum[x] + sum[y];</span><br><span class="line">  ls[p] = <span class="built_in">merge</span>(ls[x], ls[y]);</span><br><span class="line">  rs[p] = <span class="built_in">merge</span>(rs[x], rs[y]);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R)</span><br><span class="line">    <span class="keyword">return</span> sum[p];</span><br><span class="line">  <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">    ret += <span class="built_in">query</span>(ls[p], l, r, L, mid);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">    ret += <span class="built_in">query</span>(rs[p], l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">query</span>(p, l, r, <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bit[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; x &lt;= n; x += x &amp; -x)</span><br><span class="line">    bit[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( ; x; x -= x &amp; -x)</span><br><span class="line">    ret += bit[x];</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ask</span>(r) - <span class="built_in">ask</span>(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> left_x[N], right_x[N], left_nx[N], right_nx[N];</span><br><span class="line"><span class="keyword">int</span> max[N][<span class="number">2</span>], size[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  size[x] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = G[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = G[i].to;</span><br><span class="line">    <span class="keyword">if</span> (y != fa) &#123;</span><br><span class="line">      <span class="built_in">dfs1</span>(y, x);</span><br><span class="line">      size[x] += size[y];</span><br><span class="line">      <span class="keyword">if</span> (size[y] &gt; size[max[x][<span class="number">0</span>]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (size[max[x][<span class="number">0</span>]] &gt; size[max[x][<span class="number">1</span>]])</span><br><span class="line">          max[x][<span class="number">1</span>] = max[x][<span class="number">0</span>];</span><br><span class="line">        max[x][<span class="number">0</span>] = y;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size[y] &gt; size[max[x][<span class="number">1</span>]])</span><br><span class="line">          max[x][<span class="number">1</span>] = y;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> mx = size[max[x][<span class="number">0</span>]], mx2 = size[max[x][<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n - size[x] &gt; size[max[x][<span class="number">0</span>]]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size[max[x][<span class="number">0</span>]] &gt; size[max[x][<span class="number">1</span>]]) &#123;</span><br><span class="line">      max[x][<span class="number">1</span>] = max[x][<span class="number">0</span>];</span><br><span class="line">      mx2 = size[max[x][<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    max[x][<span class="number">0</span>] = fa;</span><br><span class="line">    mx = n - size[x];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n - size[x] &gt; size[max[x][<span class="number">1</span>]]) &#123;</span><br><span class="line">      max[x][<span class="number">1</span>] = fa;</span><br><span class="line">      mx2 = n - size[x];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fa) <span class="built_in">add</span>(size[x], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  left_nx[x] = <span class="number">1</span>;</span><br><span class="line">  right_nx[x] = n - <span class="number">2</span> * mx;</span><br><span class="line">  left_x[x] = std::<span class="built_in">max</span>(<span class="number">2</span> * mx - n, <span class="number">1</span>);</span><br><span class="line">  right_x[x] = n - <span class="number">2</span> * mx2;</span><br><span class="line"></span><br><span class="line">  root[x] = <span class="built_in">insert</span>(size[x]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = G[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = G[i].to;</span><br><span class="line">    <span class="keyword">if</span> (y != fa) &#123;</span><br><span class="line">      root[x] = <span class="built_in">merge</span>(root[x], root[y]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (max[x][<span class="number">0</span>] != fa) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = G[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">int</span> y = G[i].to;</span><br><span class="line">      <span class="keyword">if</span> (y == max[x][<span class="number">0</span>]) &#123;</span><br><span class="line">        ans -= (ll)x * <span class="built_in">query</span>(root[y], left_nx[x], right_nx[x]);</span><br><span class="line">        ans += (ll)x * <span class="built_in">query</span>(root[y], left_x[x], right_x[x]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = G[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">int</span> y = G[i].to;</span><br><span class="line">      <span class="keyword">if</span> (y != fa) &#123;</span><br><span class="line">        ans -= (ll)x * <span class="built_in">query</span>(root[y], left_x[x], right_x[x]);</span><br><span class="line">        ans += (ll)x * <span class="built_in">query</span>(root[y], left_nx[x], right_nx[x]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (max[x][<span class="number">0</span>] == fa)</span><br><span class="line">    ans += (ll)x * <span class="built_in">ask</span>(left_x[x], right_x[x]);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ans += (ll)x * <span class="built_in">ask</span>(left_nx[x], right_nx[x]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = G[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = G[i].to;</span><br><span class="line">    <span class="keyword">if</span> (y != fa) &#123;</span><br><span class="line">      <span class="built_in">add</span>(n - size[y], <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">add</span>(size[y], <span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">dfs2</span>(y, x);</span><br><span class="line">      <span class="built_in">add</span>(n - size[y], <span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">add</span>(size[y], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    head[i] = root[i] = size[i] = left_x[i] = left_nx[i] = right_x[i] =</span><br><span class="line">      right_nx[i] = max[i][<span class="number">0</span>] = max[i][<span class="number">1</span>] = bit[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">    ls[i] = rs[i] = sum[i] = <span class="number">0</span>;</span><br><span class="line">  ans = tot = num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  n = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">addedge</span>(x, y);</span><br><span class="line">    <span class="built_in">addedge</span>(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> T = <span class="built_in">rd</span>(); T; --T)</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>CSP-S 2019 退役记</title>
    <url>/2019/11/14/csp2019-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h3><p>去试了机子,只能说勉强能用… 考场环境勉强 比去年lfyz差很多</p>
<h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><h3 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>嗯。。。T3写了两个小时 写了10分。。。</p>
<h3 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h3><p>什么都不会 三个暴力 然后去吃好吃的买过冬衣服配了新眼镜…</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>把之前那些激动的话删了 认真说几句 Day1的考场上 T3写了很久 然而什么都没玩出来 链的部分分和暴力拍 挂了 Day2考场上先水了T1T2的64分暴力 然后开T3发现十分可做 于是写到十一点半多 T3还是没调出来 好在已经写了链和二叉树 十分钟暴力跑路 Day1T3的链部分分虽然写的是错的,但是在数据比较水的情况下有分 Day2T2的n^2 DP数组继承方向反了 然而过了所有能跑过去的下发大样例… Day1 100 + 100 + 10 + ? Day2 64 + ? + 75 总分:看数据心情 [349, 438] (当然,显然最高分最低分大概率都取不到) 虽然考的很菜 但是因为SX本身就很菜 即使取到最低分也是前5………………………..无力吐槽 于是大约退役失败了 说实话 这次发挥并不怎么样 菜是原罪 慢慢提升 然而考试策略还是有很大的问题 首先是没怎么对拍 然后时间分配有问题 主要是平常莽正解比较多 一直没怎么注意过这些问题 Day2如果把时间放在T1或者T2上就win了 T180多分的DP很水 T2的结论也不是那么不显然 实际上T3没写出来还是码力不行 <strong>丢人啊</strong> 等出分再更吧</p>
<hr>
<p>Update 12.1： 官方数据出了 D2T2一分没挂 感谢毛爷爷出的水数据 于是我变成SX RK1了。。。。神奇的事情。。。 然而还是很自闭 翻身是因为数据水 写挂还是写挂 咸鱼还是咸鱼 再接再厉8 SXOI2020见</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>CSP2019树上的数 贪心链表并查集</title>
    <url>/2020/05/16/csp2019%E6%A0%91%E4%B8%8A%E7%9A%84%E6%95%B0-%E8%B4%AA%E5%BF%83%E9%93%BE%E8%A1%A8%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5659">树上的数</a> 首先，枚举数字，再枚举目的地，贪心。先考虑一下菊花图怎么做： 对于菊花图把边的选择顺序写出来，发现可以串成一条链。对于一次移动，可以发现限制是两条边必须一前一后的移动。那么用一些数据结构维护这个东西就可以了。 考虑一般情况，对于一次$x \rightarrow y$的移动，有这样的限制：$x$出边是$x$最先走的，$y$入边是$y$最后走的，中间点的两条边是连续的。 注意到限制对于点是独立的。那么每个点都可以看做一个菊花，有第一条，最后一条，以及一些先后的顺序的限制。 对于每个菊花，一条路径是好的，除了不能成环，起点终点的边这样的限制外，还需要满足：当起点和终点在一条链的时候，这条链必须把所有点串起来。 菊花内部在过程中会产生很多链，用链表维护。当然也可以用并查集。 求解是$O(n^3)$的，但是按DFS序枚举目的地，就可以做到总复杂度$O(n^2)$了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2050</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, id[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125; G[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Chain</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> fir, lst, cnt;</span><br><span class="line">  <span class="keyword">bool</span> st[N], ed[N];</span><br><span class="line">  <span class="keyword">int</span> fa[N];</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fir = lst = cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      fa[i] = i;</span><br><span class="line">      st[i] = ed[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  G[++tot] = &#123; y, head[x] &#125;;</span><br><span class="line">  head[x] = tot, ++t[x].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = n + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (fa &amp;&amp; (!t[x].lst  t[x].lst == fa) &amp;&amp; !(t[x].fir &amp;&amp; t[x].cnt &gt; <span class="number">1</span> &amp;&amp; t[x].<span class="built_in">find</span>(fa) == t[x].<span class="built_in">find</span>(t[x].fir)) &amp;&amp; t[x].ed[fa])</span><br><span class="line">    ans = x;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = G[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((i &gt;&gt; <span class="number">1</span>) != fa) &#123;</span><br><span class="line">      <span class="keyword">int</span> y = G[i].to;</span><br><span class="line">      <span class="keyword">if</span> (!fa) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((!t[x].fir  t[x].fir == (i &gt;&gt; <span class="number">1</span>)) &amp;&amp; t[x].st[i &gt;&gt; <span class="number">1</span>]</span><br><span class="line">            &amp;&amp; !(t[x].lst &amp;&amp; t[x].cnt &gt; <span class="number">1</span> &amp;&amp; t[x].<span class="built_in">find</span>(i &gt;&gt; <span class="number">1</span>) == t[x].<span class="built_in">find</span>(t[x].lst)))</span><br><span class="line">          ans = std::<span class="built_in">min</span>(ans, <span class="built_in">find</span>(y, i &gt;&gt; <span class="number">1</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((!t[x].lst  fa != t[x].lst) &amp;&amp; (!t[x].<span class="built_in">fir</span>  (i &gt;&gt; <span class="number">1</span>) != t[x].fir) &amp;&amp; t[x].<span class="built_in">find</span>(fa) != t[x].<span class="built_in">find</span>(i &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            &amp;&amp; t[x].st[i &gt;&gt; <span class="number">1</span>] &amp;&amp; t[x].ed[fa] &amp;&amp; !(t[x].fir &amp;&amp; t[x].lst &amp;&amp; t[x].cnt &gt; <span class="number">2</span></span><br><span class="line">            &amp;&amp; t[x].<span class="built_in">find</span>(fa) == t[x].<span class="built_in">find</span>(t[x].fir) &amp;&amp; t[x].<span class="built_in">find</span>(i &gt;&gt; <span class="number">1</span>) == t[x].<span class="built_in">find</span>(t[x].lst)))</span><br><span class="line">          ans = std::<span class="built_in">min</span>(ans, <span class="built_in">find</span>(y, i &gt;&gt; <span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x == to) &#123;</span><br><span class="line">    t[x].lst = fa;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = G[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((i &gt;&gt; <span class="number">1</span>) != fa) &#123;</span><br><span class="line">      <span class="keyword">int</span> y = G[i].to;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">merge</span>(y, i &gt;&gt; <span class="number">1</span>, to)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!fa) &#123;</span><br><span class="line">          t[x].fir = i &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          t[x].ed[fa] = t[x].st[i &gt;&gt; <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">          --t[x].cnt;</span><br><span class="line">          t[x].fa[t[x].<span class="built_in">find</span>(fa)] = t[x].<span class="built_in">find</span>(i &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cin &gt;&gt; n; tot = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    head[i] = <span class="number">0</span>;</span><br><span class="line">    t[i].<span class="built_in">init</span>();</span><br><span class="line">    std::cin &gt;&gt; id[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt; n; ++i) &#123;</span><br><span class="line">    std::cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="built_in">addedge</span>(x, y);</span><br><span class="line">    <span class="built_in">addedge</span>(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) &#123; std::cout &lt;&lt; <span class="string">&quot;1\n&quot;</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> to = <span class="built_in">find</span>(id[i], <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">merge</span>(id[i], <span class="number">0</span>, to);</span><br><span class="line">    std::cout &lt;&lt; to &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> T; std::cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>CSP2020贪吃蛇 贪心</title>
    <url>/2020/11/15/csp2020%E8%B4%AA%E5%90%83%E8%9B%87-%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<p>周末偷偷看了看CSP T4，发现非常刺激，铁牌退役狗想了一中午（不过感觉比树上的树简单不少） 注意到本题中的蛇只需要最大化自己吃几个，不需要最大化排名。我们称拥有其它蛇梦寐以求的选择权利的蛇为后浪蛇（当前值最大），没有选择权利的蛇为打工蛇（当前值最小）。 考虑后浪蛇的策略：如果吃掉打工蛇，在游戏之后一定不会死，那就吃，否则就不吃。于是只需要求会不会死。 可以发现吃掉打工蛇之后，如果自己没有变成打工蛇，那么它的值一定大于之后产生的所有新蛇，于是不会死可以吃。如果吃掉后只剩下自己，也可以吃。 如果后浪蛇吃掉打工蛇后自己变成打工蛇，那么它很可能被下一个吃掉。于是只需判断下一个后浪蛇是否可以吃掉它。如果吃掉当前打工蛇，下一个后浪蛇可以吃掉自己，那么就必须停止游戏。否则就可以吃。于是可以假装吃掉了打工蛇，把问题丢给下一个后浪，递归求解。递归边界是某条后浪吃掉打工蛇后自己没有变成打工蛇。 当然其实不需要递推，开个set模拟就行。注意到模拟上述过程时间不太够，考虑用某年noip蚯蚓那个题的经典方法优化。具体来说，开两个deque，由上面的分析可知产生的新蛇一定更小，于是把初始蛇丢尽第一个队列，新产生的蛇丢进第二个队列，假装它是个set就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cerr;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> val, id;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Node n) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> val &lt; n.<span class="built_in">val</span>  (val == n.val &amp;&amp; id &lt; n.id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(Node n) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> val == n.val &amp;&amp; id == n.id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans, n, A[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> kase)</span> </span>&#123;</span><br><span class="line">  ans = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">if</span> (kase == <span class="number">1</span>) &#123;</span><br><span class="line">    n = ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      A[i] = <span class="built_in">rd</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ans; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">      A[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ans = n;</span><br><span class="line">  std::deque&lt;Node&gt; que1, que2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ans; ++i)</span><br><span class="line">    que1.<span class="built_in">push_front</span>(&#123;A[i], i&#125;);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (que1.<span class="built_in">size</span>() + que2.<span class="built_in">size</span>() &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (que1.<span class="built_in">size</span>() + que2.<span class="built_in">size</span>() == <span class="number">2</span>)</span><br><span class="line">        --ans;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node min, max;</span><br><span class="line">    min = que1.<span class="built_in">back</span>();</span><br><span class="line">    que1.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">if</span> (que2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      max = que1.<span class="built_in">front</span>();</span><br><span class="line">      que1.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (que1.<span class="built_in">size</span>() == <span class="number">1</span>  que1.<span class="built_in">front</span>() &lt; que2.<span class="built_in">front</span>()) &#123;</span><br><span class="line">        max = que2.<span class="built_in">front</span>();</span><br><span class="line">        que2.<span class="built_in">pop_front</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        max = que1.<span class="built_in">front</span>();</span><br><span class="line">        que1.<span class="built_in">pop_front</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    max.val -= min.val;</span><br><span class="line">    <span class="keyword">if</span> (!que1.<span class="built_in">empty</span>() &amp;&amp; que1.<span class="built_in">back</span>() &lt; max) &#123;</span><br><span class="line">      que2.<span class="built_in">push_back</span>(max);</span><br><span class="line">      --ans;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> del = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (que1.<span class="built_in">size</span>() + que2.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      min = max;</span><br><span class="line">      <span class="keyword">if</span> (que2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        max = que1.<span class="built_in">front</span>();</span><br><span class="line">        que1.<span class="built_in">pop_front</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (que1.<span class="built_in">size</span>() == <span class="number">1</span>  que1.<span class="built_in">front</span>() &lt; que2.<span class="built_in">front</span>()) &#123;</span><br><span class="line">          max = que2.<span class="built_in">front</span>();</span><br><span class="line">          que2.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          max = que1.<span class="built_in">front</span>();</span><br><span class="line">          que1.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      max.val -= min.val;</span><br><span class="line">      <span class="keyword">if</span> (!que1.<span class="built_in">empty</span>() &amp;&amp; que1.<span class="built_in">back</span>() &lt; max)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> (!que2.<span class="built_in">empty</span>() &amp;&amp; que2.<span class="built_in">back</span>() &lt; max)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      del ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans -= del;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; ++i)</span><br><span class="line">    <span class="built_in">solve</span>(i);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>CTSC2010性能优化 DFT循环卷积</title>
    <url>/2020/04/03/ctsc2010%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-dft%E5%BE%AA%E7%8E%AF%E5%8D%B7%E7%A7%AF/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4191">[CTSC2010]性能优化</a> 首先题目要求的是$AB^C$，乘法为循环卷积。众所周知DFT有循环卷积的性质，只需要快速求出DFT就行了。 题目里提到了$n+1$为质数，且$n$的质因子$\in \lbrace 2,3,5,7 \rbrace$。那么求出$n+1$的一个原根，考虑NTT。 在常用的NTT中，是这样做的： $$F(\omega_n^i)=F_0(\omega_{n/2}^i)+\omega_{n}^iF_1(w_{n/2}^i)$$ 实际上就是把$n$的一个因子提出来的操作 $$F(\omega_n^i)=\sum_{j &lt; p} \omega_{n}^{ij} F_j(\omega_{n/p}^i) $$ 这样子，只需要把$n$分解，就可以实现DFT了。 考虑去掉递归，写成递推。在一般DFT中有蝶形变换，在这里也可以类似的计算数组的新位置。实际上实现很简单，直接枚举$p$，维护当前块大小，考虑每一块，在块内把元素按${\rm mod}\ p$分一下就可以 那么考虑DFT。对于一个元素，会存在一组模块大小相同的数对它贡献。精细计算贡献即可 （洛谷题解里第一篇代码太妙了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, C, A[N], B[N], P, Gp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = <span class="number">1ll</span> * x * x % P)</span><br><span class="line">    <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = <span class="number">1ll</span> * ret * x % P;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_root</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="keyword">int</span>&gt; fac;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x - <span class="number">1</span>; ++i)</span><br><span class="line">    <span class="keyword">if</span> (!((x - <span class="number">1</span>) % i)) &#123;</span><br><span class="line">      fac.<span class="built_in">push_back</span>(i);</span><br><span class="line">      <span class="keyword">if</span> (i * i != x - <span class="number">1</span>)</span><br><span class="line">        fac.<span class="built_in">push_back</span>((x - <span class="number">1</span>) / i);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; ; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> ok = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j : fac)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">fpow</span>(i, j) == <span class="number">1</span>) &#123;</span><br><span class="line">        ok = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span> (ok) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_prime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(x % i))</span><br><span class="line">      <span class="keyword">while</span> (!(x % i))</span><br><span class="line">        x /= i, prime[++tot] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">1</span>) prime[++tot] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> f[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> tmp[N];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> b = tot, block = n; b; --b) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; n; i += block)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prime[b]; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; block; k += prime[b])</span><br><span class="line">          tmp[t++] = f[i + j + k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      f[i] = tmp[i];</span><br><span class="line">    block /= prime[b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DFT</span><span class="params">(<span class="keyword">int</span> f[], <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">reverse</span>(f);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> tmp[N];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, block = <span class="number">1</span>; i &lt;= tot; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> last = block;</span><br><span class="line">    block *= prime[i];</span><br><span class="line">    <span class="keyword">int</span> T = <span class="built_in">fpow</span>(Gp, n / block);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += block) &#123;</span><br><span class="line">      <span class="keyword">int</span> wn = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; block; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = k % last, w = <span class="number">1</span>; l &lt; block; l += last, w = <span class="number">1ll</span> * w * wn % P)</span><br><span class="line">          tmp[j + k] = (tmp[j + k] + <span class="number">1ll</span> * w * f[j + l]) % P;</span><br><span class="line">        wn = <span class="number">1ll</span> * wn * T % P;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">      f[j] = tmp[j], tmp[j] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (o == <span class="number">-1</span>) &#123;</span><br><span class="line">    std::<span class="built_in">reverse</span>(f + <span class="number">1</span>, f + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      f[i] = <span class="number">1ll</span> * f[i] * n % P;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = io.<span class="built_in">rd</span>(), C = io.<span class="built_in">rd</span>(), P = n + <span class="number">1</span>;</span><br><span class="line">  Gp = <span class="built_in">get_root</span>(P); <span class="built_in">get_prime</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) A[i] = io.<span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) B[i] = io.<span class="built_in">rd</span>();</span><br><span class="line">  <span class="built_in">DFT</span>(A, <span class="number">1</span>), <span class="built_in">DFT</span>(B, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    A[i] = <span class="number">1ll</span> * A[i] * <span class="built_in">fpow</span>(B[i], C) % P;</span><br><span class="line">  <span class="built_in">DFT</span>(A, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    io.<span class="built_in">out</span>(A[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>CTSC2012 熟悉的文章</title>
    <url>/2019/07/23/ctsc2012-%E7%86%9F%E6%82%89%E7%9A%84%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4022">[CTSC2012]熟悉的文章</a> 二分一个答案然后判定。 $$f[i]=max(f[j]+i-j)=i+max(f[j]-j),j \in [i-match[i],i-L]$$ SAM求$match$，DP单调队列优化一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1100000</span> + <span class="number">2333</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N * <span class="number">2</span>], ch[N * <span class="number">2</span>][<span class="number">2</span>], len[N * <span class="number">2</span>], tot = <span class="number">1</span>, last = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> np = ++tot, p = last;</span><br><span class="line">    last = np, len[np] = len[p] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; !ch[p][c])</span><br><span class="line">        ch[p][c] = np, p = fa[p];</span><br><span class="line">    <span class="keyword">if</span> (!p) fa[np] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> q = ch[p][c];</span><br><span class="line">        <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)</span><br><span class="line">            fa[np] = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> nq = ++tot;</span><br><span class="line">            ch[nq][<span class="number">0</span>] = ch[q][<span class="number">0</span>];</span><br><span class="line">            ch[nq][<span class="number">1</span>] = ch[q][<span class="number">1</span>];</span><br><span class="line">            len[nq] = len[p] + <span class="number">1</span>;</span><br><span class="line">            fa[nq] = fa[q];</span><br><span class="line">            fa[q] = fa[np] = nq;</span><br><span class="line">            <span class="keyword">while</span> (p &amp;&amp; ch[p][c] == q)</span><br><span class="line">                ch[p][c] = nq, p = fa[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, size;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N], mat[N];</span><br><span class="line"><span class="keyword">int</span> que[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= L - <span class="number">1</span>; ++i) f[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L, l = <span class="number">1</span>, r = <span class="number">0</span>; i &lt;= size; ++i) &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; f[que[r]] - que[r] &lt;= f[i - L] - (i - L))</span><br><span class="line">            --r;</span><br><span class="line">        que[++r] = i - L;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; que[l] &lt; mat[i])</span><br><span class="line">            ++l;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= r)</span><br><span class="line">            f[i] = std::<span class="built_in">max</span>(f[i], i + f[que[l]] - que[l]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[size] * <span class="number">10</span> &gt;= size * <span class="number">9</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line">        size = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; ++i)</span><br><span class="line">            <span class="built_in">insert</span>(str[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        last = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line">        size = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, p = <span class="number">1</span>, now = <span class="number">0</span>; i &lt;= size; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span> (p &amp;&amp; !ch[p][c])</span><br><span class="line">                p = fa[p], now = len[p];</span><br><span class="line">            <span class="keyword">if</span> (!p) p = <span class="number">1</span>, now = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> p = ch[p][c], ++now;</span><br><span class="line">            mat[i] = i - now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = size, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">                l = mid + <span class="number">1</span>, ans = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>DISUBSTR - Distinct Substrings</title>
    <url>/2019/06/12/disubstr-distinct-substrings/</url>
    <content><![CDATA[<p>求本质不同的子串个数。 <a href="https://www.luogu.org/problemnew/show/SP694">DISUBSTR - Distinct Substrings</a> 一共有n(n+1)/2个子串，每个height都对应了一些重复子串，减去height的和即可。详情见这里-&gt;<a href="https://baka.online/sdoi2016%E7%94%9F%E6%88%90%E9%AD%94%E5%92%92/">[SDOI2016]生成魔咒</a>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span> + <span class="number">10</span>, S = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> fir[N], sec[N], buc[N], sa[N], rk[N], ht[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; (s + <span class="number">1</span>); n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(fir, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(fir));</span><br><span class="line">    <span class="built_in">memset</span>(sec, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(sec));</span><br><span class="line">    <span class="built_in">memset</span>(buc, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(buc));</span><br><span class="line">    <span class="built_in">memset</span>(sa, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(sa));</span><br><span class="line">    <span class="built_in">memset</span>(rk, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(rk));</span><br><span class="line">    <span class="built_in">memset</span>(ht, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ht));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++buc[fir[i] = s[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; ++i) buc[i] += buc[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[buc[fir[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, p = <span class="number">0</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>, p = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; ++i) sec[++p] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt; k) sec[++p] = sa[i] - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) buc[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++buc[fir[sec[i]]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) buc[i] += buc[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[buc[fir[sec[i]]]--] = sec[i];</span><br><span class="line">        <span class="built_in">swap</span>(fir, sec); p = fir[sa[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            fir[sa[i]] = sec[sa[i]] == sec[sa[i - <span class="number">1</span>]] &amp;&amp;</span><br><span class="line">                sec[sa[i] + k] == sec[sa[i - <span class="number">1</span>] + k]</span><br><span class="line">                ? p : ++p;</span><br><span class="line">        <span class="keyword">if</span> (p == n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, p = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; <span class="number">0</span>) --p;</span><br><span class="line">        j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (s[i + p] == s[j + p]) ++p;</span><br><span class="line">        ht[rk[i]] = p; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = (n + <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans -= ht[i];</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>exBSGS 学习笔记</title>
    <url>/2019/07/27/exbsgs-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="BSGS-解方程"><a href="#BSGS-解方程" class="headerlink" title="BSGS:解方程"></a>BSGS:解方程</h3><p>$$a^x \equiv b \pmod p$$</p>
<h3 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h3><p>之前学过BSGS，重述一下： 由欧拉定理推论，$p \in prime$，$x$循环节$\leq \varphi(p) \leq p$ 令$m = \lceil \sqrt p \rceil $ $$a^{km-v} \equiv b \pmod p$$ $$a^{km} \equiv ba^v \pmod p$$ 先求$a^v$，再枚举$k$。</p>
<h3 id="exBSGS"><a href="#exBSGS" class="headerlink" title="exBSGS"></a>exBSGS</h3><p>如果$p$不是质数呢 不加证明的给出做法： 令$g=(a,p)$ 如果$g \nmid b$，无解。 $$\frac{a}{g} \equiv \frac{b}{g} \pmod {\frac{p}{g&#125;&#125;$$ $$\frac{a}{g} a^{x-1} \equiv \frac{b}{g} \pmod {\frac{p}{g&#125;&#125;$$ 记录$\frac{a}{g}$，递归求解，直到$(a,p)=1$。 式子变成了这样： $$ta^{x-k} \equiv b’ \pmod {p’}$$ 解一下。 注意有个<strong>特殊情况</strong>：如果某一步$t=b$，直接返回$k$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % p)</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = (LL)ret * x % p;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//std::unordered_map&lt;int, int&gt; map;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">100069</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hash</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> head[P + <span class="number">10</span>], nxt[P + <span class="number">10</span>], val[P + <span class="number">10</span>], to[P * <span class="number">10</span>], tot;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y = x % P, find = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[y]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val[i] == x) &#123;</span><br><span class="line">                to[i] = w;</span><br><span class="line">                find = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!find) &#123;</span><br><span class="line">            nxt[++tot] = head[y];</span><br><span class="line">            val[tot] = x;</span><br><span class="line">            to[tot] = w;</span><br><span class="line">            head[y] = tot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x % P]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val[i] == x) <span class="keyword">return</span> to[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; map;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsgs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p, <span class="keyword">int</span> baka)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p));</span><br><span class="line">    map.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, w = b % p; i &lt; m; ++i, w = (<span class="keyword">long</span> <span class="keyword">long</span>)w * a % p)</span><br><span class="line">        map.<span class="built_in">add</span>(w, i);</span><br><span class="line">    <span class="keyword">int</span> t = <span class="built_in">fpow</span>(a, m, p), x = baka;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        x = (LL)x * t % p;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">find</span>(x))</span><br><span class="line">            <span class="keyword">return</span> ((i * m - map.<span class="built_in">find</span>(x)) % p + p) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exbsgs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a % p == b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a % p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> d, cnt = <span class="number">0</span>, t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((d = <span class="built_in">gcd</span>(a, p)) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ++cnt; b /= d, p /= d;</span><br><span class="line">        t = (<span class="keyword">long</span> <span class="keyword">long</span>)t * (a / d) % p;</span><br><span class="line">        <span class="keyword">if</span> (b == t) <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">bsgs</span>(a, b, p, t);</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in"><span class="keyword">return</span></span> ((ans + cnt) % p + p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, p;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;p, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (!a &amp;&amp; !b &amp;&amp; !p)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">exbsgs</span>(a, b, p);</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">&quot;No Solution&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>exLucas 学习笔记</title>
    <url>/2020/05/28/exlucas-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>大质数取模有很多奇妙的姿势，其中比较菜的一个就是裸exLucas（然而我还是不会）。 exLucas适用于模数分解后不大的情况。 大概姿势是这样的：模数$P$分解为$p_1^{a_1} p_2^{a_2}…$，分别求解后用CRT合并。 那么求解$\binom{n+m}{n}$，只需要求解形如$n! \mod p^{a}$的式子。 令$n!=p^kc$，那么$k$很好求，只需要考虑$c$。注意到$1,2,3,…,p^a$在模意义下与$p^a+1,p^a+2,…,p^{2a}$完全一致，只需要预处理$p^a$之内，不是$p$倍数的积。递归即可。 例题：bzoj #3738. [Ontak2013]Kapitał 考虑分解成$2^a5^bc$，之后直接把上下的$10$消掉，套个exLucas上去就好了。代码参考（照抄）了Claris的实现，十分精妙。具体细节见代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cerr;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> P = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, a;</span><br><span class="line">  <span class="keyword">int</span> g = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">  <span class="keyword">return</span> y -= a / b * x, g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_inv</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x, y;</span><br><span class="line">  <span class="built_in">exgcd</span>(val, mod, x, y);</span><br><span class="line">  x = (x % mod + mod) % mod;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = x * x % mod)</span><br><span class="line">    <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = ret * x % mod;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MOD;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a * 2 ^ b</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="built_in">Node</span>() &#123; a = <span class="number">1</span>, b = <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="built_in">Node</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">    a = x, b = y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">friend</span> Node <span class="keyword">operator</span>*(Node x, Node y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Node</span>(x.a * y.a % MOD, x.b + y.b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">friend</span> Node <span class="keyword">operator</span>/(Node x, Node y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Node</span>(x.a * <span class="built_in">get_inv</span>(y.a, MOD) % MOD, x.b - y.b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; now[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, K, pw[<span class="number">1953125</span> + <span class="number">1</span>], del, res[<span class="number">2</span>], ans, B;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">calc</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!val) <span class="keyword">return</span> <span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Node</span>(pw[val % MOD] * <span class="built_in">fpow</span>(pw[MOD], val / MOD, MOD), val / B) * <span class="built_in">calc</span>(val / B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; K;</span><br><span class="line">  MOD = <span class="number">512</span>, B = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = pw[<span class="number">0</span>] = <span class="number">1</span>; i &lt;= MOD; ++i)</span><br><span class="line">    pw[i] = pw[i - <span class="number">1</span>] * (i % <span class="number">2</span> ? i : <span class="number">1</span>) % MOD;</span><br><span class="line">  pw[MOD] = pw[MOD - <span class="number">1</span>];</span><br><span class="line">  now[<span class="number">0</span>] = <span class="built_in">calc</span>(n + m) / <span class="built_in">calc</span>(n) / <span class="built_in">calc</span>(m);</span><br><span class="line">  MOD = <span class="number">1953125</span>, B = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = pw[<span class="number">0</span>] = <span class="number">1</span>; i &lt;= MOD; ++i)</span><br><span class="line">    pw[i] = pw[i - <span class="number">1</span>] * (i % <span class="number">5</span> ? i : <span class="number">1</span>) % MOD;</span><br><span class="line">  pw[MOD] = pw[MOD - <span class="number">1</span>];</span><br><span class="line">  now[<span class="number">1</span>] = <span class="built_in">calc</span>(n + m) / <span class="built_in">calc</span>(n) / <span class="built_in">calc</span>(m);</span><br><span class="line">  del = std::<span class="built_in">min</span>(now[<span class="number">0</span>].b, now[<span class="number">1</span>].b);</span><br><span class="line">  <span class="keyword">while</span> (del--) &#123;</span><br><span class="line">    MOD = <span class="number">512</span>, now[<span class="number">0</span>] = now[<span class="number">0</span>] / <span class="built_in">Node</span>(<span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">    MOD = <span class="number">1953125</span>, now[<span class="number">1</span>] = now[<span class="number">1</span>] / <span class="built_in">Node</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  MOD = <span class="number">512</span>, res[<span class="number">0</span>] = now[<span class="number">0</span>].a * <span class="built_in">fpow</span>(<span class="number">2</span>, now[<span class="number">0</span>].b, MOD) % MOD;</span><br><span class="line">  MOD = <span class="number">1953125</span>, res[<span class="number">1</span>] = now[<span class="number">1</span>].a * <span class="built_in">fpow</span>(<span class="number">5</span>, now[<span class="number">1</span>].b, MOD) % MOD;</span><br><span class="line">  ans = (<span class="number">1953125</span> * <span class="built_in">get_inv</span>(<span class="number">1953125</span>, <span class="number">512</span>) % P * res[<span class="number">0</span>] % P + <span class="number">512</span> * <span class="built_in">get_inv</span>(<span class="number">512</span>, <span class="number">1953125</span>) % P * res[<span class="number">1</span>] % P) % P;</span><br><span class="line">  <span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++i) T = T * <span class="number">10</span>;</span><br><span class="line">  ans %= T;</span><br><span class="line">  std::cout &lt;&lt; std::<span class="built_in">setw</span>(K) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>GXOI/GZOI2019与或和</title>
    <url>/2019/05/26/gxoi-gzoi2019%E4%B8%8E%E6%88%96%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P5300">[GXOI/GZOI2019]与或和</a> 直接做完全不可做嘛…因为是位运算，枚举二进制每一位，变成01矩阵做就好做了一些。 and操作：求全1矩阵个数。or操作：求总矩阵-全0矩阵个数。 首先解决一个问题：x*y的矩形内，包含右下角这个点的子矩形有多少个。答案是x*y个。原因很简单，我们枚举子矩形的左上角，发现每个点都能充当正好一次。 统计矩形个数的题，常常用单调栈。预处理每个点可以向上扩展的高度。一行一行的扫，以某个点为右下角的矩阵个数=左边到现在最低的高度乘左边到现在的距离。原因很简单，最低的高度会卡住后面的所有矩形。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, matrix[N][N][<span class="number">31</span>], up[N][N];</span><br><span class="line"><span class="keyword">int</span> st[N], top;</span><br><span class="line">LL ans1, ans2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve_and</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j][k] == <span class="number">1</span>)</span><br><span class="line">                up[i][j] = up[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> up[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        LL sum = <span class="number">0</span>; top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            sum += up[i][j];</span><br><span class="line">            <span class="keyword">while</span> (top &amp;&amp; up[i][st[top]] &gt;= up[i][j]) &#123;</span><br><span class="line">                sum -= (st[top] - st[top - <span class="number">1</span>]) * (up[i][st[top]] - up[i][j]);</span><br><span class="line">                --top;</span><br><span class="line">            &#125;</span><br><span class="line">            ans1 = (ans1 + (sum &lt;&lt; k)) % MOD;</span><br><span class="line">            st[++top] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve_or</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j][k] == <span class="number">0</span>)</span><br><span class="line">                up[i][j] = up[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> up[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        LL sum = <span class="number">0</span>; top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            sum += up[i][j];</span><br><span class="line">            <span class="keyword">while</span> (top &amp;&amp; up[i][st[top]] &gt;= up[i][j]) &#123;</span><br><span class="line">                sum -= (st[top] - st[top - <span class="number">1</span>]) * (up[i][st[top]] - up[i][j]);</span><br><span class="line">                --top;</span><br><span class="line">            &#125;</span><br><span class="line">            ans2 = (ans2 + ((i * j - sum) &lt;&lt; k)) % MOD;</span><br><span class="line">            st[++top] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="built_in">rd</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">30</span>; ++k)</span><br><span class="line">                matrix[i][j][k] = (num &amp; (<span class="number">1</span> &lt;&lt; k)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">solve_and</span>(i);</span><br><span class="line">        <span class="built_in">solve_or</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>HAOI2010最长公共子序列</title>
    <url>/2019/03/02/haoi2010%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2423">[HAOI2010]最长公共子序列</a> 把两串存在$x[]$，$y[]$中。定义$f[][]$表示最长公共子序列，$g[][]$表示方案数。 $f[][]$转移显然： $f[i][j] = f[i - 1][j - 1] + 1$ 如果 $x[i] == y[j]$ $(1)$ $f[i][j] = max(f[i - 1][j], f[i][j - 1])$ 其它情况 $(2)$ 考虑$g[][]$的转移。 $(1)$式进行时，$g[i][j] += g[i - 1][j - 1]$。 $(2)$式进行时，$g[i][j] += g[i - 1][j] (f[i][j] == f[i - 1][j]) + g[i][j - 1] (f[i][j] == f[i][j - 1])$。 然而如果$g[i][j] == g[i - 1][j - 1]$，那么$g[i - 1][j - 1]$的方案数就会被重复计算两次（容斥），需要减掉。 dp需要滚动数组。初值：$f[][]$全为0，$g[i][0] = g[0][i] = 1$;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000</span> + <span class="number">233</span>, MOD = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">char</span> x[N], y[N];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][N], g[<span class="number">2</span>][N], lenx, leny;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; (x + <span class="number">1</span>) &gt;&gt; (y + <span class="number">1</span>);</span><br><span class="line">    lenx = <span class="built_in">strlen</span>(x + <span class="number">1</span>) - <span class="number">1</span>, leny = <span class="built_in">strlen</span>(y + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= leny; ++i)</span><br><span class="line">        g[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lenx; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= leny; ++j)</span><br><span class="line">            f[now][j] = g[now][j] = <span class="number">0</span>;</span><br><span class="line">        g[now][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= leny; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x[i] == y[j])</span><br><span class="line">                f[now][j] = f[!now][j - <span class="number">1</span>] + <span class="number">1</span>,</span><br><span class="line">                g[now][j] += g[!now][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> f[now][j] = <span class="built_in">max</span>(f[now][j - <span class="number">1</span>], f[!now][j]);</span><br><span class="line">            <span class="keyword">if</span> (f[now][j] == f[now][j - <span class="number">1</span>])</span><br><span class="line">                g[now][j] += g[now][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (f[now][j] == f[!now][j])</span><br><span class="line">                g[now][j] += g[!now][j];</span><br><span class="line">            <span class="keyword">if</span> (f[now][j] == f[!now][j - <span class="number">1</span>])</span><br><span class="line">                g[now][j] -= g[!now][j - <span class="number">1</span>];</span><br><span class="line">            g[now][j] %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[lenx &amp; <span class="number">1</span>][leny] &lt;&lt; endl &lt;&lt; g[lenx &amp; <span class="number">1</span>][leny] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>HAOI2010计数 康托展开</title>
    <url>/2019/08/08/haoi2010%E8%AE%A1%E6%95%B0-%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P2518">[HAOI2010]计数</a> 前面的方案可以看做不同的排列。就是求康托展开。 对于有重复元素的康托展开，首先同样的方法，一位一位算。在计算某一位的方案数时，有这样的方法： 康托展开的求法很简单: $$f_i = \sum_{j=i}^n [A_j &gt; A_i]$$ $$\sum_{i=1}^n (n-i)! f_i + 1$$ 然而这个题有重复的值 $$\sum_{i=1}^n \frac{(n-i)!}{\prod_j cnt_j!} f_i + 1$$ 就是一个简单的多重集排列 然而显然上面的阶乘会爆long long.我们考虑另一种计算的方法 $$\frac{n!}{\prod_i cnt_i!} = \prod_i \binom{n-\sum_{j &lt; i} cnt_j}{ cnt_i }$$ 显然这个不会爆</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">10</span>], num[<span class="number">55</span>], len;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> C[<span class="number">55</span>][<span class="number">55</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        ret *= C[L][cnt[i]], L -= cnt[i];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="built_in">getchar</span>(); <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>())</span><br><span class="line">        ++cnt[num[++len] = c - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            C[i][j] = C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; --cnt[num[i]], ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num[i]; ++j)</span><br><span class="line">            <span class="keyword">if</span> (cnt[j]) &#123;</span><br><span class="line">                --cnt[j];</span><br><span class="line">                ans += <span class="built_in">calc</span>(len - i);</span><br><span class="line">                ++cnt[j];</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>HAOI2010软件安装</title>
    <url>/2019/03/13/haoi2010%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2427">[HAOI2010]软件安装</a> 道理我都懂，就是写不出来呜呜呜 首先这题依赖关系没说是树，于是可能有环。一个环要不不选要不全选，强联通搞起来。 然后是裸树形背包了然而不会写看了半天博客，又改了好久。这里记一下树形背包怎么写好了。 定义$f[i][j][k]$，表示第$i$个点考虑过前$j$个子树，背包大小为$k$。然后dfs处理。初值是$f[i][0][k]=v[i],w[i]\le k \le m$。转移方程是$f[i][j][k]=max(f[i][j][k],f[i][j-1][t]+f[ii][all][k-t])$，其中$ii$是$i$的子节点，$all$是子节点大小。 然后发现，$j$由$j-1$转移来，可以省略这一维，倒序循环$k$这一维就可以了。 其实就是个树上的分组背包…看来需要恶补DP了…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> w, v;</span><br><span class="line">    &#125; node[N];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> from[N], to[N], nxt[N], head[N], tot;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            to[++tot] = y, from[tot] = x,</span><br><span class="line">            nxt[tot] = head[x], head[x] = tot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; g1, g2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dfn[N], low[N], num, stack[N], top, c[N], cnt;</span><br><span class="line">    <span class="keyword">bool</span> ins[N];</span><br><span class="line">    Node nd[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        dfn[x] = low[x] = ++num;</span><br><span class="line">        ins[stack[++top] = x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = g1.head[x]; i; i = g1.nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = g1.to[i];</span><br><span class="line">            <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(y);</span><br><span class="line">                low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ins[y])</span><br><span class="line">                low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (low[x] == dfn[x]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y; ++cnt;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                ins[y = stack[top--]] = <span class="literal">false</span>;</span><br><span class="line">                c[y] = cnt;</span><br><span class="line">                nd[cnt].w += node[y].w;</span><br><span class="line">                nd[cnt].v += node[y].v;</span><br><span class="line">            &#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> adddd[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">200</span>][<span class="number">1000</span>], in[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nd[x].w; i &lt;= m; ++i) f[x][i] = nd[x].v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = g2.head[x]; i; i = g2.nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = g2.to[i];</span><br><span class="line">            <span class="keyword">if</span> (y != fa) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(y, x);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = m - nd[x].w; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j; ++k)</span><br><span class="line">                        f[x][j + nd[x].w] = <span class="built_in">max</span>(f[x][j + nd[x].w], f[x][j + nd[x].w - k] + f[y][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) node[i].w = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) node[i].v = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = <span class="built_in">rd</span>();</span><br><span class="line">            <span class="keyword">if</span> (y != <span class="number">0</span>) g1.<span class="built_in">addedge</span>(y, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = c[g1.from[i]], y = c[g1.to[i]];</span><br><span class="line">            <span class="keyword">if</span> (x != y &amp;&amp; !adddd[x][y]) &#123;</span><br><span class="line">                adddd[x][y] = <span class="literal">true</span>;</span><br><span class="line">                g2.<span class="built_in">addedge</span>(x, y);</span><br><span class="line">                ++in[y];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) <span class="keyword">if</span> (in[i] == <span class="number">0</span>) g2.<span class="built_in">addedge</span>(<span class="number">0</span>, i);</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        cout &lt;&lt; f[<span class="number">0</span>][m] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>HAOI2011Problem b</title>
    <url>/2019/04/26/haoi2011problem-b/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2522">[HAOI2011]Problem b</a> 懵逼钨丝反演第一题。这么久才去填<a href="https://baka.online/luogu-p2568-gcd/">之前挖的坑</a>，凉了凉了。 题意：求 $$\sum_{i=a}^b\sum_{j=c}^d[gcd(i,j)=k]$$ 考虑一个简化的问题（其实就是这道题：<a href="https://www.luogu.org/problemnew/show/P3455">[POI2007]ZAP-Queries</a>），求： $$\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=k]$$ 我们令$f(x)=\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=x]$，而$F(x)=\sum_{i=1}^n\sum_{j=1}^m[x \mid gcd(i,j)]$。 $$F(x)=\sum_{i=1}^n\sum_{j=1}^m[x \mid gcd(i,j)]\newline =\sum_{x \mid d}f(d)=\lfloor \frac{n}{x} \rfloor \lfloor \frac{m}{x} \rfloor$$ $$f(x)=\sum_{x \mid d} \mu(\frac{d}{x})F(d)$$ $$ans=f(k)=\sum_{k \mid d} \mu(\frac{d}{k})F(d)$$ 令$T=\frac{d}{k}$，则有： $$ans=\sum_{T=1}^{min(n,m)} \mu(T) \lfloor \frac{n}{Tk} \rfloor \lfloor \frac{m}{Tk} \rfloor$$ 可以$O(n)$做了，因为多组数据，我们发现$\lfloor \frac{n}{Tk} \rfloor$这样的式子在一段区间内值不变，整除分块一下，$O(\sqrt n)$。 上面推导的是一般式，为了卡常，我们可以把原问题变形一下 $$\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=k] \newline =\sum_{i=1}^{\lfloor \frac{n}{k} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{k} \rfloor}[gcd(i,j)=1]$$ 那么答案式就变成了 $$ans=\sum_{T=1}^{min(\lfloor \frac{n}{k} \rfloor,\lfloor \frac{m}{k} \rfloor)} \mu(T) \lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor$$ 常数更小，玩的更爽 终于可以回到本题了，本题下界从$1$变成了$a,c$，其实容斥一下就好了。$ans=solve(b,d)-solve(a-1,d)-solve(c-1,b)+solve(a-1,c-1)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50000</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> mu[N], prime[N], cnt, flag[N], sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) &#123;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; ++j) &#123;</span><br><span class="line">            flag[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    n /= k, m /= k;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) <span class="built_in">swap</span>(n, m);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = <span class="built_in">min</span>(n / (n / l), m / (m / l));</span><br><span class="line">        ans += (<span class="keyword">long</span> <span class="keyword">long</span>)(sum[r] - sum[l - <span class="number">1</span>]) * (n / l) * (m / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">rd</span>(); i; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">rd</span>(), b = <span class="built_in">rd</span>(), c = <span class="built_in">rd</span>(), d = <span class="built_in">rd</span>(), k = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="built_in">solve</span>(b, d, k) - <span class="built_in">solve</span>(a - <span class="number">1</span>, d, k)</span><br><span class="line">            - <span class="built_in">solve</span>(b, c - <span class="number">1</span>, k) + <span class="built_in">solve</span>(a - <span class="number">1</span>, c - <span class="number">1</span>, k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>BJOI2015树的同构</title>
    <url>/2019/04/19/bjoi2015%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4337">[BJOI2015]树的同构</a> 解法1：树上hash题。以树的每个点为根，分别求个hash值，因为访问子树顺序影响结果，要对子树的hash排序。然后对比两棵树每个点为根的hash是否都相等就行了。 解法2：（dalao博客学来的）对树找出代表点，即重心。重心最多有两个，以这两个点分别为根求hash就行了，不需要完整的求每个点。 解法3：（使用所有点或者重心都行）hash虽然一般很稳，但是能被卡掉，考虑用括号序列表示一棵树。进去的时候放个(，把所有子树的括号序列排序插后面，出去放)。 这是解法1的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">150</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125; g[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    g[++tot].to = y, g[tot].nxt = head[x],</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * (tot + <span class="number">1</span>));</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, s[N];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ha[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> h = <span class="number">0</span>, tr[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="keyword">if</span> (y != fa)</span><br><span class="line">            tr[++top] = <span class="built_in">dfs</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(tr + <span class="number">1</span>, tr + top + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= top; ++i)</span><br><span class="line">        h = h * <span class="number">131</span> + tr[i];</span><br><span class="line">    <span class="keyword">return</span> h * <span class="number">131</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= m; ++t) &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">rd</span>(); s[t] = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">rd</span>();</span><br><span class="line">            <span class="keyword">if</span> (x) &#123;</span><br><span class="line">                <span class="built_in">addedge</span>(x, i);</span><br><span class="line">                <span class="built_in">addedge</span>(i, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            ha[t][i] = <span class="built_in">dfs</span>(i, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">sort</span>(ha[t] + <span class="number">1</span>, ha[t] + n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[t]) &#123;</span><br><span class="line">                <span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                    <span class="keyword">if</span> (ha[i][j] != ha[t][j]) &#123;</span><br><span class="line">                        ok = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> kai586123::<span class="built_in">main</span>(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>HAOI2016字符合并</title>
    <url>/2019/05/08/haoi2016%E5%AD%97%E7%AC%A6%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3736">[HAOI2016]字符合并</a> 区间DP+状压DP。我们用f[i][j][k]表示区间[i,j]合并成k的答案。区间DP的时候枚举mid，让mid的一边合成一个字符，剩下的部分合成剩下的字符。如果区间长度可以直接合并，就直接合并一下。 本题思想简单，代码不怎么好写…抄的网上的…果然我太菜OAO</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lovelive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>, K = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, def[N], c[N], w[N];</span><br><span class="line">lovelive f[N][N][(<span class="number">1</span> &lt;&lt; K) + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; def[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; k; ++i)</span><br><span class="line">        cin &gt;&gt; c[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        f[i][i][def[i]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; ++len) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = len; r &lt;= n; ++l, ++r) &#123;</span><br><span class="line">            <span class="keyword">int</span> lenlen = (len - <span class="number">1</span>) % (k - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!lenlen) lenlen = k - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> mid = r; mid &gt; l; mid -= k - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">1</span> &lt;&lt; lenlen; ++s) &#123;</span><br><span class="line">                    f[l][r][s &lt;&lt; <span class="number">1</span>] = <span class="built_in">max</span>(f[l][r][s &lt;&lt; <span class="number">1</span>], f[l][mid - <span class="number">1</span>][s] + f[mid][r][<span class="number">0</span>]);</span><br><span class="line">                    f[l][r][s &lt;&lt; <span class="number">1</span>  <span class="number">1</span>] = <span class="built_in">max</span>(f[l][r][s &lt;&lt; <span class="number">1</span>  <span class="number">1</span>], f[l][mid - <span class="number">1</span>][s] + f[mid][r][<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (lenlen == k - <span class="number">1</span>) &#123;</span><br><span class="line">                lovelive t[<span class="number">2</span>]; <span class="built_in">memset</span>(t, <span class="number">0xcf</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(t));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">1</span> &lt;&lt; k; ++s)</span><br><span class="line">                    t[c[s]] = <span class="built_in">max</span>(t[c[s]], f[l][r][s] + w[s]);</span><br><span class="line">                f[l][r][<span class="number">0</span>] = t[<span class="number">0</span>];</span><br><span class="line">                f[l][r][<span class="number">1</span>] = t[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lovelive ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; k; ++i)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[<span class="number">1</span>][n][i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>HAOI2017八纵八横 线性基线段树分治</title>
    <url>/2019/08/07/haoi2017%E5%85%AB%E7%BA%B5%E5%85%AB%E6%A8%AA-%E7%BA%BF%E6%80%A7%E5%9F%BA%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P3733">[HAOI2017]八纵八横</a> 考虑没有修改的情况。可以发现，起点编号是个没用的条件，可以对答案产生贡献的是图中的环。 求出一棵DFS树，那么剩下的所有边，都会和DFS树上的一些边构成一个简单环。一个更复杂的环可以由简单环组合而成，把它们预处理出来，加入线性基即可。 线性基并不能撤销。本题的特点是每条边都有个存在时间，所以考虑线段树分治。维护$log_n$个线性基，对应每一层。这就变成了板子题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, P, max_bit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, nxt;</span><br><span class="line">    std::bitset&lt;N&gt; cost;</span><br><span class="line">&#125; g[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, std::bitset&lt;N&gt; cost)</span> </span>&#123;</span><br><span class="line">    g[++tot] = &#123; x, y, head[x], cost &#125;;</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Liner_Basis</span> &#123;</span></span><br><span class="line">    std::bitset&lt;N&gt; basis[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(std::bitset&lt;N&gt; bit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = max_bit; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bit[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!basis[i][i]) &#123;</span><br><span class="line">                basis[i] = bit;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bit ^= basis[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::bitset&lt;N&gt; bit;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = max_bit; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            <span class="keyword">if</span> (!bit[i]) bit ^= basis[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = max_bit, flag = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bit[i]) flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="built_in">putchar</span>(bit[i] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; B[<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visit[N], vis_edge[N];</span><br><span class="line">std::bitset&lt;N&gt; val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">graph_dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    visit[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!visit[y]) &#123;</span><br><span class="line">            val[y] = val[x] ^ g[i].cost;</span><br><span class="line">            vis_edge[i] = vis_edge[i ^ <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">graph_dfs</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NChange</span> &#123;</span></span><br><span class="line">    std::bitset&lt;N&gt; nedge;</span><br><span class="line">    <span class="keyword">int</span> x, y, add, del;</span><br><span class="line">&#125; nc[N];</span><br><span class="line"><span class="keyword">int</span> last[N];</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; change[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R) <span class="keyword">return</span> (<span class="keyword">void</span>)(change[p].<span class="built_in">push_back</span>(id));</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">insert</span>(p * <span class="number">2</span>, l, r, id, L, mid);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) <span class="built_in">insert</span>(p * <span class="number">2</span> + <span class="number">1</span>, l, r, id, mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_seg_tree</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> dep, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep) B[dep] = B[dep - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : change[p])</span><br><span class="line">        B[dep].<span class="built_in">insert</span>(val[nc[y].x] ^ val[nc[y].y] ^ nc[y].nedge);</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L != P + <span class="number">1</span>) B[dep].<span class="built_in">query</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">dfs_seg_tree</span>(p * <span class="number">2</span>, dep + <span class="number">1</span>, L, mid);</span><br><span class="line">    <span class="built_in">dfs_seg_tree</span>(p * <span class="number">2</span> + <span class="number">1</span>, dep + <span class="number">1</span>, mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; std::string str;</span><br><span class="line">        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; str;</span><br><span class="line">        max_bit = std::<span class="built_in">max</span>(max_bit, (<span class="keyword">int</span>)str.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">addedge</span>(x, y, std::bitset&lt;N&gt;(str));</span><br><span class="line">        <span class="built_in">addedge</span>(y, x, std::bitset&lt;N&gt;(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">graph_dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= tot; i += <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (!vis_edge[i])</span><br><span class="line">            B[<span class="number">0</span>].<span class="built_in">insert</span>(val[g[i].from] ^ val[g[i].to] ^ g[i].cost);</span><br><span class="line">    B[<span class="number">0</span>].<span class="built_in">query</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, add = <span class="number">0</span>; i &lt;= P; ++i) &#123;</span><br><span class="line">        std::string op; std::cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;Add&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y; std::string str;</span><br><span class="line">            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; str;</span><br><span class="line">            nc[i] = &#123; std::bitset&lt;N&gt;(str), x, y, i, <span class="number">0</span> &#125;;</span><br><span class="line">            last[++add] = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;Cancel&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> k; std::cin &gt;&gt; k;</span><br><span class="line">            nc[last[k]].del = i - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> k; std::string str;</span><br><span class="line">            std::cin &gt;&gt; k &gt;&gt; str;</span><br><span class="line">            max_bit = std::<span class="built_in">max</span>(max_bit, (<span class="keyword">int</span>)str.<span class="built_in">size</span>());</span><br><span class="line">            nc[i] = nc[last[k]];</span><br><span class="line">            nc[last[k]].del = i - <span class="number">1</span>;</span><br><span class="line">            last[k] = nc[i].add = i;</span><br><span class="line">            nc[i].nedge = std::bitset&lt;N&gt;(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= P; ++i)</span><br><span class="line">        <span class="keyword">if</span> (nc[i].add)</span><br><span class="line">            <span class="built_in">insert</span>(<span class="number">1</span>, nc[i].add, nc[i].del == <span class="number">0</span> ? P + <span class="number">1</span> : nc[i].del, i, <span class="number">1</span>, P + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs_seg_tree</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, P + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World!</title>
    <url>/2019/01/05/hello-world/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::cout&lt;&lt; &quot;Hello, World!!!&quot; &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>Baka’s Blog -&gt; 2018.8.25 - ?</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>HEOI2013ALO</title>
    <url>/2019/04/12/heoi2013alo/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4098">[HEOI2013]ALO</a> 正解可持久化Trie。于是抄洛谷题解打了个暴力，A了。。。不过bzoj被加强版数据搞WA。 就是假设每个位置是区间第二大，向左右暴力扩展这样。不细讲了，因为是错的：比如有数据7 5 3 2，第二小是5，5^2=7，但是按照暴力解法是6。当然暴力可以加上同时考虑两边的就能过了。贴一下洛谷AC代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c -<span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50233</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], cnt, ans, x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        x = cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[i]) ++cnt;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x = <span class="built_in">max</span>(x, a[i] ^ a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">1</span>) ans = <span class="built_in">max</span>(ans, x);</span><br><span class="line">        x = cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[i]) ++cnt;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x = <span class="built_in">max</span>(x, a[i] ^ a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正解：枚举每个值做次大值，然后如果能快速找出一个值和它xor之后最大就行了。考虑使用可持久化01Trie，把数字按位放进Trie里，可持久化一下，就可以给定一个区间，在树上对于每一位，尽可能去走和它相反的位，以快速找到最大值。 把所有值从大到小排序，然后按顺序考虑，把值出现位置插入set中。取出当前位置，因为set中已有的位置的数都比当前大，所以显然[前驱的前驱+1,后驱的后驱-1]是可以考虑与当前值xor的位置。在此区间内查询一下就可以了。 复杂度$O(nlogn)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c -<span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50000</span> + <span class="number">2333</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch[N * <span class="number">50</span>][<span class="number">2</span>], num, root[N * <span class="number">50</span>], sum[N * <span class="number">50</span>];</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, id;</span><br><span class="line">&#125; a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;n1, <span class="keyword">const</span> Node &amp;n2) &#123;</span><br><span class="line">    <span class="keyword">return</span> n1.val &gt; n2.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now, tmp = now = ++num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = (val &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        ch[now][<span class="number">0</span>] = ch[p][<span class="number">0</span>];</span><br><span class="line">        ch[now][<span class="number">1</span>] = ch[p][<span class="number">1</span>];</span><br><span class="line">        p = ch[p][t];</span><br><span class="line">        now = ch[now][t] = ++num;</span><br><span class="line">        sum[now] = sum[p] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = (val &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum[ch[r][t ^ <span class="number">1</span>]] - sum[ch[l][t ^ <span class="number">1</span>]]) &#123;</span><br><span class="line">            l = ch[l][t ^ <span class="number">1</span>];</span><br><span class="line">            r = ch[r][t ^ <span class="number">1</span>];</span><br><span class="line">            ans = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l = ch[l][t];</span><br><span class="line">            r = ch[r][t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">rd</span>(), ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i].val = <span class="built_in">rd</span>(); a[i].id = i;</span><br><span class="line">        root[i] = <span class="built_in">insert</span>(root[i - <span class="number">1</span>], a[i].val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    st.<span class="built_in">insert</span>(-INF); st.<span class="built_in">insert</span>(-INF - <span class="number">1</span>);</span><br><span class="line">    st.<span class="built_in">insert</span>(INF); st.<span class="built_in">insert</span>(INF + <span class="number">1</span>);</span><br><span class="line">    st.<span class="built_in">insert</span>(a[<span class="number">1</span>].id);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">max</span>(<span class="number">1</span>, *--(--st.<span class="built_in">lower_bound</span>(a[i].id)) + <span class="number">1</span>),</span><br><span class="line">            r = <span class="built_in">min</span>(n, *(++st.<span class="built_in">upper_bound</span>(a[i].id)) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= r) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(a[i].val, root[l - <span class="number">1</span>], root[r]));</span><br><span class="line">            st.<span class="built_in">insert</span>(a[i].id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> kai586123::<span class="built_in">main</span>(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>HEOI2016/TJOI2016 字符串</title>
    <url>/2019/07/31/heoi2016-tjoi2016-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P4094">[HEOI2016/TJOI2016] 字符串</a> 要求一个长度，不可做，改成二分这个长度$x$。 这题有一种SA+主席树的做法。在height数组上二分出和$[c,d]$的lcp是$x$的区间。然后查询$[a,b]$在区间内是否有分布。这个查询可以用主席树来做。 另一种做法是SAM+线段树合并+倍增。把原字符串反转，问题变成了后缀。用线段树维护哪些后缀出现过。在parent树上dfs，用线段树合并维护后缀。 在查询的时候，找出$[d-mid+1,d]$在SAM上的位置。用倍增实现这一过程。 今天才发现自己的线段树合并写的菜了。。。。。。应该每次新建一个节点，而不是合并到原树上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200000</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m; <span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ls[N * <span class="number">32</span>], rs[N * <span class="number">32</span>], num, root[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> x, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) p = ++num;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">add</span>(ls[p], x, L, mid);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">add</span>(rs[p], x, mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x  !y) <span class="keyword">return</span> x + y;</span><br><span class="line">    <span class="keyword">int</span> z = ++num;</span><br><span class="line">    ls[z] = <span class="built_in">merge</span>(ls[x], ls[y]);</span><br><span class="line">    rs[z] = <span class="built_in">merge</span>(rs[x], rs[y]);</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) ret = <span class="built_in">exist</span>(ls[p], l, r, L, mid);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) ret = <span class="built_in">exist</span>(rs[p], l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">21</span>], ch[N][<span class="number">26</span>], tot = <span class="number">1</span>, last = <span class="number">1</span>, len[N];</span><br><span class="line"><span class="keyword">int</span> which[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = last, np = ++tot;</span><br><span class="line">    len[last = np] = len[p] + <span class="number">1</span>;</span><br><span class="line">    which[w] = np;</span><br><span class="line">    <span class="built_in">add</span>(root[np], w, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; !ch[p][c])</span><br><span class="line">        ch[p][c] = np, p = fa[p][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (!p) fa[np][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> q = ch[p][c];</span><br><span class="line">        <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)</span><br><span class="line">            fa[np][<span class="number">0</span>] = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> nq = ++tot;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="built_in"><span class="keyword">sizeof</span></span>(ch[q]));</span><br><span class="line">            len[nq] = len[p] + <span class="number">1</span>;</span><br><span class="line">            fa[nq][<span class="number">0</span>] = fa[q][<span class="number">0</span>];</span><br><span class="line">            fa[q][<span class="number">0</span>] = fa[np][<span class="number">0</span>] = nq;</span><br><span class="line">            <span class="keyword">while</span> (p &amp;&amp; ch[p][c] == q)</span><br><span class="line">                ch[p][c] = nq, p = fa[p][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ord[N], buc[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line">    std::<span class="built_in">reverse</span>(str + <span class="number">1</span>, str + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">insert</span>(str[i] - <span class="string">&#x27;a&#x27;</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) ++buc[len[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) buc[i] += buc[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tot; i; --i) ord[buc[len[i]]--] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = ord[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; ++j)</span><br><span class="line">            fa[p][j] = fa[fa[p][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tot; i; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = ord[i];</span><br><span class="line">        root[fa[p][<span class="number">0</span>]] = <span class="built_in">merge</span>(root[fa[p][<span class="number">0</span>]], root[p]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (len[fa[p][i]] &gt;= x)</span><br><span class="line">            p = fa[p][i];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">exist</span>(root[p], l, r, <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = n - <span class="built_in">rd</span>() + <span class="number">1</span>, b = n - <span class="built_in">rd</span>() + <span class="number">1</span>,</span><br><span class="line">            c = n - <span class="built_in">rd</span>() + <span class="number">1</span>, d = n - <span class="built_in">rd</span>() + <span class="number">1</span>;</span><br><span class="line">        std::<span class="built_in">swap</span>(a, b); std::<span class="built_in">swap</span>(c, d);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = std::<span class="built_in">min</span>(b - a + <span class="number">1</span>, d - c + <span class="number">1</span>), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(which[d], mid, a + mid - <span class="number">1</span>, b))</span><br><span class="line">                l = mid + <span class="number">1</span>, ans = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">prework</span>();</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>HEOI2012采花</title>
    <url>/2019/02/16/heoi2012%E9%87%87%E8%8A%B1/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2743">[HEOI2012]采花</a> 有一道题叫做HH的项链，要维护区间颜色数，这题是那个题的加强版，要维护出现两次的颜色数。 把询问离线按照r排序，按顺序扫整个花田，维护pre数组表示颜色与当前位置相同的上一个位置。用树状数组在每个颜色倒数第二次出现的位置+1，其他位置全是0。 这样，即可确保两点：每个颜色只被统计一次，不会出现某颜色只出现一次被错算进答案里（如果放在最后出现位置+1就会出现，样例就是例子）。 这题排序两次就会TLE…丧心病狂…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">0</span>;<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))a=c==<span class="string">&#x27;-&#x27;</span>?<span class="number">0</span>:<span class="number">1</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))b=b*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a?b:-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e6</span>+<span class="number">2333</span>;</span><br><span class="line"><span class="keyword">int</span> n,c,m,t[N],color[N],ans[N],pre[N],colorAppear[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span>&#123;</span><span class="keyword">int</span> l,r,id;&#125;ask[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp1</span><span class="params">(Ask x,Ask y)</span></span>&#123;<span class="keyword">return</span> x.r&lt;y.r;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;<span class="keyword">for</span>(;x&lt;=n;x+=x&amp;-x)t[x]+=k;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">int</span> ans=<span class="number">0</span>;<span class="keyword">for</span>(;x;x-=x&amp;-x)ans+=t[x];<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>(),c=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)color[i]=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)ask[i].l=<span class="built_in">rd</span>(),ask[i].r=<span class="built_in">rd</span>(),ask[i].id=i;</span><br><span class="line">    <span class="built_in">sort</span>(ask+<span class="number">1</span>,ask+m+<span class="number">1</span>,comp1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=ask[i<span class="number">-1</span>].r+<span class="number">1</span>;j&lt;=ask[i].r;++j)&#123;</span><br><span class="line">            pre[j]=colorAppear[color[j]];</span><br><span class="line">            colorAppear[color[j]]=j;</span><br><span class="line">            <span class="keyword">if</span>(pre[pre[j]])<span class="built_in">add</span>(pre[pre[j]],<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(pre[j])<span class="built_in">add</span>(pre[j],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans[ask[i].id]=<span class="built_in">query</span>(ask[i].r)-<span class="built_in">query</span>(ask[i].l<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>HEOI2016/TJOI2016排序 线段树合并分裂</title>
    <url>/2020/01/03/heoi2016-tjoi2016%E6%8E%92%E5%BA%8F-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6%E5%88%86%E8%A3%82/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2824">[HEOI2016/TJOI2016]排序</a> 今日见高一要学线段树分裂，发现自己没写过，大惊，来补了一下这个题。。。 其实这题很水的，只不过线段树分裂当板子用，专门记一下。。。 维护权值线段树，把一段区间都塞进权值线段树当作排好了。 那么用set维护线段树的根，操作一段区间的时候，把涉及到的一段取出来就好了。取出来合并涉及到线段树合并和分裂的操作。 其实线段树分裂就是找$k$大，同时新建一棵线段树，把前$k$大放进新线段树里，并且在旧线段树上删除这部分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cerr;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, Q;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> l, r, root, op;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b) &#123;</span><br><span class="line">  <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::set&lt;Node&gt; set;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegTree</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> ls, rs, sum;</span><br><span class="line">&#125; seg[N * <span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> stk[N * <span class="number">30</span>], top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">new_node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = stk[top--];</span><br><span class="line">  seg[x].ls = seg[x].rs = seg[x].sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  stk[++top] = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> x, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p) p = <span class="built_in">new_node</span>();</span><br><span class="line">  ++seg[p].sum;</span><br><span class="line">  <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">insert</span>(seg[p].ls, x, L, mid);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">insert</span>(seg[p].rs, x, mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!x  !y) <span class="keyword">return</span> x + y;</span><br><span class="line">  <span class="keyword">int</span> z = <span class="built_in">new_node</span>();</span><br><span class="line">  seg[z].ls = <span class="built_in">merge</span>(seg[x].ls, seg[y].ls);</span><br><span class="line">  seg[z].rs = <span class="built_in">merge</span>(seg[x].rs, seg[y].rs);</span><br><span class="line">  seg[z].sum = seg[x].sum + seg[y].sum;</span><br><span class="line">  <span class="built_in">remove</span>(x), <span class="built_in">remove</span>(y);</span><br><span class="line">  <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> q = <span class="built_in">new_node</span>();</span><br><span class="line">  seg[q].sum += x; seg[p].sum -= x;</span><br><span class="line">  <span class="keyword">if</span> (L == R) <span class="keyword">return</span> q;</span><br><span class="line">  <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>, s = seg[seg[p].ls].sum;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; s) seg[q].ls = <span class="built_in">split</span>(seg[p].ls, x, L, mid);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    seg[q].ls = seg[p].ls, seg[p].ls = <span class="number">0</span>;</span><br><span class="line">    seg[q].rs = <span class="built_in">split</span>(seg[p].rs, x - s, mid + <span class="number">1</span>, R);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_kth</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L == R) <span class="keyword">return</span> L;</span><br><span class="line">  <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>, s = seg[seg[p].ls].sum;</span><br><span class="line">  <span class="keyword">if</span> (s &gt;= x) <span class="keyword">return</span> <span class="built_in">get_kth</span>(seg[p].ls, x, L, mid);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">get_kth</span>(seg[p].rs, x - s, mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">seq_split</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  std::set&lt;Node&gt;::iterator it = set.<span class="built_in">lower_bound</span>(&#123;<span class="number">0</span>, l, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">  <span class="keyword">if</span> (it-&gt;l != l) &#123;</span><br><span class="line">    Node tmp = *it;</span><br><span class="line">    set.<span class="built_in">erase</span>(it);</span><br><span class="line">    <span class="keyword">if</span> (!tmp.op) &#123;</span><br><span class="line">      <span class="keyword">int</span> root = <span class="built_in">split</span>(tmp.root, l - tmp.l, <span class="number">1</span>, n);</span><br><span class="line">      set.<span class="built_in">insert</span>(&#123; tmp.l, l - <span class="number">1</span>, root, <span class="number">0</span> &#125;);</span><br><span class="line">      set.<span class="built_in">insert</span>(&#123; l, tmp.r, tmp.root, <span class="number">0</span> &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> root = <span class="built_in">split</span>(tmp.root, tmp.r - l + <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">      set.<span class="built_in">insert</span>(&#123; tmp.l, l - <span class="number">1</span>, tmp.root, <span class="number">1</span> &#125;);</span><br><span class="line">      set.<span class="built_in">insert</span>(&#123; l, tmp.r, root, <span class="number">1</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  it = set.<span class="built_in">lower_bound</span>(&#123; <span class="number">0</span>, r, <span class="number">0</span>, <span class="number">0</span> &#125;);</span><br><span class="line">  <span class="keyword">if</span> (it-&gt;r != r) &#123;</span><br><span class="line">    Node tmp = *it;</span><br><span class="line">    set.<span class="built_in">erase</span>(it);</span><br><span class="line">    <span class="keyword">if</span> (!tmp.op) &#123;</span><br><span class="line">      <span class="keyword">int</span> root = <span class="built_in">split</span>(tmp.root, r - tmp.l + <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">      set.<span class="built_in">insert</span>(&#123; tmp.l, r, root, <span class="number">0</span> &#125;);</span><br><span class="line">      set.<span class="built_in">insert</span>(&#123; r + <span class="number">1</span>, tmp.r, tmp.root, <span class="number">0</span> &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> root = <span class="built_in">split</span>(tmp.root, tmp.r - r, <span class="number">1</span>, n);</span><br><span class="line">      set.<span class="built_in">insert</span>(&#123; tmp.l, r, tmp.root, <span class="number">1</span> &#125;);</span><br><span class="line">      set.<span class="built_in">insert</span>(&#123; r + <span class="number">1</span>, tmp.r, root, <span class="number">1</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    it = set.<span class="built_in">lower_bound</span>(&#123; <span class="number">0</span>, l, <span class="number">0</span>, <span class="number">0</span> &#125;);</span><br><span class="line">    <span class="keyword">if</span> (it == set.<span class="built_in">end</span>()  it-&gt;l &gt; r)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    Node tmp = *it;</span><br><span class="line">    set.<span class="built_in">erase</span>(tmp);</span><br><span class="line">    ret = <span class="built_in">merge</span>(ret, tmp.root);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen(&quot;data&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">  n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N * <span class="number">30</span> - <span class="number">1</span>; ++i)</span><br><span class="line">    stk[++top] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">rd</span>(), root = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">insert</span>(root, x, <span class="number">1</span>, n);</span><br><span class="line">    set.<span class="built_in">insert</span>(&#123; i, i, root, <span class="number">0</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="keyword">int</span> op = <span class="built_in">rd</span>(), x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>(), root = <span class="built_in">seq_split</span>(x, y);</span><br><span class="line">    set.<span class="built_in">insert</span>(&#123; x, y, root, op &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  Q = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">int</span> root = <span class="built_in">seq_split</span>(Q, Q);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">get_kth</span>(root, <span class="number">1</span>, <span class="number">1</span>, n));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>HEOI2016/TJOI2016树</title>
    <url>/2019/06/04/heoi2016-tjoi2016%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4092">[HEOI2016/TJOI2016]树</a> 顺着树剖的题单找过去的，一点标签，发现有并查集。 其实显然这题可以用并查集做。离线操作，把每个点最终标记数出来。并查集数组是fa[]，对于树上每个点x，如果标记过，fa[x]=x，不然fa[x]=father[x]。 倒序处理操作，询问直接回答，标记的就减，如果点x减没了，fa[x]=father[x]。 偷懒并查集只写了路径压缩，$O(nlogn)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> fa[N], father[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] == x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125; g[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    g[++tot].to = y, g[tot].nxt = head[x],</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; op[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[x] = cnt[x] ? x : f;</span><br><span class="line">    father[x] = f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="keyword">if</span> (y != f)</span><br><span class="line">            <span class="built_in">dfs</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">addedge</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> opt[<span class="number">5</span>]; <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, opt);</span><br><span class="line">        op[i].second = <span class="built_in">rd</span>();</span><br><span class="line">        op[i].first = *opt == <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!op[i].first)</span><br><span class="line">            ++cnt[op[i].second];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!op[i].first) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!--cnt[op[i].second])</span><br><span class="line">                fa[op[i].second] = father[op[i].second];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans[++ans[<span class="number">0</span>]] = <span class="built_in">find</span>(op[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ans[<span class="number">0</span>]; i; --i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>HNOI/AHOI2018转盘 分块</title>
    <url>/2020/05/27/hnoi-ahoi2018%E8%BD%AC%E7%9B%98-%E5%88%86%E5%9D%97/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4425">[HNOI/AHOI2018]转盘</a> 冷静分析一下：在原地呆一会再走比中间呆着优秀。倍长，钦定从$x$开始走，等待时间$s=\max_{i=x}^{i+n-1} \lbrace A_i - i + x \rbrace$。再冷静一下发现直接求到$2n$也是没问题的。 之后就是一个神秘转化了：反过来考虑$i$对$x$贡献，发现$A_i - i$单调的一段有贡献。就转化为了动态维护单调栈，动态维护最小值的问题。 考虑一种线段树做法：合并左右儿子，用右儿子的max在左边二分，找到合适的位置，再做一个区间查询。复杂度两个log。 还有一种高级分块方法：直接维护每一块的单调栈，询问的时候扫栈，考虑后面一块的max，在前面二分对应位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cerr;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, B = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, op, A[N], ans;</span><br><span class="line"><span class="keyword">int</span> L[N], pos[N], block;</span><br><span class="line"><span class="keyword">int</span> stk[B][B], max[B], top_blk[B];</span><br><span class="line"><span class="keyword">int</span> min[B][B];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> blk)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = L[blk + <span class="number">1</span>] - <span class="number">1</span>; i &gt;= L[blk]; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!top  A[i] &gt; A[stk[blk][top]])</span><br><span class="line">      stk[blk][++top] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  max[blk] = A[stk[blk][top]];</span><br><span class="line">  top_blk[blk] = top;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &gt;= <span class="number">2</span>; --i) &#123;</span><br><span class="line">    min[blk][i] = stk[blk][i] + A[stk[blk][i - <span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">if</span> (i != top)</span><br><span class="line">      min[blk][i] = std::<span class="built_in">min</span>(min[blk][i], min[blk][i + <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Priority_Queue</span> &#123;</span></span><br><span class="line">  std::priority_queue&lt;<span class="keyword">int</span>&gt; que, del;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    que.<span class="built_in">push</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    del.<span class="built_in">push</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; !del.<span class="built_in">empty</span>() &amp;&amp; que.<span class="built_in">top</span>() == del.<span class="built_in">top</span>())</span><br><span class="line">      que.<span class="built_in">pop</span>(), del.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">assert</span>(!que.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">return</span> que.<span class="built_in">top</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> Max = que.<span class="built_in">top</span>(), ret = <span class="number">1e9</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> blk = pos[n]; blk; --blk) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max[blk] &lt;= Max)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = top_blk[blk], res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">      <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (A[stk[blk][mid]] &gt; Max)</span><br><span class="line">        res = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(res != <span class="number">-1</span>);</span><br><span class="line">    ret = std::<span class="built_in">min</span>(ret, stk[blk][res] + Max);</span><br><span class="line">    <span class="keyword">if</span> (res != top_blk[blk])</span><br><span class="line">      ret = std::<span class="built_in">min</span>(ret, min[blk][res + <span class="number">1</span>]);</span><br><span class="line">    Max = max[blk];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret + n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; op;</span><br><span class="line">  block = std::<span class="built_in">sqrt</span>(n * std::<span class="built_in">log</span>(n)) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    std::cin &gt;&gt; A[i];</span><br><span class="line">    A[i] -= i;</span><br><span class="line">    pos[i] = (i - <span class="number">1</span>) / block + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos[i] != pos[i - <span class="number">1</span>])</span><br><span class="line">      L[pos[i]] = i;</span><br><span class="line">    que.<span class="built_in">push</span>(A[i] - n);</span><br><span class="line">  &#125;</span><br><span class="line">  pos[n + <span class="number">1</span>] = pos[n] + <span class="number">1</span>;</span><br><span class="line">  L[pos[n + <span class="number">1</span>]] = n + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pos[n]; ++i)</span><br><span class="line">    <span class="built_in">modify</span>(i);</span><br><span class="line">  ans = <span class="built_in">query</span>();</span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="comment">// exit(0);</span></span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y; std::cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">if</span> (op) x ^= ans, y ^= ans;</span><br><span class="line">    que.<span class="built_in">erase</span>(A[x] - n);</span><br><span class="line">    A[x] = y - x;</span><br><span class="line">    que.<span class="built_in">push</span>(A[x] - n);</span><br><span class="line">    <span class="built_in">modify</span>(pos[x]);</span><br><span class="line">    ans = <span class="built_in">query</span>();</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>HNOI2010平面图判定</title>
    <url>/2019/07/09/hnoi2010%E5%B9%B3%E9%9D%A2%E5%9B%BE%E5%88%A4%E5%AE%9A/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3209">[HNOI2010]平面图判定</a> 想了半天，不可做。补习了一下平面图知识。 平面图是可以画在平面上并且使得不同的边可以互不交叠的图。对偶图就是平面图中平面做点，点与点之间连边形成的图。</p>
<h5 id="平面图的Eular公式："><a href="#平面图的Eular公式：" class="headerlink" title="平面图的Eular公式："></a>平面图的Eular公式：</h5><p>$V$是点数，$F$是面数，$E$是边数，则有$V+F=E+2$。 证明： 给平面图做个生成树出来，再做个对偶图。对偶图上边中不是在生成树上的单独提出来，发现没有环（生成树联通），是个树。注意到树的点是边数$+1$，带入原公式，得证。</p>
<h5 id="一个推论"><a href="#一个推论" class="headerlink" title="一个推论"></a>一个推论</h5><p>平面图中，$E \leq 3V-6$ 因为平面图中每个面至少由三条边围成，每条边只挨着两个面。$3F\leq 2E$，代入可得。</p>
<hr>
<p>有了这一坨推论，可以发现，可能是平面图的边数是$O(n)$级别。 枚举不属于环的边对，如果这对边在环内相交，那么它们必须一个在外面一个在里面。用2-SAT解决问题。拆点，$x,x’$，分别表示在内在外。建这些边。 $x\to y’,y \to x’, x’ \to y, y’ \to x$ 好吧我承认并查集就可做。。。。我是顺着2-SAT标签找进来的别打我。。。。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; edge[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> circle[N], where[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125; g[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    g[++tot].to = y, g[tot].nxt = head[x],</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[N], low[N], ins[N], stack[N], top, belong[N], cnt, num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++num;</span><br><span class="line">    ins[stack[++top] = x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[y = g[i].to]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ins[y])</span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low[x] == dfn[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y; ++cnt;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ins[y = stack[top--]] = <span class="literal">false</span>;</span><br><span class="line">            belong[y] = cnt;</span><br><span class="line">        &#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">love</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * (tot + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * (m * <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * (m * <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * (m * <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">memset</span>(belong, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * (m * <span class="number">2</span>));</span><br><span class="line">    tot = cnt = num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m &gt; n * <span class="number">3</span> - <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="built_in">rd</span>(), <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        edge[i].x = <span class="built_in">rd</span>();</span><br><span class="line">        edge[i].y = <span class="built_in">rd</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        circle[i] = <span class="built_in">rd</span>();</span><br><span class="line">        where[circle[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    circle[n + <span class="number">1</span>] = circle[<span class="number">1</span>];</span><br><span class="line">    circle[<span class="number">0</span>] = circle[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((circle[where[edge[i].x] - <span class="number">1</span>] == edge[i].y) </span><br><span class="line">            (circle[where[edge[i].x] + <span class="number">1</span>] == edge[i].y))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((circle[where[edge[j].x] - <span class="number">1</span>] == edge[j].y) </span><br><span class="line">                (circle[where[edge[j].x] + <span class="number">1</span>] == edge[j].y))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> x1 = where[edge[i].x], x2 = where[edge[i].y],</span><br><span class="line">                y1 = where[edge[j].x], y2 = where[edge[j].y];</span><br><span class="line">            <span class="keyword">if</span> (x1 &gt; x2) std::<span class="built_in">swap</span>(x1, x2);</span><br><span class="line">            <span class="keyword">if</span> (y1 &gt; y2) std::<span class="built_in">swap</span>(y1, y2);</span><br><span class="line">            <span class="keyword">if</span> (!((x1 &lt; y1 &amp;&amp; y1 &lt; x2 &amp;&amp; x2 &lt; y2) </span><br><span class="line">                (y1 &lt; x1 &amp;&amp; x1 &lt; y2 &amp;&amp; y2 &lt; x2)))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">addedge</span>(i, j + m);</span><br><span class="line">            <span class="built_in">addedge</span>(j, i + m);</span><br><span class="line">            <span class="built_in">addedge</span>(i + m, j);</span><br><span class="line">            <span class="built_in">addedge</span>(j + m, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m * <span class="number">2</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (belong[i] == belong[i + m]) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T = <span class="built_in">rd</span>(); <span class="keyword">while</span> (T--) <span class="built_in">love</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>HNOI2008GT考试</title>
    <url>/2019/06/10/hnoi2008gt%E8%80%83%E8%AF%95/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3193">[HNOI2008]GT考试</a> 首先DP一下。$f[i][j]$表示$n$到$i$，$m$到$j$的方案数。实际上不需要关心具体字母，知道有多少转移方案就行了。$f[i][j]=\sum_{t=1}^{m-1}(f[i-1][t]*g[k][j])$。$g[i][j]$表示从$m$的$i$到$j$的方案数。 实际上，因为数据很小，$g$数组可以暴力求出来。另一种方法是用kmp。枚举起点和终点字母算方案数就行了。 DP的式子长得很好看，可以矩乘优化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, mod;</span><br><span class="line"><span class="keyword">char</span> num[<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; num[j + <span class="number">1</span>] != num[i])</span><br><span class="line">            j = nxt[j];</span><br><span class="line">        <span class="keyword">if</span> (num[j + <span class="number">1</span>] == num[i])</span><br><span class="line">            ++j;</span><br><span class="line">        nxt[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="string">&#x27;0&#x27;</span>; j &lt;= <span class="string">&#x27;9&#x27;</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i;</span><br><span class="line">            <span class="keyword">while</span> (x &amp;&amp; num[x + <span class="number">1</span>] != j)</span><br><span class="line">                x = nxt[x];</span><br><span class="line">            <span class="keyword">if</span> (num[x + <span class="number">1</span>] == j)</span><br><span class="line">                ++x;</span><br><span class="line">            <span class="keyword">if</span> (x != m)</span><br><span class="line">                ++g[i][x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>() &#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a)); &#125;</span><br><span class="line">&#125; A, G;</span><br><span class="line"></span><br><span class="line">Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix &amp;x, <span class="keyword">const</span> Matrix &amp;y) &#123;</span><br><span class="line">    Matrix ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">20</span>; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">20</span>; ++k)</span><br><span class="line">                ret.a[i][j] = (ret.a[i][j] + x.a[i][k] * y.a[k][j]) % mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">fpow</span><span class="params">(Matrix x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    Matrix ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; ++i)</span><br><span class="line">        ret.a[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = ret * x;</span><br><span class="line">        x = x * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">            G.a[i][j] = g[i][j];</span><br><span class="line">    A.a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    A = A * <span class="built_in">fpow</span>(G, n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        ans = (ans + A.a[<span class="number">0</span>][i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod &gt;&gt; (num + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">kmp</span>();</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>HNOI2004宠物收养场</title>
    <url>/2019/01/05/hnoi2004%E5%AE%A0%E7%89%A9%E6%94%B6%E5%85%BB%E5%9C%BA/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2286">[HNOI2004]宠物收养场</a> 一道可以用STLset解决的问题 这题貌似解法很多，但是蒟蒻只会用STL的set… 开两个set，每个分别插入INF与-INF作为边界 每次输入，如果另一个set中有可用元素，则取出进行判断 lower_bound(x)可以找出第一个大于等于x的值的位置，–x即第一个小于x的值 比较b与两数之差即可 当然，也可以只开一个set，以减少代码长度，实现也很简单 <a href="http://hzwer.com/1311.html">实现</a> 一定要记得取模与开long long…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; man, pet;</span><br><span class="line">    man.<span class="built_in">insert</span>(INF);</span><br><span class="line">    man.<span class="built_in">insert</span>(-INF);</span><br><span class="line">    pet.<span class="built_in">insert</span>(INF);</span><br><span class="line">    pet.<span class="built_in">insert</span>(-INF);</span><br><span class="line">    <span class="keyword">int</span> n, a, b;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (man.<span class="built_in">size</span>() != <span class="number">2</span>) &#123;</span><br><span class="line">                set&lt;<span class="keyword">int</span>&gt;::iterator l = --man.<span class="built_in">lower_bound</span>(b), r = man.<span class="built_in">lower_bound</span>(b);</span><br><span class="line">                <span class="keyword">if</span> (b - *l &lt;= *r - b &amp;&amp; *l != -INF) &#123;</span><br><span class="line">                    ans += b - *l;</span><br><span class="line">                    man.<span class="built_in">erase</span>(l);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (*r != INF) &#123;</span><br><span class="line">                    ans += *r - b;</span><br><span class="line">                    man.<span class="built_in">erase</span>(r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                pet.<span class="built_in">insert</span>(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pet.<span class="built_in">size</span>() != <span class="number">2</span>) &#123;</span><br><span class="line">                set&lt;<span class="keyword">int</span>&gt;::iterator l = --pet.<span class="built_in">lower_bound</span>(b), r = pet.<span class="built_in">lower_bound</span>(b);</span><br><span class="line">                <span class="keyword">if</span> (b - *l &lt;= *r - b &amp;&amp; *l != -INF) &#123;</span><br><span class="line">                    ans += b - *l;</span><br><span class="line">                    pet.<span class="built_in">erase</span>(l);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (*r != INF) &#123;</span><br><span class="line">                    ans += *r - b;</span><br><span class="line">                    pet.<span class="built_in">erase</span>(r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                man.<span class="built_in">insert</span>(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans % <span class="number">1000000</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>HNOI2019白兔之舞 单位根反演</title>
    <url>/2020/03/29/hnoi2019%E7%99%BD%E5%85%94%E4%B9%8B%E8%88%9E-%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<p><a href="https://loj.ac/problem/3058">[HNOI2019]白兔之舞</a> 这个套路那个套路 叠加起来就是毒瘤题 各种奇怪东西加在一起的题。 考虑钦定走了$m$步的方案数。令$f_m$为连着走了$m$步的方案： $$\sum_{i=0}^L \binom{i-1}{L-1} f_m = \binom{L}{m} f_m $$ 显然$f$k可以矩乘优化求。令$S$为初始矩阵，$M$为转移矩阵： $$f_i = (SM^i)_y$$ $$ans_t = \sum_{i=0}^L [i \mod K = t] \binom{L}{i} f_i$$ 看到整除根据套路单位根反演： $$ans_t = \sum_{i=0}^L \frac{1}{K} \sum_{j &lt; K} \omega_{K}^{j(i-t)} \binom{L}{i} f_i$$ 再套路的化简一波： $$=\frac{1}{K} \sum_{j &lt; K } \omega_{K}^{-jt} (S \sum_{i=0}^L \binom{L}{i} M^i \omega_{K}^{ji} )_y$$ 后面第二个$\sum$里的东西可以二项式定理 $$=\frac{1}{K} \sum_{j &lt; K } \omega_{K}^{-jt} (S (M\omega_{K}^j+I)^L)_y$$ 显然可以倍增随便求 $$=\frac{1}{K} \sum_{j &lt; K } \omega_{K}^{-jt} V_j$$ 因为模数不是质数，考虑Bluestein’s Algorithm。 $$=\frac{1}{K} \sum_{j &lt; K } \omega_{K}^{\binom{j}{2} + \binom{t}{2} - \binom{j+t}{2&#125;&#125; V_j$$ $$=\frac{1}{K} \omega_{K}^{\binom{t}{2&#125;&#125; \sum_{j &lt; K } \omega_{K}^{\binom{j}{2&#125;&#125; V_j \omega_{K}^{-\binom{j+k}{2&#125;&#125; $$ 那么后面这个显然是卷积，卷一卷就可以做了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cerr;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = std::<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span> &#123;</span></span><br><span class="line">  <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> comp <span class="keyword">operator</span>+(<span class="keyword">const</span> comp &amp;a, <span class="keyword">const</span> comp &amp;b) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; a.x + b.x, a.y + b.y &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> comp <span class="keyword">operator</span>-(<span class="keyword">const</span> comp &amp;a, <span class="keyword">const</span> comp &amp;b) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; a.x - b.x, a.y - b.y &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> comp <span class="keyword">operator</span>*(<span class="keyword">const</span> comp &amp;a, <span class="keyword">const</span> comp &amp;b) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> comp <span class="keyword">operator</span>/(<span class="keyword">const</span> comp &amp;a, <span class="keyword">double</span> b) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; a.x / b, a.y / b &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> comp <span class="title">conj</span><span class="params">(<span class="keyword">const</span> comp &amp;a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; a.x, -a.y &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lim, rev[N];</span><br><span class="line">comp w1[N], w2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  lim = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (lim &lt; n) lim &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) &#123;</span><br><span class="line">    rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>)  ((i &amp; <span class="number">1</span>) ? (lim &gt;&gt; <span class="number">1</span>) : <span class="number">0</span>);</span><br><span class="line">    w1[i] = &#123; std::<span class="built_in">cos</span>(PI * <span class="number">2</span> * i / lim), std::<span class="built_in">sin</span>(PI * <span class="number">2</span> * i / lim) &#125;;</span><br><span class="line">    w2[i] = <span class="built_in">conj</span>(w1[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DFT</span><span class="params">(comp f[], <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    <span class="keyword">if</span> (i &lt; rev[i]) std::<span class="built_in">swap</span>(f[i], f[rev[i]]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += i &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">      comp *p = o == <span class="number">1</span> ? w1 : w2;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k, p += lim / i / <span class="number">2</span>) &#123;</span><br><span class="line">        comp nx = f[j + k], ny = f[i + j + k] * *p;</span><br><span class="line">        f[j + k] = nx + ny;</span><br><span class="line">        f[i + j + k] = nx - ny;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (o == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">      f[i] = f[i] / lim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> P;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MTT</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> F[], <span class="keyword">long</span> <span class="keyword">long</span> G[], <span class="keyword">long</span> <span class="keyword">long</span> R[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> comp A[N], B[N]; <span class="keyword">int</span> M = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) &#123;</span><br><span class="line">    A[i] = &#123; F[i] &amp; M, F[i] &gt;&gt; <span class="number">15</span> &#125;;</span><br><span class="line">    B[i] = &#123; G[i] &amp; M, G[i] &gt;&gt; <span class="number">15</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">DFT</span>(A, <span class="number">1</span>), <span class="built_in">DFT</span>(B, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">static</span> comp tA[N], tB[N], tC[N], tD[N];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = (lim - i) &amp; (lim - <span class="number">1</span>);</span><br><span class="line">    comp ta = (A[i] + <span class="built_in">conj</span>(A[j])) * comp &#123; <span class="number">0.5</span>, <span class="number">0</span> &#125;,</span><br><span class="line">      tb = (A[i] - <span class="built_in">conj</span>(A[j])) * comp &#123; <span class="number">0</span>, <span class="number">-0.5</span> &#125;,</span><br><span class="line">      tc = (B[i] + <span class="built_in">conj</span>(B[j])) * comp &#123; <span class="number">0.5</span>, <span class="number">0</span> &#125;,</span><br><span class="line">      td = (B[i] - <span class="built_in">conj</span>(B[j])) * comp &#123; <span class="number">0</span>, <span class="number">-0.5</span> &#125;;</span><br><span class="line">    tA[i] = ta * tc; tB[i] = ta * td;</span><br><span class="line">    tC[i] = tb * tc; tD[i] = tb * td;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) &#123;</span><br><span class="line">    A[i] = tA[i] + tB[i] * comp &#123; <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    B[i] = tC[i] + tD[i] * comp &#123; <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">DFT</span>(A, <span class="number">-1</span>), <span class="built_in">DFT</span>(B, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) &#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ta = (<span class="keyword">long</span> <span class="keyword">long</span>)(A[i].x + <span class="number">0.5</span>) % P;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tb = (<span class="keyword">long</span> <span class="keyword">long</span>)(A[i].y + <span class="number">0.5</span>) % P,</span><br><span class="line">      tc = (<span class="keyword">long</span> <span class="keyword">long</span>)(B[i].x + <span class="number">0.5</span>) % P,</span><br><span class="line">      td = (<span class="keyword">long</span> <span class="keyword">long</span>)(B[i].y + <span class="number">0.5</span>) % P;</span><br><span class="line">    R[i] = (ta + ((tb + tc) &lt;&lt; <span class="number">15</span>) + (td &lt;&lt; <span class="number">30</span>)) % P;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K, L, X, Y;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> omega;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> mat[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Matrix def, mat_I, mat_S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix &amp;a, <span class="keyword">const</span> Matrix &amp;b) &#123;</span><br><span class="line">  Matrix ret; <span class="built_in">memset</span>(ret.mat, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ret.mat));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)</span><br><span class="line">        ret.mat[i][j] += a.mat[i][k] * b.mat[k][j];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)</span><br><span class="line">      ret.mat[i][j] %= P;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = x * x % P)</span><br><span class="line">    <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = ret * x % P;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> buc[N], tot;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= P - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!((P - <span class="number">1</span>) % i)) &#123;</span><br><span class="line">      buc[++tot] = i;</span><br><span class="line">      <span class="keyword">if</span> (i * i != P - <span class="number">1</span>)</span><br><span class="line">        buc[++tot] = (P - <span class="number">1</span>) / i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= P - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> ok = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; ++j)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">fpow</span>(i, buc[j]) == <span class="number">1</span>) &#123;</span><br><span class="line">        ok = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span> (ok) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-114514</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">fpow</span><span class="params">(Matrix x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  Matrix ret = x;</span><br><span class="line">  <span class="keyword">for</span> (--y; y; y &gt;&gt;= <span class="number">1</span>, x = x * x)</span><br><span class="line">    <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = ret * x;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">calc_A</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  Matrix qwq; <span class="built_in">memset</span>(qwq.mat, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(qwq.mat));</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> w = <span class="built_in">fpow</span>(omega, x);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">      qwq.mat[i][j] = (def.mat[i][j] * w + mat_I.mat[i][j]) % P;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">fpow</span>(qwq, L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> A[N], B[N], C[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen(&quot;data&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; K &gt;&gt; L &gt;&gt; X &gt;&gt; Y &gt;&gt; P;</span><br><span class="line">  omega = <span class="built_in">fpow</span>(<span class="built_in">get_root</span>(), (P - <span class="number">1</span>) / K);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">      std::cin &gt;&gt; def.mat[i][j];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    mat_I.mat[i][i] = <span class="number">1</span>;</span><br><span class="line">  mat_S.mat[<span class="number">0</span>][X - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; ++i)</span><br><span class="line">    A[i] = (mat_S * <span class="built_in">calc_A</span>(i)).mat[<span class="number">0</span>][Y - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; ++i)</span><br><span class="line">    A[i] = A[i] * <span class="built_in">fpow</span>(omega, <span class="number">1ll</span> * i * (i - <span class="number">1</span>) / <span class="number">2</span>) % P;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= K * <span class="number">2</span>; ++i)</span><br><span class="line">    B[K * <span class="number">2</span> - i] = <span class="built_in">fpow</span>(<span class="built_in">fpow</span>(omega, <span class="number">1ll</span> * i * (i - <span class="number">1</span>) / <span class="number">2</span>), P - <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">init</span>(K * <span class="number">2</span> + <span class="number">5</span>);</span><br><span class="line">  <span class="built_in">MTT</span>(A, B, C);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; ++i) &#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="built_in">fpow</span>(K, P - <span class="number">2</span>) * <span class="built_in">fpow</span>(omega, <span class="number">1ll</span> * i * (i - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">      % P * C[K * <span class="number">2</span> - i] % P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>CERC2016二分毯 Bipartite Blanket Hall定理状压</title>
    <url>/2019/11/10/cerc2016%E4%BA%8C%E5%88%86%E6%AF%AF-bipartite-blanket-hall%E5%AE%9A%E7%90%86%E7%8A%B6%E5%8E%8B/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P3679">[CERC2016]二分毯 Bipartite Blanket</a> 首先要知道Hall定理. 二分图点集$X,Y$,令$X \leq Y$,记$T(x)$为和$x$相邻点集,如果存在完美匹配,则对于$\forall x \subseteq X$,有$x \leq T(x)$ 证明的话,大概就是假设不存在完美匹配,就可以找到增广路这样 然后本题的”覆盖”是指点是匹配端点就行,所以有一个推论: 对于$X,Y$的子集$x,y$,如果$x,y$分别满足Hall定理,那么一定存在一组匹配,使得$x,y$都在其中. 于是可以分别状压DP求出所有满足的子集,排序双指针扫一扫.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>, S = (<span class="number">1</span> &lt;&lt; N) + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, G_A[S], G_B[S], A[N], B[N], T,</span><br><span class="line">  f_A[S], f_B[S], cnt[S];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line">std::vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; s_A, s_B;</span><br><span class="line"><span class="keyword">char</span> str[N + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    std::cin &gt;&gt; str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">      <span class="keyword">if</span> (str[j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        G_A[<span class="number">1</span> &lt;&lt; i] = <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">        G_B[<span class="number">1</span> &lt;&lt; j] = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    std::cin &gt;&gt; A[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    std::cin &gt;&gt; B[i];</span><br><span class="line">  std::cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; <span class="number">1</span> &lt;&lt; std::<span class="built_in">max</span>(n, m); ++s)</span><br><span class="line">    cnt[s] = cnt[s &gt;&gt; <span class="number">1</span>] + (s &amp; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">1</span> &lt;&lt; n; ++s)</span><br><span class="line">      <span class="keyword">if</span> (s &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">        G_A[s] = G_A[s ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">1</span> &lt;&lt; m; ++s)</span><br><span class="line">      <span class="keyword">if</span> (s &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">        G_B[s] = G_B[s ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">1</span> &lt;&lt; n; ++s) &#123;</span><br><span class="line">    f_A[s] = <span class="number">1</span>; <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="keyword">if</span> (s &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">        f_A[s] &amp;= f_A[s ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">        sum += A[i];</span><br><span class="line">      &#125;</span><br><span class="line">    f_A[s] &amp;= cnt[G_A[s]] &gt;= cnt[s];</span><br><span class="line">    <span class="keyword">if</span> (f_A[s])</span><br><span class="line">      s_A.<span class="built_in">push_back</span>(sum);</span><br><span class="line">  &#125;</span><br><span class="line">  std::<span class="built_in">sort</span>(s_A.<span class="built_in">begin</span>(), s_A.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">1</span> &lt;&lt; m; ++s) &#123;</span><br><span class="line">    f_B[s] = <span class="number">1</span>; <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">      <span class="keyword">if</span> (s &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">        f_B[s] &amp;= f_B[s ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">        sum += B[i];</span><br><span class="line">      &#125;</span><br><span class="line">    f_B[s] &amp;= cnt[G_B[s]] &gt;= cnt[s];</span><br><span class="line">    <span class="keyword">if</span> (f_B[s])</span><br><span class="line">      s_B.<span class="built_in">push_back</span>(sum);</span><br><span class="line">  &#125;</span><br><span class="line">  std::<span class="built_in">sort</span>(s_B.<span class="built_in">begin</span>(), s_B.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>, b = s_B.<span class="built_in">size</span>(); a &lt; s_A.<span class="built_in">size</span>(); ++a) &#123;</span><br><span class="line">    <span class="keyword">while</span> (b - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; s_A[a] + s_B[b - <span class="number">1</span>] &gt;= T)</span><br><span class="line">      --b;</span><br><span class="line">    ans += s_B.<span class="built_in">size</span>() - b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>HEOI2016/TJOI2016序列</title>
    <url>/2019/07/02/heoi2016-tjoi2016%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4093">[HEOI2016/TJOI2016]序列</a> 首先写个暴力DP出来： f[i] = max{f[j] + 1}，j &lt; i, max_val[j] &lt;= a[i], a[j] &lt;= min_val[i]。 看得出来这是个三维偏序。树套树就可以了。这里用CDQ优化DP做。 几个小东西： 因为左边对右边有影响，递归左边后，计算影响，再递归右边。 树状数组维护最大值，因为只有增大和清零。 要排序几次，明显归并挂了。sort就行，复杂度多个log。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">2333</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, up;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, min, max, val, ans;</span><br><span class="line">&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp_id</span><span class="params">(<span class="keyword">const</span> Node &amp;x, <span class="keyword">const</span> Node &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.id &lt; y.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp_max</span><span class="params">(<span class="keyword">const</span> Node &amp;x, <span class="keyword">const</span> Node &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.max &lt; y.max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp_val</span><span class="params">(<span class="keyword">const</span> Node &amp;x, <span class="keyword">const</span> Node &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.val &lt; y.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bit[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; x &lt;= up; x += x &amp; -x)</span><br><span class="line">        bit[x] = std::<span class="built_in">max</span>(bit[x], y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; x &lt;= up; x += x &amp; -x)</span><br><span class="line">        bit[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; x; x -= x &amp; -x)</span><br><span class="line">        ret = std::<span class="built_in">max</span>(ret, bit[x]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">solve</span>(l, mid);</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(p + l, p + mid + <span class="number">1</span>, comp_max);</span><br><span class="line">    std::<span class="built_in">sort</span>(p + mid + <span class="number">1</span>, p + r + <span class="number">1</span>, comp_val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i].max &lt;= p[j].val)</span><br><span class="line">            <span class="built_in">add</span>(p[i].val, p[i].ans), ++i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p[j].ans = std::<span class="built_in">max</span>(p[j].ans, <span class="built_in">ask</span>(p[j].min) + <span class="number">1</span>), ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">        p[j].ans = std::<span class="built_in">max</span>(p[j].ans, <span class="built_in">ask</span>(p[j].min) + <span class="number">1</span>), ++j;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= l)</span><br><span class="line">        <span class="built_in">clear</span>(p[i--].val);</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(p + mid + <span class="number">1</span>, p + r + <span class="number">1</span>, comp_id);</span><br><span class="line">    <span class="built_in">solve</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(); m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        p[i].min = p[i].max = p[i].val = <span class="built_in">rd</span>();</span><br><span class="line">        p[i].id = i; p[i].ans = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">        p[x].max = std::<span class="built_in">max</span>(p[x].max, y);</span><br><span class="line">        p[x].min = std::<span class="built_in">min</span>(p[x].min, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        up = std::<span class="built_in">max</span>(up, p[i].max);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ans = std::<span class="built_in">max</span>(ans, p[i].ans);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>HNOI2010弹飞绵羊</title>
    <url>/2019/03/05/hnoi2010%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3203">[HNOI2010]弹飞绵羊</a> 这题正解LCT，然而蒟蒻虽然知道是板子题，可是不会写LCT… 不过这题也能用分块做。我们只需要维护每个点弹出当前块后会到达的位置，和需要弹多少步才能弹出去。在询问时一块一块的跳，修改时暴力维护即可。倒序循环可以在$O(n)$的时间内预处理。 实际上就是把$O(1)$的修改和$O(n)$的查询利用分块都变成了$O(\sqrt n)$。所以总复杂度$O(m\sqrt n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200000</span> + <span class="number">2333</span>;</span><br><span class="line"><span class="comment">// ef == &quot;elastic force&quot;</span></span><br><span class="line"><span class="keyword">int</span> n, m, block, pos[N], l[N], nxt[N], step[N], ef[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(), block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ef[i] = <span class="built_in">rd</span>();</span><br><span class="line">        pos[i] = (i - <span class="number">1</span>) / block + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos[i] != pos[i - <span class="number">1</span>]) l[pos[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    l[pos[n] + <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">    m = <span class="built_in">rd</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = to; i &gt;= from; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + ef[i] &gt;= l[pos[i] + <span class="number">1</span>])</span><br><span class="line">            step[i] = <span class="number">1</span>, nxt[i] = i + ef[i];</span><br><span class="line">        <span class="keyword">else</span> step[i] = step[i + ef[i]] + <span class="number">1</span>, nxt[i] = nxt[i + ef[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; x &lt;= n; x = nxt[x])</span><br><span class="line">        ans += step[x];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(), <span class="built_in">update</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="built_in">rd</span>(), x;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(<span class="built_in">rd</span>() + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ef[x = <span class="built_in">rd</span>() + <span class="number">1</span>] = <span class="built_in">rd</span>(), <span class="built_in">update</span>(l[pos[x]], x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>IOI1998 Polygon</title>
    <url>/2019/01/05/ioi1998-polygon/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4342">Luogu P4342 [IOI1998]Polygon</a> 又是区间dp耶qwq 根据题意，删掉一条边之后合并，其实类似合并果子一题 输入数据，首先任取一点破环称链，对于整个链dp之后，${f_max}[i][i+n-1]$即为答案 本题中，由于涉及乘法运算，可能有两很小的负数相乘，结果却很大，需要再使用$g$数组记录最小值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN], g[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> num[MAXN];</span><br><span class="line"><span class="keyword">char</span> op[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> t, <span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(q, <span class="built_in">max</span>(<span class="built_in">max</span>(x, y), <span class="built_in">max</span>(z, t)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> t, <span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(q, <span class="built_in">min</span>(<span class="built_in">min</span>(x, y), <span class="built_in">min</span>(z, t)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; op[i] &gt;&gt; num[i];</span><br><span class="line">        num[i + n] = num[i];</span><br><span class="line">        op[i + n] = op[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(g));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        f[i][i] = num[i];</span><br><span class="line">        g[i][i] = num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n * <span class="number">2</span>; ++len) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = len; j &lt;= n * <span class="number">2</span>; ++i, ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt;= j; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (op[k] == <span class="string">&#x27;t&#x27;</span>) &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][k - <span class="number">1</span>] + f[k][j]);</span><br><span class="line">                    g[i][j] = <span class="built_in">min</span>(g[i][j], g[i][k - <span class="number">1</span>] + g[k][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][k - <span class="number">1</span>] * f[k][j], </span><br><span class="line">                        f[i][k - <span class="number">1</span>] * g[k][j], g[i][k - <span class="number">1</span>] * f[k][j], g[i][k - <span class="number">1</span>] * g[k][j]);</span><br><span class="line">                    g[i][j] = <span class="built_in">min</span>(g[i][j], f[i][k - <span class="number">1</span>] * f[k][j], </span><br><span class="line">                        f[i][k - <span class="number">1</span>] * g[k][j], g[i][k - <span class="number">1</span>] * f[k][j], g[i][k - <span class="number">1</span>] * g[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = -(<span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[i][i + n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[i][i + n - <span class="number">1</span>] == ans) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某处g写成f调了半小时…..</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>IOI2014wall砖墙</title>
    <url>/2019/04/03/ioi2014wall%E7%A0%96%E5%A2%99/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4560">[IOI2014]wall砖墙</a> 实际上就是线段树，两个操作：区间与一个数取min，max。于是打两个lazytag，add和del，分别表示两种操作的结果，即add&lt;=x&lt;=del。修改的时候，以add操作为例，只需要把add和del都和h取一个max即可。remove操作同理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000000</span> + <span class="number">23333</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, add, del;</span><br><span class="line">    <span class="built_in">Segment_Tree</span>() &#123; del = INF; &#125;</span><br><span class="line">&#125; t[N * <span class="number">3</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(p) p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(p) p &lt;&lt; 1  1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[p].l = l, t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l != r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(p), l, mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[p].add != <span class="number">0</span>) &#123;</span><br><span class="line">        t[<span class="built_in">ls</span>(p)].add = <span class="built_in">max</span>(t[<span class="built_in">ls</span>(p)].add, t[p].add);</span><br><span class="line">        t[<span class="built_in">ls</span>(p)].del = <span class="built_in">max</span>(t[<span class="built_in">ls</span>(p)].del, t[p].add);</span><br><span class="line">        t[<span class="built_in">rs</span>(p)].add = <span class="built_in">max</span>(t[<span class="built_in">rs</span>(p)].add, t[p].add);</span><br><span class="line">        t[<span class="built_in">rs</span>(p)].del = <span class="built_in">max</span>(t[<span class="built_in">rs</span>(p)].del, t[p].add);</span><br><span class="line">        t[p].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t[p].del != INF) &#123;</span><br><span class="line">        t[<span class="built_in">ls</span>(p)].add = <span class="built_in">min</span>(t[<span class="built_in">ls</span>(p)].add, t[p].del);</span><br><span class="line">        t[<span class="built_in">ls</span>(p)].del = <span class="built_in">min</span>(t[<span class="built_in">ls</span>(p)].del, t[p].del);</span><br><span class="line">        t[<span class="built_in">rs</span>(p)].add = <span class="built_in">min</span>(t[<span class="built_in">rs</span>(p)].add, t[p].del);</span><br><span class="line">        t[<span class="built_in">rs</span>(p)].del = <span class="built_in">min</span>(t[<span class="built_in">rs</span>(p)].del, t[p].del);</span><br><span class="line">        t[p].del = INF;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> h, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            t[p].add = <span class="built_in">max</span>(t[p].add, h);</span><br><span class="line">            t[p].del = <span class="built_in">max</span>(t[p].del, h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            t[p].add = <span class="built_in">min</span>(t[p].add, h);</span><br><span class="line">            t[p].del = <span class="built_in">min</span>(t[p].del, h);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(p);</span><br><span class="line">        <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">            <span class="built_in">change</span>(<span class="built_in">ls</span>(p), l, r, h, opt);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">            <span class="built_in">change</span>(<span class="built_in">rs</span>(p), l, r, h, opt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t[p].l &amp;&amp; !t[p].r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (t[p].l == t[p].r)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t[p].add);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(p);</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="built_in">ls</span>(p));</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="built_in">rs</span>(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="built_in">rd</span>(), l = <span class="built_in">rd</span>() + <span class="number">1</span>, r = <span class="built_in">rd</span>() + <span class="number">1</span>, h = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>, l, r, h, opt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> kai586123::<span class="built_in">main</span>(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>JSOI2007文本生成器</title>
    <url>/2019/05/17/jsoi2007%E6%96%87%E6%9C%AC%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4052">[JSOI2007]文本生成器</a> 直接算不好做，求出总方案减去读不到的情况。搞个AC自动机，然后在AC自动机上DP。 利用fail树的性质，如果某个点的祖先是串终点，那么这个点也不能走。可以走的点可以在建AC自动机的时候同时求出来。 在可以走的点上，定义f[i][j]表示跑了i位，在点j停下的方案数。本来应该是向Trie树上的儿子，或者沿着fail向上跳转移，但是因为我们建图的时候优化，直接把Trie树变成了Trie图，所以直接枚举儿子就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span>, MOD = <span class="number">10007</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, ans, ch[N][<span class="number">26</span>], fail[N], num, f[<span class="number">110</span>][N];;</span><br><span class="line"><span class="keyword">bool</span> ed[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ch[now][s[i] - <span class="string">&#x27;A&#x27;</span>])</span><br><span class="line">            ch[now][s[i] - <span class="string">&#x27;A&#x27;</span>] = ++num;</span><br><span class="line">        now = ch[now][s[i] - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ed[now] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>][i])</span><br><span class="line">            que.<span class="built_in">push</span>(ch[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ch[x][i]) &#123;</span><br><span class="line">                ch[x][i] = ch[fail[x]][i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fail[ch[x][i]] = ch[fail[x]][i];</span><br><span class="line">                ed[ch[x][i]] = ed[fail[ch[x][i]]];</span><br><span class="line">                que.<span class="built_in">push</span>(ch[x][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = x * x % MOD)</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * x % MOD;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= num; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; ++k)</span><br><span class="line">                <span class="keyword">if</span> (!ed[ch[j][k]])</span><br><span class="line">                    f[i + <span class="number">1</span>][ch[j][k]] = (f[i + <span class="number">1</span>][ch[j][k]] + f[i][j]) % MOD;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">        ret += f[m][i];</span><br><span class="line">    <span class="keyword">return</span> ret % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        <span class="built_in">insert</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;?&quot; &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; ((<span class="built_in">pow</span>(<span class="number">26</span>, m) - <span class="built_in">dp</span>()) % MOD + MOD) % MOD &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>JSOI2007重要的城市</title>
    <url>/2019/03/02/jsoi2007%E9%87%8D%E8%A6%81%E7%9A%84%E5%9F%8E%E5%B8%82/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1841">[JSOI2007]重要的城市</a> （这篇发的洛谷题解…粘贴过来了 怎么全都是Floyd…提供一个不一样的思路（可能蒟蒻脑回路清奇，第一思路就这个…） 一个城市x重要，当且仅当去掉它之后可以让s-&gt;t的最短路变化（s != t != x)。因为本题的n很小，我们可以枚举n作为s。 当确定s之后，以s为起点跑一次最短路，然后把所有在最短路上的边加入一个新图中。具体做法是：对于一条边，如果它起点处的最短路加上边权等于终点处的最短路，那么就把它加入新图中。 这个新图有一个很好的性质：它是一个DAG。原因很简单，最短路上没环= =。注意到这个最短路DAG记录了s为起点到所有点的最短路。 枚举1~n的每个点。如果存在边x-&gt;y，并且y的入度为1，那么删掉x之后y的入度会变成0，显然无法从s到达，即删掉x之后破坏了一些点的最短路。x就是一个关键点。 时间复杂度：枚举$O(n)$次，计算最短路$O(mlogn)$，求点x$O(m)$。所以总复杂度是$O(nmlogn)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500</span>, M = N * N;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, nxt, c;</span><br><span class="line">&#125; g[M * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    g[++tot].to = y, g[tot].from = x, g[tot].c = c,</span><br><span class="line">    g[tot].nxt = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; que;</span><br><span class="line"><span class="keyword">int</span> dis[N], in[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N], important[N], mark[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, s));</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = que.<span class="built_in">top</span>().second;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!vis[x]) &#123;</span><br><span class="line">            vis[x] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">                <span class="keyword">if</span> (dis[y] &gt; dis[x] + g[i].c) &#123;</span><br><span class="line">                    dis[y] = dis[x] + g[i].c;</span><br><span class="line">                    que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-dis[y], y));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(mark, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(mark));</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(in));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dis[g[i].from] + g[i].c == dis[g[i].to]) &#123;</span><br><span class="line">            mark[i] = <span class="literal">true</span>;</span><br><span class="line">            ++in[g[i].to];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">        <span class="keyword">if</span> (mark[i] &amp;&amp; in[g[i].to] == <span class="number">1</span> &amp;&amp; g[i].from != s)</span><br><span class="line">            important[g[i].from] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>(), c = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">addedge</span>(x, y, c), <span class="built_in">addedge</span>(y, x, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">solve</span>(i);</span><br><span class="line">    <span class="keyword">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (important[i]) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            ok = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ok) cout &lt;&lt; <span class="string">&quot;No important cities.&quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>CSP模拟赛104 T3 最大值 题解</title>
    <url>/2019/11/07/csp%E6%A8%A1%E6%8B%9F%E8%B5%9B104-t3-%E6%9C%80%E5%A4%A7%E5%80%BC-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>我们有一个这样的式子 $$E(x) = \sum_{i} P(i \leq x)$$ 证明: $$E(x) = i P(i) = \sum_{i} iP(x=i) $$ $$ = \sum_{i} i (P(x \geq i) - P(x \leq i+1))$$ 由期望线性性,$E = \sum_i E(max=i)$. 考虑组合意义,可以得到: $$P(x \leq \max_{i=l}^r y_i)$$ $$= 1- \prod_{i=l}^r (1-P(x \leq y_i))$$ 我们考虑如果$x$不存在于$y_i$中,那么$P$不会产生新的值,所以枚举所有$y_i$作$x$,求解答案即可 把上面式子后面$\prod$部分取出来,记作$q$,考虑维护$q$ 把$y_i$从大到小排序,那么插入一个新的$y_i$,只会让$P$一次性增大,可以简单维护.考虑同一个位置只有$\min$可以对答案产生贡献,还要删掉旧的$y$.用vector维护每个位置排序后的点. $$q = q \frac{P_{new&#125;&#125;{P_{old&#125;&#125;$$ 对于期望计算式子里$\sum$,因为不存在的值不影响$P$的结果,乘上就行了 如果是单次询问就做完了,对于多次询问,把询问排序,一个点可以覆盖一个区间的询问.把询问离散成点建立线段树,区间乘,维护区间$q$和即可,不是本题难点.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cerr;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">233</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = (ll)x * x % P)</span><br><span class="line">    <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = (ll)ret * x % P;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, ans, left[N], right[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stone</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x, y, p;</span><br><span class="line">&#125; st[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> l, r;</span><br><span class="line">&#125; qu[N];</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; vec[N];</span><br><span class="line"><span class="keyword">int</span> not_pick[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Stone &amp;a, <span class="keyword">const</span> Stone &amp;b) &#123;</span><br><span class="line">  <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Query &amp;a, <span class="keyword">const</span> Query &amp;b) &#123;</span><br><span class="line">  <span class="keyword">return</span> a.l &lt; b.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(p) p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(p) p &lt;&lt; 1  1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val[N * <span class="number">4</span>], tag[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  val[p] = (val[<span class="built_in">ls</span>(p)] + val[<span class="built_in">rs</span>(p)]) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  val[p] = (ll)val[p] * v % P;</span><br><span class="line">  tag[p] = (ll)tag[p] * v % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tag[p] != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">push</span>(<span class="built_in">ls</span>(p), tag[p]);</span><br><span class="line">    <span class="built_in">push</span>(<span class="built_in">rs</span>(p), tag[p]);</span><br><span class="line">    tag[p] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  tag[p] = val[p] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (L == R)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(<span class="built_in">ls</span>(p), L, mid);</span><br><span class="line">  <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, R);</span><br><span class="line">  <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">push</span>(p, v);</span><br><span class="line">  <span class="built_in">pushdown</span>(p);</span><br><span class="line">  <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">    <span class="built_in">mul</span>(<span class="built_in">ls</span>(p), l, r, v, L, mid);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">    <span class="built_in">mul</span>(<span class="built_in">rs</span>(p), l, r, v, mid + <span class="number">1</span>, R);</span><br><span class="line">  <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cerr &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left[x] &gt; right[x])</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  ll u = (<span class="number">1</span> - (vec[x].<span class="built_in">back</span>() - not_pick[x]) % P + P) % P;</span><br><span class="line">  u = <span class="built_in">fpow</span>(u, P - <span class="number">2</span>);</span><br><span class="line">  vec[x].<span class="built_in">pop_back</span>();</span><br><span class="line">  ll v = (<span class="number">1</span> - (vec[x].<span class="built_in">back</span>() - not_pick[x]) % P + P) % P;</span><br><span class="line"></span><br><span class="line">  u = u * v % P;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mul</span>(<span class="number">1</span>, left[x], right[x], u, <span class="number">1</span>, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;max.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;max.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">  <span class="comment">// freopen(&quot;example_max3.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"></span><br><span class="line">  n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>(), q = <span class="built_in">rd</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, q);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>(), p = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">if</span> (!p  !y)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    st[++cnt] = &#123; x, y, p &#125;;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  std::<span class="built_in">sort</span>(st + <span class="number">1</span>, st + cnt + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    vec[i].<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">    vec[st[i].x].<span class="built_in">push_back</span>((ll)vec[st[i].x].<span class="built_in">back</span>() * (<span class="number">1</span> - st[i].p) % P);</span><br><span class="line">    vec[st[i].x].<span class="built_in">back</span>() = (vec[st[i].x].<span class="built_in">back</span>() + P) % P;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    not_pick[i] = vec[i].<span class="built_in">back</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="built_in">rd</span>(), r = <span class="built_in">rd</span>();</span><br><span class="line">    qu[i] = &#123; l, r &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  std::<span class="built_in">sort</span>(qu + <span class="number">1</span>, qu + q + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l = <span class="number">1</span>, r = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r &amp;&amp; qu[l].r &lt; i)</span><br><span class="line">      ++l;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; q &amp;&amp; qu[r + <span class="number">1</span>].l &lt;= i)</span><br><span class="line">      ++r;</span><br><span class="line">    left[i] = l, right[i] = r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt, j; i &gt;= <span class="number">1</span>; ) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = i; i &gt;= <span class="number">1</span> &amp;&amp; st[i].y == st[j].y; --i)</span><br><span class="line">      <span class="built_in">change</span>(st[i].x);</span><br><span class="line">    ans = (ans + (ll)val[<span class="number">1</span>] * (st[j].y - st[i].y)) % P;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ans = ((ll)st[cnt].y * q - ans) % P;</span><br><span class="line">  ans = (ans % P + P) % P;</span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>HNOI2015菜肴制作</title>
    <url>/2019/02/16/hnoi2015%E8%8F%9C%E8%82%B4%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3243">[HNOI2015]菜肴制作</a> 拓扑排序，把队列换成优先队列。如果正着跑的话，样例中就有过不了的情况：五个点，两个限制，5在2前，4在3前。如果用小根堆拓扑，会先找4，但是明显先找5是正确答案。 题中要求的不是最小字典序，而是编号小的靠前的方案。可以发现如果让编号大的点尽可能靠后是没问题的。于是反向建图，用大根堆拓扑排序即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">0</span>;<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))a=c==<span class="string">&#x27;-&#x27;</span>?<span class="number">0</span>:<span class="number">1</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))b=b*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a?b:-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">200000</span>+<span class="number">2333</span>;<span class="keyword">int</span> T,n,m,head[N],tot,in[N],ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>&#123;</span><span class="keyword">int</span> to,nxt;&#125;g[N];priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt; que;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adddedge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;++in[y],g[++tot].to=y,g[tot].nxt=head[x],head[x]=tot;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)g[i].to=g[i].nxt=head[i]=in[i]=<span class="number">0</span>;ans[<span class="number">0</span>]=tot=<span class="number">0</span>;<span class="keyword">while</span>(!que.<span class="built_in">empty</span>())que.<span class="built_in">pop</span>();&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toposort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="keyword">if</span>(in[i]==<span class="number">0</span>)que.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=que.<span class="built_in">top</span>();que.<span class="built_in">pop</span>();</span><br><span class="line">        ans[++ans[<span class="number">0</span>]]=x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x],y=g[i].to;i;i=g[i].nxt,y=g[i].to)</span><br><span class="line">            <span class="keyword">if</span>(--in[y]==<span class="number">0</span>)que.<span class="built_in">push</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    T=<span class="built_in">rd</span>();<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;<span class="keyword">int</span> x=<span class="built_in">rd</span>(),y=<span class="built_in">rd</span>();<span class="built_in">adddedge</span>(y,x);&#125;</span><br><span class="line">        <span class="built_in">toposort</span>();</span><br><span class="line">        <span class="keyword">if</span>(ans[<span class="number">0</span>]!=n)<span class="built_in">puts</span>(<span class="string">&quot;Impossible!&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;--i)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>Jsoi2010游戏 树形DP</title>
    <url>/2020/01/11/jsoi2010%E6%B8%B8%E6%88%8F-%E6%A0%91%E5%BD%A2dp/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=5024">[Jsoi2010]游戏</a> 考场rush 50分，挂成10分了5555 给一个数列，判断是否合法。 注意到只需要二进制后$3$位，$5^k$在$\mod 8$意义下，$1 \rightarrow 5 \rightarrow 1 \rightarrow 5 …$。注意到$1$和$5$的后两位都是$01$，说明后两位只与和有关，只需关注第三位。 第三位除了被和影响，还会被乘$5^{2k}$的数的第一位影响。如果所有数都是$0$或$1$，显然没有选择，否则可以自由组成想要的$0$或$1$，这是因为对任意方案取反即可得到另一种。 一种方案可以看作一个边上有颜色的三角，$ans = \binom{n}{3} - u$，$u$是不合法方案数量。不合法方案等于三边颜色不全相同的三角。可以枚举两条颜色不同的边计算。 定义$f_{x,i,j,k}, i &lt; 8, j &lt; 4, k &lt; 3$为$x$点，选的数列$\mod 8 = i$，数列的第一位和$\mod 4 = j$，这个数列为全$0$，全$1$，或都有。求出根的方案树，进而换根求出总方案数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, val1[N], val2[N], root;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[N][<span class="number">8</span>][<span class="number">4</span>][<span class="number">3</span>], ans;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> s = (val1[x] + i) &amp; <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">int</span> t = (val2[x] + j) &amp; <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k)</span><br><span class="line">        f[x][s][t][(k == <span class="number">1</span>) != val2[x] ? <span class="number">2</span> : k] += f[y][i][j][k] * v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y : G[x]) &#123;</span><br><span class="line">    <span class="built_in">dfs1</span>(y);</span><br><span class="line">    <span class="built_in">update</span>(x, y, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ++f[x][val1[x]][val2[x]][val2[x]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  --f[x][val1[x]][val2[x]][val2[x]];</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">    tmp += f[x][<span class="number">3</span>][j][<span class="number">0</span>] + f[x][<span class="number">3</span>][j][<span class="number">2</span>] + f[x][<span class="number">7</span>][j][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (j &amp; <span class="number">2</span>)</span><br><span class="line">      tmp += f[x][<span class="number">7</span>][j][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      tmp += f[x][<span class="number">3</span>][j][<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  ans += tmp * (n - tmp - <span class="number">1</span>);</span><br><span class="line">  ++f[x][val1[x]][val2[x]][val2[x]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">get_ans</span>(x);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y : G[x]) &#123;</span><br><span class="line">    <span class="built_in">update</span>(x, y, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">update</span>(y, x, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(y);</span><br><span class="line">    <span class="built_in">update</span>(y, x, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">update</span>(x, y, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> fa = <span class="built_in">rd</span>(), v = <span class="built_in">rd</span>();</span><br><span class="line">    val1[i] = v &amp; <span class="number">7</span>;</span><br><span class="line">    val2[i] = v &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!fa) root = i;</span><br><span class="line">    <span class="keyword">else</span> G[fa].<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs1</span>(root), <span class="built_in">dfs2</span>(root);</span><br><span class="line">  ans = <span class="number">1ll</span> * n * (n - <span class="number">1</span>) * (n - <span class="number">2</span>) / <span class="number">6</span> - ans / <span class="number">2</span>;</span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>JLOI2014松鼠的新家</title>
    <url>/2019/01/05/jloi2014%E6%9D%BE%E9%BC%A0%E7%9A%84%E6%96%B0%E5%AE%B6/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3258">[JLOI2014]松鼠的新家</a> 又是一个LCA树剖都能做的题，想少打点代码还跑的快点，用了LCA+树上差分 根据题意，每次要把两点间所有点值+1。因为除第一次外，每次操作都会把当前起始点多+1（最后一次值不增加，也视为多+1），最后输出时要把这些值-1。 于是建立sum数组，每次把两点+1，LCA与LCA的父亲各-1，操作完成后最后dfs一次输出答案即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span>? <span class="number">0</span>: <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> a? b: -b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300000</span> + <span class="number">2333</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">G</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> to, nxt;</span><br><span class="line">    &#125; g[MAXN * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], tot, dis[MAXN], f[MAXN][<span class="number">20</span>], T, N, v[MAXN], sum[MAXN];</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        g[++tot].to = y, g[tot].nxt = head[x];</span><br><span class="line">        head[x] = tot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="number">1</span>), dis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y = g[i].to; i; i = g[i].nxt, y = g[i].to)</span><br><span class="line">                <span class="keyword">if</span> (!dis[y]) &#123;</span><br><span class="line">                    dis[y] = dis[x] + <span class="number">1</span>, f[y][<span class="number">0</span>] = x, q.<span class="built_in">push</span>(y);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= T; ++j)</span><br><span class="line">                        f[y][j] = f[f[y][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dis[x] &lt; dis[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = T; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            <span class="keyword">if</span> (dis[f[x][i]] &gt;= dis[y])</span><br><span class="line">                x = f[x][i];</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = T; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            <span class="keyword">if</span> (f[x][i] != f[y][i])</span><br><span class="line">                x = f[x][i], y = f[y][i];</span><br><span class="line">        <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y = g[i].to; i; i = g[i].nxt, y = g[i].to)</span><br><span class="line">            <span class="keyword">if</span> (dis[y] == dis[x] + <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">dfs</span>(y), sum[x] += sum[y];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        N = <span class="built_in">rd</span>(), T = <span class="built_in">log2</span>(N) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) v[i] = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">addedge</span>(x, y), <span class="built_in">addedge</span>(y, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = v[i], y = v[i - <span class="number">1</span>], lca = <span class="built_in">query</span>(x, y);</span><br><span class="line">            ++sum[x], ++sum[y], --sum[lca], --sum[f[lca][<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i == v[<span class="number">1</span>]? sum[i]: sum[i] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>JSOI2009计数问题</title>
    <url>/2019/05/30/jsoi2009%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4054">[JSOI2009]计数问题</a> 数据很小，三维树状数组。发现每次只查一个颜色，改成二维树状数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> c[N][N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt;= n; j += <span class="built_in">lowbit</span>(j))</span><br><span class="line">                c[i][j] += v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j; j -= <span class="built_in">lowbit</span>(j))</span><br><span class="line">                ret += c[i][j];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            a[i][j] = <span class="built_in">rd</span>();</span><br><span class="line">            t[a[i][j]].<span class="built_in">add</span>(i, j, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>(), c = <span class="built_in">rd</span>();</span><br><span class="line">            t[a[x][y]].<span class="built_in">add</span>(x, y, <span class="number">-1</span>);</span><br><span class="line">            a[x][y] = c;</span><br><span class="line">            t[a[x][y]].<span class="built_in">add</span>(x, y, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> x1 = <span class="built_in">rd</span>(), x2 = <span class="built_in">rd</span>(), y1 = <span class="built_in">rd</span>(), y2 = <span class="built_in">rd</span>(), c = <span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t[c].<span class="built_in">ask</span>(x2, y2) - t[c].<span class="built_in">ask</span>(x2, y1 - <span class="number">1</span>)</span><br><span class="line">                - t[c].<span class="built_in">ask</span>(x1 - <span class="number">1</span>, y2) + t[c].<span class="built_in">ask</span>(x1 - <span class="number">1</span>, y1 - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>JSOI2019神经网络 树形DP生成函数</title>
    <url>/2020/05/13/jsoi2019%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E6%A0%91%E5%BD%A2dp%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5333">[JSOI2019]神经网络</a> 一条合法的哈密顿路，由两部分组成：每棵树拆成一些独立的链，把链串起来。 考虑如何把树拆成链。令$f_{x,i,0/1/2}$，表示$x$子树内划分为$i$条，并且有$0/1/2$个链连上来。对于子树$y$，是从$y$连上来，对于当前考虑的$x$，是连到$x$的。那么就可以转移了，注意一条链可以有两个端点。 考虑使用EGF求解。第一个树比较特殊，先不管。注意到拼起来之后，不可以有原树上的相邻。那么考虑一个容斥： $$F(x)=\sum_{i=1} \frac{x^i}{i!} \sum_{j=i} \binom{j-1}{i-1}(-1)^{j-i}f_jj!$$ 后面的部分是考虑一下随意拼接，并二项式反演得到的。 对于第一个树，因为已经钦定了起点，就不可以随意排列了。那么有： $$F(x)=\sum_{i=1} \frac{x^{i-1&#125;&#125;{(i-1)!} \sum_{j=i} \binom{j-1}{i-1}(-1)^{j-i}f_jj!$$ 卷起来就是哈密顿路的方案了。这道题要求的是哈密顿环，所以第一个树的还要减去： $$F(x)=\sum_{i=1} \frac{x^{i-2&#125;&#125;{(i-2)!} \sum_{j=i} \binom{j-1}{i-1}(-1)^{j-i}f_jj!$$</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>JSOI2008球形空间产生器</title>
    <url>/2019/02/01/jsoi2008%E7%90%83%E5%BD%A2%E7%A9%BA%E9%97%B4%E4%BA%A7%E7%94%9F%E5%99%A8/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4035">[JSOI2008]球形空间产生器</a> 高斯消元。 令球的半径为$R$，球心坐标为$x_i$，题目给出的点为$a_i,b_i,c_i…$，有： $\sum_{i=1}^{n}(x_{i}-a_{i})^{2}=R^{2} (1)$ $\sum_{i=1}^{n}(x_{i}-b_{i})^{2}=R^{2} (2)$ $(2)-(1)$，得 $\sum_{i=1}^{n}2(a_{i}-b_{i})x_{i}=\sum_{i=1}^{n}a_{i}^{2}-b_{i}^{2}$ 题目给出了$n+1$个点，相减之后正好$n$个，解出$x$即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> a[<span class="number">15</span>][<span class="number">15</span>], b[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            cin &gt;&gt; b[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            a[i][n + <span class="number">1</span>] += <span class="built_in">pow</span>(b[i][j]) - <span class="built_in">pow</span>(b[i + <span class="number">1</span>][j]),</span><br><span class="line">            a[i][j] = <span class="number">2</span> * (b[i][j] - b[i + <span class="number">1</span>][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[j][i]) &gt; <span class="built_in">fabs</span>(a[pos][i]))</span><br><span class="line">                pos = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; ++j)</span><br><span class="line">            <span class="built_in">swap</span>(a[i][j], a[pos][j]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][i]) &lt; eps)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                <span class="keyword">double</span> t = a[j][i] / a[i][i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n + <span class="number">1</span>; ++k)</span><br><span class="line">                    a[j][k] -= a[i][k] * t;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.3f &quot;</span>, a[i][n + <span class="number">1</span>] / a[i][i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>jzptab （求LCM和）</title>
    <url>/2019/06/19/jzptab-%EF%BC%88%E6%B1%82lcm%E5%92%8C%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2693">jzptab</a> 首先这题毒瘤了……看清楚$\mod 1e8+9$。 萌新刚学OI，只好默默推式子（$n \leq m$）： $$\sum_{i=1}^n \sum_{j=1}^mlcm(i,j)$$ 由$lcm$求法， $$\sum_{i=1}^n \sum_{j=1}^m \frac{ij}{gcd(i,j)}$$ 枚举$gcd$， $$\sum_{d=1}^n \sum_{d\mid i}\sum_{d\mid j} \frac{ij}{gcd(i,j)} [gcd(i,j)=d]$$ $$\sum_{d=1}^n d \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor } \sum_{j=1}^{\lfloor \frac{m}{d} \rfloor} ij [gcd(i,j)=1]$$ 把$gcd$用$\mu $写出来： $$\sum_{d=1}^n d \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor } \sum_{j=1}^{\lfloor \frac{m}{d} \rfloor} \sum_{k \mid i, k \mid j} \mu(k) ij$$ 前置$k$的枚举： $$\sum_{d=1}^n d \sum_{k=1}^n \mu(k) k^2 \sum_{i=1}^{\lfloor \frac{n}{kd} \rfloor } \sum_{j=1}^{\lfloor \frac{m}{kd} \rfloor} ij$$ 如果一次询问就可以做了，多次询问继续化简： 令$T=kd$，枚举$T$ $$\sum_{T=1}^n \sum_{i=1}^{\lfloor \frac{n}{T} \rfloor } \sum_{j=1}^{\lfloor \frac{m}{T} \rfloor} ij \sum_{d \mid T} d(\lfloor \frac{T}{d} \rfloor) \mu(\lfloor \frac{T}{d} \rfloor) $$ 令$h(T)=\sum_{d \mid T} d(\lfloor \frac{T}{d} \rfloor) \mu(\lfloor \frac{T}{d} \rfloor)$，发现这玩意是几个积性函数卷起来，还是积性函数。 积性函数可以线性筛。 令$T \in prime$，$h(T)=T-T^2$。 令$i \perp T$，$h(iT)=h(i)h(T)$。 令$i \in prime, i \mid T$，因为带多个$i$的，$\mu$都是$0$，剩下的都乘了$i$，$h(iT)=ih(T)$。 给$h(T)$求一下前缀和，每次就可以分块回答了。 大约是$O(\sqrt n)$？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">2333</span>, P = <span class="number">100000009</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], pri[N], vis[N], tot, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    h[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123; pri[++tot] = i; h[i] = (i - i * i) % P; &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; pri[j] * i &lt; N; ++j) &#123;</span><br><span class="line">            vis[pri[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                h[i * pri[j]] = (pri[j] * h[i]) % P;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> h[i * pri[j]] = (h[i] * h[pri[j]]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) h[i] = (h[i] + h[i - <span class="number">1</span>]) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * (x + <span class="number">1</span>) / <span class="number">2</span> % P; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m; <span class="keyword">if</span> (n &gt; m) <span class="built_in">swap</span>(n, m);</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = <span class="built_in">min</span>(n / (n / l), m / (m / l));</span><br><span class="line">        ans = (ans + <span class="built_in">sum</span>(n / l) * <span class="built_in">sum</span>(m / l) % P * (h[r] - h[l - <span class="number">1</span>])) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (ans % P + P) % P &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(); <span class="keyword">int</span> T; cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>LCS2 - Longest Common Substring II</title>
    <url>/2019/06/18/lcs2-longest-common-substring-ii/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/SP1812">LCS2 - Longest Common Substring II</a> 多串LCS。 对一个串建SAM，用剩下的所有串在上面依次跑，求出SAM上每个节点的答案。 因为parent树上，儿子可以匹配到的，父亲也能匹配到，所以用父亲的答案对儿子取max，再对自己的len取min。 求出所有串对于每个节点的答案之后，因为所有串都匹配到才可以，每个节点取min。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> * <span class="number">2</span> + <span class="number">2333</span>;</span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> fa[N], ch[N][<span class="number">26</span>], len[N], tot = <span class="number">1</span>, last = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = last, np = ++tot;</span><br><span class="line">    last = np; len[np] = len[p] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; !ch[p][c])</span><br><span class="line">        ch[p][c] = np, p = fa[p];</span><br><span class="line">    <span class="keyword">if</span> (!p) fa[np] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> q = ch[p][c];</span><br><span class="line">        <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)</span><br><span class="line">            fa[np] = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> nq = ++tot;</span><br><span class="line">            len[nq] = len[p] + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="built_in"><span class="keyword">sizeof</span></span>(ch[q]));</span><br><span class="line">            fa[nq] = fa[q];</span><br><span class="line">            fa[q] = fa[np] = nq;</span><br><span class="line">            <span class="keyword">while</span> (p &amp;&amp; ch[p][c] == q)</span><br><span class="line">                ch[p][c] = nq, p = fa[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], c[N];</span><br><span class="line"><span class="keyword">int</span> ba[N], ka[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>); n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">insert</span>(s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) ++c[len[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) a[c[len[i]]--] = i;</span><br><span class="line">    <span class="built_in">memset</span>(ka, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ka));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>) != EOF) &#123;</span><br><span class="line">        n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, p = <span class="number">1</span>, now = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span> (p &amp;&amp; !ch[p][c])</span><br><span class="line">                p = fa[p], now = len[p];</span><br><span class="line">            <span class="keyword">if</span> (!p) p = <span class="number">1</span>, now = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> ++now, p = ch[p][c],</span><br><span class="line">                ba[p] = <span class="built_in">max</span>(ba[p], now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tot; i; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = a[i], f = fa[x];</span><br><span class="line">            ba[f] = <span class="built_in">max</span>(ba[f], <span class="built_in">min</span>(ba[x], len[f]));</span><br><span class="line">            ka[x] = <span class="built_in">min</span>(ba[x], ka[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(ba, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ba));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, ka[i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>Life Forms</title>
    <url>/2019/06/13/life-forms/</url>
    <content><![CDATA[<p>求不小于k个字符串中的最长子串 <a href="http://poj.org/problem?id=3294">Life Forms</a> 二分长度，判断有没有k个来自不同串的。 确定长度后，把所有够这么长，且出现了至少k次的全部塞进答案里。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1000</span> + <span class="number">233</span>, N = M * <span class="number">100</span>, S = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, len[<span class="number">110</span>], chuan[N]; <span class="keyword">char</span> ch[M];</span><br><span class="line"><span class="keyword">int</span> s[N], x[N], y[N], sa[N], ht[N], rk[N], c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(s));</span><br><span class="line">    <span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(x));</span><br><span class="line">    <span class="built_in">memset</span>(y, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(y));</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line">    <span class="built_in">memset</span>(rk, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(rk));</span><br><span class="line">    <span class="built_in">memset</span>(sa, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(sa));</span><br><span class="line">    <span class="built_in">memset</span>(ht, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ht));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i] = s[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) sa[c[x[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>, k = <span class="number">1</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>, p = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; ++i) y[++p] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt; k) y[++p] = sa[i] - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[y[i]]]--] = y[i];</span><br><span class="line">        std::<span class="built_in">swap</span>(x, y); x[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            x[sa[i]] = y[sa[i]] == y[sa[i - <span class="number">1</span>]]</span><br><span class="line">                &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]</span><br><span class="line">                ? p : ++p;</span><br><span class="line">        <span class="keyword">if</span> (p == n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, p = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (p &gt; <span class="number">0</span>) --p;</span><br><span class="line">        <span class="keyword">while</span> (s[i + p] == s[j + p]) ++p;</span><br><span class="line">        ht[rk[i]] = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ht[i] &lt; k) &#123;</span><br><span class="line">            tot = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                cnt[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = chuan[sa[i]];</span><br><span class="line">        <span class="keyword">if</span> (x &amp;&amp; ++cnt[x] == <span class="number">1</span>) ++tot;</span><br><span class="line">        <span class="keyword">if</span> (tot &gt;= m / <span class="number">2</span> + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans_st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ans_st[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>; <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ht[i] &lt; k) &#123;</span><br><span class="line">            tot = flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                cnt[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = chuan[sa[i]];</span><br><span class="line">        <span class="keyword">if</span> (x &amp;&amp; ++cnt[x] == <span class="number">1</span>) ++tot;</span><br><span class="line">        <span class="keyword">if</span> (!flag &amp;&amp; tot == m / <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            ans_st[++ans_st[<span class="number">0</span>]] = sa[i];</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n, ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">judge</span>(mid)) l = mid + <span class="number">1</span>, ans = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">-1</span>) &#123; <span class="built_in">puts</span>(<span class="string">&quot;?&quot;</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="built_in">calc</span>(ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ans_st[<span class="number">0</span>]; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = ans_st[i]; j &lt;= ans_st[i] + ans - <span class="number">1</span>; ++j)</span><br><span class="line">            <span class="built_in">putchar</span>(s[j]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ttt = <span class="number">1</span>; ; ++ttt) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        <span class="keyword">if</span> (!m) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ttt != <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="built_in">init</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ch + <span class="number">1</span>);</span><br><span class="line">                len[i] = <span class="built_in">strlen</span>(ch + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len[i]; ++j) &#123;</span><br><span class="line">                    s[++n] = ch[j];</span><br><span class="line">                    chuan[n] = i;</span><br><span class="line">                &#125;</span><br><span class="line">                s[++n] = i + <span class="number">233</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s[n--] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">SA</span>();</span><br><span class="line">            <span class="built_in">solve</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>Little Elephant and Strings</title>
    <url>/2019/06/16/little-elephant-and-strings/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/CF204E">Little Elephant and Strings</a> bzoj的3277 3473也是这个题。 据说这题SA被SAM踩爆，不管了… 如果[l,r]满足条件，[l,r-1]也满足。枚举起点l，二分r。 预处理L(x)，表示[sa[L(x)],sa[x]]里，出现够了k个串。 知道起点和长度之后，可以在sa上二分，找到[x,y]使得区间lcp是长度。如果L(y)&gt;=x，说明满足条件。 $O(nlog^2n)$。 这么写是会在bzoj的古董机上TLE的。 在原串里，如果[l,r]满足条件，那么[l+1,r]也满足条件。利用这个性质，r单调不降，类似求height的方法，直接枚举r就好了。$O(nlogn)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">2333</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k; <span class="keyword">char</span> ch[N];</span><br><span class="line"><span class="keyword">int</span> s[N], bl[N], x[N], y[N], c[N], sa[N], ht[N], rk[N];</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">20</span>], lg[N];</span><br><span class="line"><span class="keyword">int</span> L[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ch + <span class="number">1</span>); <span class="keyword">int</span> len = <span class="built_in">strlen</span>(ch + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len; ++j) s[++n] = ch[j], bl[n] = i;</span><br><span class="line">        s[++n] = i + <span class="number">233</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i] = s[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, p = <span class="number">0</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>, p = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; ++i) y[++p] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (sa[i] &gt; k) y[++p] = sa[i] - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[y[i]]]--] = y[i];</span><br><span class="line">        <span class="built_in">swap</span>(x, y); x[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            x[sa[i]] = y[sa[i]] == y[sa[i - <span class="number">1</span>]]</span><br><span class="line">                &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]</span><br><span class="line">                ? p : ++p;</span><br><span class="line">        <span class="keyword">if</span> (p == n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, p = <span class="number">0</span>, j; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (p) --p;</span><br><span class="line">        <span class="keyword">while</span> (s[i + p] == s[j + p]) ++p;</span><br><span class="line">        ht[rk[i]] = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) st[i][<span class="number">0</span>] = ht[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">17</span>; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i)</span><br><span class="line">            st[i][j] = <span class="built_in">min</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>, p = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bl[sa[i]]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (++cnt[bl[sa[i]]] == <span class="number">1</span>) ++j;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= k) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j - (cnt[bl[sa[p]]] == <span class="number">1</span>) &gt;= k) &#123;</span><br><span class="line">                j -= !(--cnt[bl[sa[p++]]]);</span><br><span class="line">            &#125;</span><br><span class="line">            L[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = lg[y - x + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(st[x][t], st[y - (<span class="number">1</span> &lt;&lt; t) + <span class="number">1</span>][t]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r, mid, left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ht[x + <span class="number">1</span>] &lt; y) right = x;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        l = x + <span class="number">1</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">lcp</span>(x + <span class="number">1</span>, mid) &gt;= y)</span><br><span class="line">                l = mid + <span class="number">1</span>, right = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ht[x] &lt; y) left = x;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        l = <span class="number">1</span>, r = x - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">lcp</span>(mid + <span class="number">1</span>, x) &gt;= y)</span><br><span class="line">                r = mid - <span class="number">1</span>, left = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L[right] &gt;= left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>; <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bl[i]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, ans);</span><br><span class="line">            p = <span class="number">0</span>;</span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p) --p;</span><br><span class="line">            <span class="keyword">while</span> (bl[i + p] &amp;&amp; <span class="built_in">check</span>(rk[i], p + <span class="number">1</span>))</span><br><span class="line">                ++p;</span><br><span class="line">            ans += p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(); <span class="built_in">build</span>(); <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>LNOI2014 LCA</title>
    <url>/2019/07/23/lnoi2014-lca/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4211">[LNOI2014]LCA</a> 首先LCA到根的路径，可以就是两个点分别向根走一次，共同经过的路径。 把询问离线，拆成一加一减，然后树剖+线段树随便做。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50000</span> + <span class="number">2333</span>, MOD = <span class="number">201314</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125; g[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    g[++tot].to = y, g[tot].nxt = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N], top[N], son[N], size[N], num, dep[N], id[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fat)</span> </span>&#123;</span><br><span class="line">    fa[x] = fat; size[x] = <span class="number">1</span>; dep[x] = dep[fat] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="keyword">if</span> (y != fat) &#123;</span><br><span class="line">            <span class="built_in">dfs1</span>(y, x);</span><br><span class="line">            <span class="keyword">if</span> (size[son[x]] &lt; size[y])</span><br><span class="line">                son[x] = y;</span><br><span class="line">            size[x] += size[y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line">    top[x] = topf; id[x] = ++num;</span><br><span class="line">    <span class="keyword">if</span> (son[x]) &#123;</span><br><span class="line">        <span class="built_in">dfs2</span>(son[x], topf);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">            <span class="keyword">if</span> (y != son[x] &amp;&amp; y != fa[x])</span><br><span class="line">                <span class="built_in">dfs2</span>(y, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum[N * <span class="number">4</span>], lazy[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(p) p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(p) p &lt;&lt; 1  1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R) &#123;</span><br><span class="line">        sum[p] = (sum[p] + v * (R - L + <span class="number">1</span>)) % MOD;</span><br><span class="line">        lazy[p] += v;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">add</span>(<span class="built_in">ls</span>(p), L, mid, lazy[p], L, mid);</span><br><span class="line">        <span class="built_in">add</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, R, lazy[p], mid + <span class="number">1</span>, R);</span><br><span class="line">        lazy[p] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">            <span class="built_in">add</span>(<span class="built_in">ls</span>(p), l, r, v, L, mid);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">            <span class="built_in">add</span>(<span class="built_in">rs</span>(p), l, r, v, mid + <span class="number">1</span>, R);</span><br><span class="line">        sum[p] = (sum[<span class="built_in">ls</span>(p)] + sum[<span class="built_in">rs</span>(p)]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R) &#123;</span><br><span class="line">        <span class="keyword">return</span> sum[p];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">add</span>(<span class="built_in">ls</span>(p), L, mid, lazy[p], L, mid);</span><br><span class="line">        <span class="built_in">add</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, R, lazy[p], mid + <span class="number">1</span>, R);</span><br><span class="line">        lazy[p] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">            ret += <span class="built_in">ask</span>(<span class="built_in">ls</span>(p), l, r, L, mid);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">            ret += <span class="built_in">ask</span>(<span class="built_in">rs</span>(p), l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">        <span class="keyword">return</span> ret % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">range_add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]])</span><br><span class="line">            std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">1</span>, id[top[x]], id[x], <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; dep[y])</span><br><span class="line">        std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>, id[x], id[y], <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">range_ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]])</span><br><span class="line">            std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">        ret = (ret + <span class="built_in">ask</span>(<span class="number">1</span>, id[top[x]], id[x], <span class="number">1</span>, n)) % MOD;</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; dep[y])</span><br><span class="line">        std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    ret += <span class="built_in">ask</span>(<span class="number">1</span>, id[x], id[y], <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">return</span> ret % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, z, id, o;</span><br><span class="line">&#125; qu[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> Query &amp;a, <span class="keyword">const</span> Query &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(), q = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">addedge</span>(<span class="built_in">rd</span>() + <span class="number">1</span>, i);</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">rd</span>() + <span class="number">1</span>, r = <span class="built_in">rd</span>() + <span class="number">1</span>, z = <span class="built_in">rd</span>() + <span class="number">1</span>;</span><br><span class="line">        qu[++j].x = l - <span class="number">1</span>, qu[j].z = z, qu[j].id = i, qu[j].o = <span class="number">-1</span>;</span><br><span class="line">        qu[++j].x = r, qu[j].z = z, qu[j].id = i, qu[j].o = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(qu + <span class="number">1</span>, qu + q * <span class="number">2</span> + <span class="number">1</span>, comp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">range_add</span>(<span class="number">1</span>, i);</span><br><span class="line">        <span class="keyword">while</span> (qu[j].x &lt; i) ++j;</span><br><span class="line">        <span class="keyword">while</span> (qu[j].x == i) &#123;</span><br><span class="line">            ans[qu[j].id] = (ans[qu[j].id] + <span class="built_in">range_ask</span>(<span class="number">1</span>, qu[j].z) * qu[j].o) % MOD;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (ans[i] % MOD + MOD) % MOD);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>Luogu P2568 GCD</title>
    <url>/2019/04/03/luogu-p2568-gcd/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2568">GCD</a> 第一次写这种题…这题正好$i$和$j$的范围都是$n$，可以这么做，如果不一样只能莫比乌斯反演了…（蒟蒻当然不会啦）。 $$\sum_{i=1}^n \sum_{j=1}^n [gcd(i,j) == p], p \in prime$$ 把$p$提取出来 $$\sum_{p \in prime}\sum_{i=1}^{\lfloor n / p \rfloor} \sum_{j=1}^{\lfloor n / p \rfloor} [gcd(i,j) == 1]$$ 套路一下改变$j$的范围（同[SDOI2008]仪仗队） $$\sum_{p \in prime} (\sum_{i=1}^{\lfloor n / p \rfloor} (2\sum_{j=1}^{i} [gcd(i,j) == 1]) - 1)$$ 这个$-1$是因为$i=j$时会重复计算。 发现里面就是一个$\varphi$。 $$\sum_{p \in prime} (2\sum_{i=1}^{\lfloor n / p \rfloor} \varphi(i) - 1)$$ 线性筛一下$\varphi$，求个前缀和，枚举$p$求答案。复杂度$O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">2333</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, pri[N], phi[N], tot, sum[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eular</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">            pri[++tot] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * pri[j] &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            vis[i * pri[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                phi[i * pri[j]] = phi[i] * pri[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> phi[i * pri[j]] = phi[i] * (pri[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + phi[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">eular</span>();</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">        ans += <span class="number">2</span> * sum[n / pri[i]] - <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>LOJ6509 雅礼集训 2018 Day7 C DP线性消元</title>
    <url>/2020/05/26/loj6509-%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD-2018-day7-c-dp%E7%BA%BF%E6%80%A7%E6%B6%88%E5%85%83/</url>
    <content><![CDATA[<p><a href="https://loj.ac/problem/6509">「雅礼集训 2018 Day7」C</a> 考虑一个乱走的过程，可以发现在某个点，除了最后一步（停止），每一步的期望长度都是所在的点到所有点距离的平均数。 那么考虑记录每个点走了多少次。热动分析一下发现所有同色点的期望次数都是一样的。 那么搞一个DP，令$f_{i,0/1}$表示有$i$个$1$，$0/1$期望走多少次（对于一个点）。这个DP是倒序的，也就是令全是某个数为边界倒推。 $$f_{i,0} = \frac{i}{n} f_{i-1,0} + \frac{n-i-1}{n} f_{i+1,0} + \frac{1}{n} f_{i+1,1} + \frac{1}{n}$$ $$f_{i,1}= \frac{i-1}{n} f_{i-1,1} + \frac{1}{n} f_{i-1,0} + \frac{n-i}{n} f_{i+1,1} + \frac{1}{n}$$ 这个式子的意思是这样的：以第一个为例，有一定概率走到$1$，那么无贡献，继承即可。有一定概率走到$0$，继承其它点，并加上走到的那个点的贡献。 注意一个边界问题：因为考虑的是非最后一次，当只剩下一个点并翻转它的时候，不能加$\frac{1}{n}$。 移项之后可以由$i-1,i$推出$i+1$。注意到当$i=0,i=n$时，期望次数是$0$。那么直接设每一项是$xf_{1,0}+yf_{1,1}+z$，推到边界，解出即可。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>Long Long Message</title>
    <url>/2019/06/13/long-long-message/</url>
    <content><![CDATA[<p>求两个字符串长度不小于 k 的公共子串的个数（可以相同）。 <a href="http://poj.org/problem?id=2774">Long Long Message</a> 这题题目描述过于感人23333333333 最大公共子串一定体现在height数组里。扫描height，如果相邻两个后缀不在一个原串里，更新答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200000</span> + <span class="number">233</span>, S = <span class="number">233</span>;</span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> n, q, ans;</span><br><span class="line"><span class="keyword">int</span> x[N], y[N], c[N], sa[N], rk[N], ht[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    s[q = (n + <span class="number">1</span>)] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + n + <span class="number">2</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i] = s[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) sa[c[x[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, p = <span class="number">0</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>, p = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; ++i) y[++p] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt; k) y[++p] = sa[i] - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[y[i]]]--] = y[i];</span><br><span class="line">        <span class="built_in">swap</span>(x, y); x[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            x[sa[i]] = y[sa[i]] == y[sa[i - <span class="number">1</span>]]</span><br><span class="line">                &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]</span><br><span class="line">                ? p : ++p;</span><br><span class="line">        <span class="keyword">if</span> (p == n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, p = <span class="number">0</span>, j; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (p) --p;</span><br><span class="line">        <span class="keyword">while</span> (s[i + p] == s[j + p]) ++p;</span><br><span class="line">        ht[rk[i]] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> ((sa[i] &lt; q &amp;&amp; sa[i - <span class="number">1</span>] &gt; q)  (sa[i] &gt; q &amp;&amp; sa[i - <span class="number">1</span>] &lt; q))</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, ht[i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>manacher算法与回文自动机</title>
    <url>/2019/01/07/manacher%E7%AE%97%E6%B3%95%E4%B8%8E%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<p>manacher算法，是用来O(N)求出最长回文子串的算法。 首先一段回文串对称中心有可能是一个字符，也有可能是两个字符中间。我们通过在两个字符之间添加额外的字符解决这个问题，使对称中心一定在一个字符上。 已知一个大回文串[i … mid … j]，里面存在一个对称中心为k的小回文串。我们可以知道以下性质<strong>（注意以下结论成立前提是在大回文串内）</strong>：</p>
<ul>
<li>回文串内部关于对称中心对称，即[i … mid]与[j … mid]对称。</li>
<li>回文串内取一点，可以找出一个与其关于mid对称的点。同样，在回文串内取一段区间，可以找出一段与其关于mid对称的区间。</li>
<li>对于点k，一定存在点k’，二者关于mid对称。也存在以k’为中心的回文串与k回文串关于mid对称。</li>
<li>k与k’对称，(k + k’) / 2 = mid，k = mid * 2 - k’。</li>
</ul>
<p>我们记录每个位置最长回文串长度p[]，当前已知最靠右的回文串的对称中心mid，与右端点ri。 对于mid &lt;= i &lt; r，p[i] &gt;= min(p[mid * 2 - i], ri - i)。所以对于点i我们不必从i两端向外扩展，可以直接找出一段已知对称区间，然后暴力扩展。显然最终答案为max{p[i]} - 1。 <a href="https://www.luogu.org/problemnew/show/P3805">manacher算法模板题</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">11000000</span> * <span class="number">2</span> + <span class="number">233333</span>;</span><br><span class="line"><span class="keyword">char</span> a[MAXN] = &#123;<span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;#&#x27;</span>&#125;, c;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>, p[MAXN], ans, mid, ri;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isalpha</span>(c))</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isalpha</span>(c))</span><br><span class="line">        a[++cnt] = c, a[++cnt] = <span class="string">&#x27;#&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; ri)</span><br><span class="line">            p[i] = <span class="built_in">min</span>(p[mid * <span class="number">2</span> - i], ri - i);</span><br><span class="line">        <span class="keyword">else</span> p[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (a[i - p[i]] == a[i + p[i]])</span><br><span class="line">            ++p[i]; </span><br><span class="line">        <span class="keyword">if</span> (p[i] + i &gt; ri) ri = p[i] + i, mid = i;</span><br><span class="line">        <span class="keyword">if</span> (p[i] &gt; ans) ans = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>回文自动机：挖个坑改日再更</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>Lydsy1705月赛棋盘上的守卫 Kruskal</title>
    <url>/2019/11/06/lydsy1705%E6%9C%88%E8%B5%9B%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E5%AE%88%E5%8D%AB-kruskal/</url>
    <content><![CDATA[<p>费用流显然是不行的…不过根据网格图套路,我们可以建出一张行列为点的图来. 考虑如何表示方向.可以把一个点到另一个点的有向边,看作守卫了后面那个点的一行.要守卫所有行列,即每个点入度都为1,是外向树森林. 用Kruskal维护MST即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">2333</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, fa[N], cir[N], tot;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x, y, c;</span><br><span class="line">&#125; e[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b) &#123;</span><br><span class="line">  <span class="keyword">return</span> a.c &lt; b.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; ++i)</span><br><span class="line">    fa[i] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e[++tot].c);</span><br><span class="line">      e[tot].x = i, e[tot].y = n + j;</span><br><span class="line">    &#125;</span><br><span class="line">  std::<span class="built_in">sort</span>(e + <span class="number">1</span>, e + n * m + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">find</span>(e[i].x), y = <span class="built_in">find</span>(e[i].y);</span><br><span class="line">    <span class="keyword">if</span> (cir[x] &amp;&amp; cir[y])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == y)</span><br><span class="line">      cir[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      fa[x] = y;</span><br><span class="line">      cir[y] = cir[x];</span><br><span class="line">    &#125;</span><br><span class="line">    ans += e[i].c;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>Miller Rabin学习笔记</title>
    <url>/2019/07/25/miller-rabin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>嗯。。。</p>
<h4 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h4><p>$$(a,p)=1,a^{p-1} \equiv 1 \pmod p$$ 火星人都知道。</p>
<h4 id="费马测试"><a href="#费马测试" class="headerlink" title="费马测试"></a>费马测试</h4><p>选$a$，如果满足上式，$p$是质数。 然而这是不一定正确的，反例：$p=341=11 \times 31$</p>
<h4 id="二次探测定理"><a href="#二次探测定理" class="headerlink" title="二次探测定理"></a>二次探测定理</h4><p>$$p &gt; 2, p \in prime,a^2 \equiv 1 \pmod p$$ 此时有一个结论： $$a \equiv 1 \ or \ a \equiv p - 1 \pmod p$$</p>
<h5 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h5><p>$$a^2 \equiv 1 \pmod p$$ $$a^2 - 1\equiv 0 \pmod p$$ $$(a+1)(a-1) \equiv 0 \pmod p$$ $$p \mid (a + 1) \ or \ p \mid (a - 1)$$ 假设： $$ \nmid (a + 1) \ and \ p \nmid (a - 1), p \mid (a+1)(a-1)$$ 那么$p$的一部分质因子在$a+1$中，一部分在$a-1$中。 即： $$(a+1,p) &gt; 1, (a-1,p) &gt; 1$$ 显然不成立。</p>
<h4 id="Miller-Rabin"><a href="#Miller-Rabin" class="headerlink" title="Miller Rabin"></a>Miller Rabin</h4><p>要测试的数是$n$ $$n = 2^k \times t$$ 选取一些$a$ 若 $$n \in prime$$ 一定在 $$a^{2^x \times t} \equiv 1 \pmod n$$ 的时候，当满足： $$a^{2^x \times t} \equiv 1 \pmod n$$ 则有： $$a^{2^x \times (t-1)} \equiv 1 \ or \ a^{2^x \times (t-1)} \equiv n - 1 \pmod n$$ $a$选几个小质数，在OI范围内，已经可以百分百正确了。 <a href="https://www.luogu.org/problem/P3383">【模板】线性筛素数</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = (<span class="keyword">long</span> <span class="keyword">long</span>)x * x % p)</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = (<span class="keyword">long</span> <span class="keyword">long</span>)ret * x % p;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num_bin[<span class="number">5</span>] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">miller_rabin</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> t = n - <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!(t &amp; <span class="number">1</span>)) t &gt;&gt;= <span class="number">1</span>, ++k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == num_bin[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">fpow</span>(num_bin[i], t, n);</span><br><span class="line">        <span class="comment">// 二次探测定理 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, next = x; j &lt;= k; ++j) &#123;</span><br><span class="line">            next = (<span class="keyword">long</span> <span class="keyword">long</span>)x * x % n;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="number">1</span> &amp;&amp; x != <span class="number">1</span> &amp;&amp; x != n - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            x = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="number">1</span>) <span class="comment">// 费马小定理 </span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, x; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), <span class="built_in">puts</span>(<span class="built_in">miller_rabin</span>(x) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>Maximum repetition substring</title>
    <url>/2019/06/13/maximum-repetition-substring/</url>
    <content><![CDATA[<p>求一个字符串的循环次数最多的循环同构子串，其次满足字典序最小。 <a href="http://poj.org/problem?id=3693">Maximum repetition substring</a> 先解决第一个条件。枚举循环节长度i。如果确定了循环串的开头在x，那么lcp(x,x+i)就可以求。但是如果枚举每个位置，必TLE。 可以换成枚举[1,i] [i+1,2i+1]…。这样，枚举到的位置不一定是开头。向前向后分别求一次lcp，就凑出来了。如果长度是L，就循环了L/i+1次。 L模i不一定为0。实际上可以构造这样一个串：abaabaabaa，循环节可以是aba，也可以是baa，长度都是3。这提示我们，循环串的开头位置是一个区间。如果从i-1向左的lcp是l，从i向右的lcp是r，[i-l,i-l+(l+r)%i]都可以做开头。 判断两串大小，比较rank即可。找出区间内rank最小值，作为最小串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">233</span>, S = <span class="number">233</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">char</span> s[N], rs[N]; <span class="keyword">int</span> n, lg2[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SA</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x[N], y[N], c[N], sa[N], ht[N], rk[N];</span><br><span class="line">    <span class="keyword">int</span> st[N][<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i] = s[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[i]]--] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, p = <span class="number">0</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>, p = <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; ++i) y[++p] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">                <span class="keyword">if</span> (sa[i] &gt; k) y[++p] = sa[i] - k;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[y[i]]]--] = y[i];</span><br><span class="line">            <span class="built_in">swap</span>(x, y); x[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">                x[sa[i]] = y[sa[i]] == y[sa[i - <span class="number">1</span>]]</span><br><span class="line">                    &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]</span><br><span class="line">                    ? p : ++p;</span><br><span class="line">            <span class="keyword">if</span> (p == n) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rk[sa[i]] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, p = <span class="number">0</span>, j; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (p) --p;</span><br><span class="line">            <span class="keyword">while</span> (s[i + p] == s[j + p]) ++p;</span><br><span class="line">            ht[rk[i]] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) st[i][<span class="number">0</span>] = ht[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">17</span>; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i)</span><br><span class="line">                st[i][j] = <span class="built_in">min</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lcp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">bool</span> opt = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">0</span>) &#123;</span><br><span class="line">            x = rk[x]; y = rk[y];</span><br><span class="line">            <span class="keyword">if</span> (x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">            ++x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lg = lg2[y - x + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(st[x][lg], st[y - (<span class="number">1</span> &lt;&lt; lg) + <span class="number">1</span>][lg]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; a, b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmq</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lg = lg2[y - x + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(st[x][lg], st[y - (<span class="number">1</span> &lt;&lt; lg) + <span class="number">1</span>][lg]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rs[i] = s[n - i + <span class="number">1</span>];</span><br><span class="line">    a.<span class="built_in">calc</span>(s); b.<span class="built_in">calc</span>(rs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) st[i][<span class="number">0</span>] = a.rk[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">17</span>; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i)</span><br><span class="line">            st[i][j] = <span class="built_in">min</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, mxmx = INF, L = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j + i &lt;= n; j += i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] != s[j + i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> l = b.<span class="built_in">lcp</span>(n - j + <span class="number">2</span>, n - j - i + <span class="number">2</span>), r = a.<span class="built_in">lcp</span>(j, j + i);</span><br><span class="line">            <span class="keyword">if</span> ((l + r) / i + <span class="number">1</span> &gt; mx) &#123;</span><br><span class="line">                mx = (l + r) / i + <span class="number">1</span>;</span><br><span class="line">                mxmx = INF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((l + r) / i + <span class="number">1</span> == mx) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; </span></span><br><span class="line">                <span class="keyword">int</span> t = <span class="built_in">rmq</span>(j - l, j - l + (l + r) % i);</span><br><span class="line">                <span class="keyword">if</span> (t &lt; mxmx) &#123;</span><br><span class="line">                    mxmx = t;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; a.sa[t] &lt;&lt; endl;</span></span><br><span class="line">                    L = a.sa[t]; R = L + mx * i - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; ++i)</span><br><span class="line">        <span class="built_in">putchar</span>(s[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) lg2[i] = <span class="built_in">log2</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; ; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Case %d: &quot;</span>, i);</span><br><span class="line">            <span class="built_in">solve</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOI1999生日蛋糕</title>
    <url>/2019/01/05/noi1999%E7%94%9F%E6%97%A5%E8%9B%8B%E7%B3%95/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1731">NOI1999 生日蛋糕</a> 下午在机房+晚上在家，终于干掉了，果然我是蒟蒻…… 思路：DFS+剪枝</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> min_v[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> ans=INF;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> r,<span class="keyword">int</span> h,<span class="keyword">int</span> V,<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(V==N) ans=<span class="built_in">min</span>(ans,S);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(V+min_v[m]&gt;N) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(S+(N-V)/r*<span class="number">2</span>&gt;ans) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;mh&lt;m) <span class="keyword">return</span>;</span><br><span class="line">    rint s,v;</span><br><span class="line">    <span class="keyword">for</span>(rint i=r;i&gt;=m;--i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(rint j=h;j&gt;=m;--j)&#123;</span><br><span class="line">            v=V+i*i*j;</span><br><span class="line">            s=S+i*<span class="number">2</span>*j;</span><br><span class="line">            <span class="keyword">if</span>(m==M) s+=i*i;</span><br><span class="line">            <span class="built_in">dfs</span>(m<span class="number">-1</span>,i<span class="number">-1</span>,j<span class="number">-1</span>,v,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(rint i=<span class="number">1</span>;i&lt;<span class="number">20</span>;++i)&#123;</span><br><span class="line">        min_v[i]=min_v[i<span class="number">-1</span>]+i*i*i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r=(N-min_v[M<span class="number">-1</span>])/M,h=r/M;</span><br><span class="line">    <span class="built_in">dfs</span>(M,r,h,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ans==INF) cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;ans;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOI Online#3优秀子序列 集合幂级数exp</title>
    <url>/2020/05/28/noi-online3%E4%BC%98%E7%A7%80%E5%AD%90%E5%BA%8F%E5%88%97-%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0exp/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6570">[NOI Online#3]优秀子序列</a> 首先易知$i \And j=0$等价于$i j = i +j$。于是就是子集卷积。$O(3^n)$卷一下就行了。注意特判$0$。考场代码不知道为什么60分 考虑使用形式幂级数。冷静分析一下：首先一个数不能选两次，因此随便选$k$次，除以$k!$，就得到了$k$个数的方案数。可以发现$k \leq n$。 答案写出来就是$G(x) = 1 + \sum_{i \geq 1} \frac{F(x)^i}{i!}$，发现这玩意和$e^{F(x)}$一模一样。于是$\exp$就好了。 注意到$n$非常小，直接考虑暴力$\exp$。$B=e^A \rightarrow B’ = A’ e^A \rightarrow B = \int A’B$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cerr;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>, P = <span class="number">1e9</span> + <span class="number">7</span>, lim = <span class="number">1</span> &lt;&lt; <span class="number">18</span>, L = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">  x -= P, x += x &lt; <span class="number">0</span> ? P : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, A[N], pr[N], tot, vis[N], phi[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  phi[<span class="number">1</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= lim; ++i) &#123;</span><br><span class="line">    <span class="built_in">check</span>(inv[i] = P - <span class="number">1ll</span> * P / i * inv[P % i] % P);</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">      pr[++tot] = i;</span><br><span class="line">      phi[i] = i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * pr[j] &lt;= lim; ++j) &#123;</span><br><span class="line">      vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (!(i % pr[j])) &#123;</span><br><span class="line">        phi[i * pr[j]] = phi[i] * pr[j];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      phi[i * pr[j]] = phi[i] * phi[pr[j]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fwt</span><span class="params">(<span class="keyword">int</span> f[], <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += i &lt;&lt; <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k)</span><br><span class="line">        o == <span class="number">1</span> ? <span class="built_in">check</span>(f[i + j + k] += f[j + k]) : <span class="built_in">check</span>(f[i + j + k] += P - f[j + k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[L + <span class="number">1</span>][N], g[L + <span class="number">1</span>][N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; ++i)</span><br><span class="line">    f[__builtin_popcount(i)][i] = A[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= L; ++i) &#123;</span><br><span class="line">    <span class="built_in">fwt</span>(f[i], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; ++j)</span><br><span class="line">      f[i][j] = <span class="number">1ll</span> * f[i][j] * i % P;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) &#123;</span><br><span class="line">    g[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= L; ++j) &#123;</span><br><span class="line">      <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= j; ++k)</span><br><span class="line">        tmp = (tmp + <span class="number">1ll</span> * f[k][i] * g[j - k][i]) % P;</span><br><span class="line">      g[j][i] = <span class="number">1ll</span> * tmp * inv[j] % P;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= L; ++i)</span><br><span class="line">    <span class="built_in">fwt</span>(g[i], <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    ans = (ans + <span class="number">1ll</span> * g[__builtin_popcount(i)][i] * phi[i + <span class="number">1</span>]) % P;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A[<span class="number">0</span>]; ++i)</span><br><span class="line">    ans = ans * <span class="number">2</span> % P;</span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    ++A[<span class="built_in">rd</span>()];</span><br><span class="line">  <span class="built_in">init</span>(), <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOI2001炮兵阵地</title>
    <url>/2019/04/26/noi2001%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2704">[NOI2001]炮兵阵地</a> 状压DP大水题。 定义f[x][y][i]，表示第i行，状态为x，第i-1行状态为y。转移方程显然：f[x][y][i]=max{f[y][z][i-1]+sum[x]}。其中sum[x]表示x状态的1数量。 判断某方案一行内是否可行，把x与一下x移一位，x移2位，都是0就行了。判断两行更简单，与一下。 这题甚至不需要滚动数组。预处理一下一行内可行状态，发现m=10时也只有60种，开个60_60_100的数组就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, mp[<span class="number">200</span>], f[<span class="number">65</span>][<span class="number">65</span>][<span class="number">20</span>], sum[<span class="number">65</span>], ok[<span class="number">65</span>], cnt, ans;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; ch;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">            <span class="keyword">if</span> (ch[j] == <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">                mp[i] = <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!(i &amp; (i &lt;&lt; <span class="number">1</span>)) &amp;&amp; !(i &amp; (i &lt;&lt; <span class="number">2</span>)) &amp;&amp; !(i &amp; (i &gt;&gt; <span class="number">1</span>)) &amp;&amp; !(i &amp; (i &gt;&gt; <span class="number">2</span>))) &#123;</span><br><span class="line">            ok[++cnt] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j; j &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> (j &amp; <span class="number">1</span>) ++sum[cnt];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!(ok[i] &amp; mp[<span class="number">0</span>]))</span><br><span class="line">            f[i][<span class="number">0</span>][<span class="number">0</span>] = sum[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++j)</span><br><span class="line">            <span class="keyword">if</span> (!(ok[j] &amp; mp[<span class="number">1</span>]) &amp;&amp; !(ok[i] &amp; ok[j]))</span><br><span class="line">                f[j][i][<span class="number">1</span>] = <span class="built_in">max</span>(f[j][i][<span class="number">1</span>], f[i][<span class="number">0</span>][<span class="number">0</span>] + sum[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++j)</span><br><span class="line">            <span class="keyword">if</span> (!(ok[j] &amp; mp[i]))</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= cnt; ++k)</span><br><span class="line">                    <span class="keyword">if</span> (!(ok[j] &amp; ok[k]))</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= cnt; ++t)</span><br><span class="line">                            <span class="keyword">if</span> (!(ok[j] &amp; ok[t]) &amp;&amp; !(ok[k] &amp; ok[t]))</span><br><span class="line">                                f[j][k][i] = <span class="built_in">max</span>(f[j][k][i], f[k][t][i - <span class="number">1</span>] + sum[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++j)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, f[i][j][n - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOI2009植物大战僵尸</title>
    <url>/2019/04/11/noi2009%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2805">[NOI2009]植物大战僵尸</a> 最大权闭合子图入门题。 把题目中的植物向左边的植物和可以攻击到的植物连边，构成了一张图。显然环是无敌的，去掉即可。我们需要在剩下的环上找出可以取到的最大值。 闭合子图，是有向图一个子图，其中所有点出边指向的点还在子图内。这道题中如果要攻击一个植物，要把连向它的植物都打掉，即一个闭合子图。本题要求出最大权闭合子图。 从S向所有val&gt;=0的点连val，所有val&lt;0的点向T连-val，图中原有的边连INF。最大权=正val和-最小割=正val和-最大流。 这里只感性的理解一下：显然INF都不会被割掉，最小割中割掉的边都是和S或T连着的。割掉和S的连接表示不选，割掉和T的连接表示选的代价。割的最少时选中的最大，然后我们都知道最小割=最大流。最大权闭合子图的具体证明可以看国集论文。 所以这题只需要先建个图出来，拓扑排序去掉环，然后跑个最大流就行了。 代码写的特别丑仅供参考…（</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123&#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">0</span>; <span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) a=c==<span class="string">&#x27;-&#x27;</span>?<span class="number">0</span>:<span class="number">1</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) b=b*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a?b:-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S=<span class="number">50</span>,N=<span class="number">233333</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt,flow;</span><br><span class="line">&#125;g[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N],tot=<span class="number">1</span>,n,m,id[S][S],num,s=++num,t=++num,</span><br><span class="line">    val[N],in[N],sum,que[N*<span class="number">10</span>],l,r,dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; gg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    g[++tot].to=y,g[tot].nxt=head[x],</span><br><span class="line">    g[tot].flow=f,head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="built_in">addedge</span>(x,y,f);</span><br><span class="line">    <span class="built_in">addedge</span>(y,x,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    dis[que[l=<span class="number">0</span>,r=<span class="number">1</span>]=s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l!=r)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=que[++l];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=g[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i].flow&amp;&amp;!dis[g[i].to])&#123;</span><br><span class="line">                dis[g[i].to]=dis[x]+<span class="number">1</span>;</span><br><span class="line">                que[++r]=g[i].to;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> mf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==t) <span class="keyword">return</span> mf;</span><br><span class="line">    <span class="keyword">int</span> used=<span class="number">0</span>,tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=g[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(g[i].flow&amp;&amp;dis[g[i].to]==dis[x]+<span class="number">1</span>)&#123;</span><br><span class="line">            tmp=<span class="built_in">dfs</span>(g[i].to,<span class="built_in">min</span>(g[i].flow,mf-used));</span><br><span class="line">            used+=tmp,g[i].flow-=tmp,g[i^<span class="number">1</span>].flow+=tmp;</span><br><span class="line">            <span class="keyword">if</span>(!tmp) dis[g[i].to]=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(used==mf) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!used) dis[x]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">            id[i][j]=++num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            val[id[i][j]]=<span class="built_in">rd</span>();</span><br><span class="line">            <span class="keyword">int</span> cnt=<span class="built_in">rd</span>();</span><br><span class="line">            <span class="keyword">while</span>(cnt--)&#123;</span><br><span class="line">                <span class="keyword">int</span> x=<span class="built_in">rd</span>()+<span class="number">1</span>,y=<span class="built_in">rd</span>()+<span class="number">1</span>;</span><br><span class="line">                ++in[id[x][y]];</span><br><span class="line">                gg[id[i][j]].<span class="built_in">push_back</span>(id[x][y]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j!=m)&#123;</span><br><span class="line">                ++in[id[i][j]];</span><br><span class="line">                gg[id[i][j+<span class="number">1</span>]].<span class="built_in">push_back</span>(id[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toposort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">            <span class="keyword">if</span>(!in[id[i][j]])&#123;</span><br><span class="line">                vis[id[i][j]]=<span class="literal">true</span>;</span><br><span class="line">                que[++r]=id[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">while</span>(l!=r)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=que[++l];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;gg[x].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> y=gg[x][i];</span><br><span class="line">            <span class="keyword">if</span>(!--in[y]&amp;&amp;!vis[y])&#123;</span><br><span class="line">                vis[y]=<span class="literal">true</span>;</span><br><span class="line">                que[++r]=y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=id[i][j];</span><br><span class="line">            <span class="keyword">if</span>(vis[x])&#123;</span><br><span class="line">                <span class="keyword">if</span>(val[x]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    sum+=val[x];</span><br><span class="line">                    <span class="built_in">add</span>(s,x,val[x]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">add</span>(x,t,-val[x]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">unsigned</span> k=<span class="number">0</span>;k&lt;gg[x].<span class="built_in">size</span>();++k)&#123;</span><br><span class="line">                    <span class="keyword">int</span> y=gg[x][k];</span><br><span class="line">                    <span class="keyword">if</span>(vis[y])</span><br><span class="line">                        <span class="built_in">add</span>(y,x,INF);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>()) sum-=<span class="built_in">dfs</span>(s,INF);</span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">love</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">toposort</span>();</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> kai586123::<span class="built_in">love</span>(),<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOI2004郁闷的出纳员</title>
    <url>/2019/06/08/noi2004%E9%83%81%E9%97%B7%E7%9A%84%E5%87%BA%E7%BA%B3%E5%91%98/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1486">[NOI2004]郁闷的出纳员</a> 大水题，结果因为不熟练调了半天，怒写题解记录一下。 开一个变量delta记录全局修改值。当减少delta的时候，应该把离职的员工，即在平衡树里值&lt;=m-delta-1的都删掉。 如果是一般平衡树暴力删就行，但是用splay有更好的方案： 分类讨论。首先找一找有没有值为m-delta-1的点。 如果没有，插一个进去，转到根，把根和左子树全删掉。 如果有，转到根，把根和左子树全删掉。 然而这样是不对的。因为可能存在不止一个值为m-delta-1的点，把一个转到根后，剩下的不但可能存在于左子树，也可能存在于右子树。 所以需要反复执行这个过程。 当然，如果把值一样的放在一个点就没这种问题了…. 另外，这题要记录删除的个数，删之前树的大小-删之后树的大小就是这次删掉的人。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">2333</span>, INF = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Splay &#123;</span><br><span class="line">    <span class="keyword">int</span> ch[N][<span class="number">2</span>], fa[N], val[N], size[N], root, tot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; size[x] = size[ch[x][<span class="number">0</span>]] + size[ch[x][<span class="number">1</span>]] + <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y = fa[x], z = fa[y], k = ch[y][<span class="number">1</span>] == x;</span><br><span class="line">        ch[z][ch[z][<span class="number">1</span>] == y] = x; fa[x] = z;</span><br><span class="line">        ch[y][k] = ch[x][k ^ <span class="number">1</span>]; fa[ch[x][k ^ <span class="number">1</span>]] = y;</span><br><span class="line">        ch[x][k ^ <span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">        <span class="built_in">pushup</span>(y); <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> tar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (fa[x] != tar) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = fa[x], z = fa[y];</span><br><span class="line">            <span class="keyword">if</span> (z != tar)</span><br><span class="line">                <span class="built_in">rotate</span>((ch[y][<span class="number">1</span>] == x) ^ (ch[z][<span class="number">1</span>] == y) ? x : y);</span><br><span class="line">            <span class="built_in">rotate</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!tar) root = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = root, f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) f = x, x = ch[x][v &gt; val[x]];</span><br><span class="line">        x = ++tot;</span><br><span class="line">        <span class="keyword">if</span> (f) ch[f][v &gt; val[f]] = x;</span><br><span class="line">        fa[x] = f; size[x] = <span class="number">1</span>; val[x] = v;</span><br><span class="line">        <span class="built_in">splay</span>(x, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; size[root])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> x = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == size[ch[x][<span class="number">1</span>]] + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> val[x];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (k &lt;= size[ch[x][<span class="number">1</span>]])</span><br><span class="line">                x = ch[x][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= size[ch[x][<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">                x = ch[x][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = root;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val[x] == v) &#123;</span><br><span class="line">                <span class="built_in">splay</span>(x, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">            x = ch[x][v &gt; val[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">find</span>(v), ret = size[root];</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">insert</span>(v);</span><br><span class="line">            fa[root = ch[root][<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                fa[root = ch[root][<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">                x = <span class="built_in">find</span>(v);</span><br><span class="line">            &#125; <span class="keyword">while</span> (x != <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret - size[root];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Splay::<span class="built_in">insert</span>(INF);</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">char</span> opt[<span class="number">2</span>]; <span class="keyword">int</span> x, delta = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, opt, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (*opt == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= m)</span><br><span class="line">                Splay::<span class="built_in">insert</span>(x - delta);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*opt == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">            delta += x;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*opt == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">            delta -= x;</span><br><span class="line">            tot += Splay::<span class="built_in">remove</span>(m - delta - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> t = Splay::<span class="built_in">kth</span>(x + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t == <span class="number">-1</span> ? t : t + delta);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOI2009诗人小G</title>
    <url>/2019/07/05/noi2009%E8%AF%97%E4%BA%BA%E5%B0%8Fg/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1912">[NOI2009]诗人小G</a> 四边形不等式。不会证明。记录一下解法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __int128 long double</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">char</span> s[N][<span class="number">35</span>]; <span class="keyword">int</span> sum[N];</span><br><span class="line"><span class="keyword">int</span> n, len, p, g[N];</span><br><span class="line">__int128 f[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> p, l, r;</span><br><span class="line">&#125; que[N];</span><br><span class="line"><span class="keyword">int</span> head, tail;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> __int128 <span class="title">fpow</span><span class="params">(__int128 x)</span> </span>&#123;</span><br><span class="line">    __int128 ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = p; y; y &gt;&gt;= <span class="number">1</span>, x = x * x)</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = ret * x;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;len, &amp;p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i]);</span><br><span class="line">        sum[i] = <span class="built_in">strlen</span>(s[i]) + sum[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> __int128 <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[l] + <span class="built_in">fpow</span>(std::<span class="built_in">abs</span>(sum[r] - sum[l] + r - l - <span class="number">1</span> - len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [l, r]中，now比last决策优的最前面的now的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> now, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l != r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">calc</span>(last, mid) &gt; <span class="built_in">calc</span>(now, mid))</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = <span class="number">1</span>, tail = <span class="number">1</span>;</span><br><span class="line">    que[head] = Node&#123; <span class="number">0</span>, <span class="number">1</span>, n &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head &lt;= tail &amp;&amp; que[head].r &lt; i)</span><br><span class="line">            ++head;</span><br><span class="line">        f[i] = <span class="built_in">calc</span>(que[head].p, i);</span><br><span class="line">        g[i] = que[head].p; <span class="comment">// 转移点</span></span><br><span class="line">        <span class="comment">// 新决策完全不如旧决策</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">calc</span>(que[tail].p, n) &lt; <span class="built_in">calc</span>(i, n))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 旧决策完全不如新决策</span></span><br><span class="line">        <span class="keyword">while</span> (head &lt;= tail &amp;&amp; <span class="built_in">calc</span>(i, que[tail].l) &lt; <span class="built_in">calc</span>(que[tail].p, que[tail].l))</span><br><span class="line">            --tail;</span><br><span class="line">        <span class="keyword">if</span> (head &gt; tail)</span><br><span class="line">            que[++tail] = Node&#123; i, i + <span class="number">1</span>, n &#125;;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 拆开最后一个，二分</span></span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">find</span>(que[tail].l, n, i, que[tail].p);</span><br><span class="line">            que[tail].r = x - <span class="number">1</span>;</span><br><span class="line">            que[++tail] = Node&#123; i, x, n &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stack[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[n] &gt; (__int128)(<span class="number">1e18</span>))</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Too hard to arrange&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (<span class="keyword">long</span> <span class="keyword">long</span>)f[n]);</span><br><span class="line">        <span class="keyword">int</span> now = n, top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (now) &#123;</span><br><span class="line">            stack[++top] = now;</span><br><span class="line">            now = g[now];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s[i]);</span><br><span class="line">            <span class="keyword">if</span> (i != stack[top])</span><br><span class="line">                <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>), --top;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="built_in">output</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOI2010超级钢琴</title>
    <url>/2019/04/18/noi2010%E8%B6%85%E7%BA%A7%E9%92%A2%E7%90%B4/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2048">[NOI2010]超级钢琴</a> 这题真的好神啊…%%%%% 暴力能拿点部分分。用人话说一下题意，其实就是求区间前k大数和。可以二分第k大然后主席树/可持久化Trie乱搞一下，看题解里说开O2能过…然而正解少一个log。思路：贪心+st表+堆。 前缀和优化一下，然后区间[l,r]的和就是sum[r]-sum[l-1]。固定左端点设为o，右端点可以产生在[o+l-1,o+r-1]之间。用(o,l,r)表示o为左端点，右端点在[l,r]的一个状态，并记录t，使l&lt;=t&lt;=r，且sum[t]-sum[l-1]最大。 先枚举o，插入一些状态到大根堆里。。每次取出堆顶，然后插回去(o,l,t-1)和(o,t+1,r)。选够要求的数量即可。因为数据范围很大，求t可以用st表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500000</span> + <span class="number">2333</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, l, r;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N], st[N][<span class="number">20</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        st[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = st[i][j - <span class="number">1</span>], y = st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>];</span><br><span class="line">            st[i][j] = sum[x] &gt; sum[y] ? x : y;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="built_in">log2</span>(r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> x = st[l][k], y = st[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k];</span><br><span class="line">    <span class="keyword">return</span> sum[x] &gt; sum[y] ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> o, l, r, t;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _o, <span class="keyword">int</span> _l, <span class="keyword">int</span> _r) &#123;</span><br><span class="line">        o = _o, l = _l, r = _r;</span><br><span class="line">        t = <span class="built_in">query</span>(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> sum[a.t] - sum[a.o - <span class="number">1</span>] &lt; sum[b.t] - sum[b.o - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Node&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(), k = <span class="built_in">rd</span>(), l = <span class="built_in">rd</span>(), r = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        sum[i] = <span class="built_in">rd</span>() + sum[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + l - <span class="number">1</span> &lt;= n; ++i)</span><br><span class="line">        que.<span class="built_in">push</span>(<span class="built_in">Node</span>(i, i + l - <span class="number">1</span>, <span class="built_in">min</span>(i + r - <span class="number">1</span>, n)));</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        Node node = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        ans += sum[node.t] - sum[node.o - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (node.l != node.t)</span><br><span class="line">            que.<span class="built_in">push</span>(<span class="built_in">Node</span>(node.o, node.l, node.t - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (node.r != node.t)</span><br><span class="line">            que.<span class="built_in">push</span>(<span class="built_in">Node</span>(node.o, node.t + <span class="number">1</span>, node.r));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> kai586123::<span class="built_in">main</span>(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOI2011阿狸的打字机</title>
    <url>/2019/05/10/noi2011%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2414">[NOI2011]阿狸的打字机</a> AC自动机神题。题意：给一坨字符串，问一个串在另一个串里出现了多少次。 这题输入很毒瘤，而且决定了字符串总长度是极大的量级，只能建Trie。建出来Trie，再建个AC自动机，就可以暴力了。据说50分。 把trie上所有点的fail指针指向的点向这个点连边，构成一棵fail树。研究一下fail树的性质：如果在它上面某个点匹配到一个串，那么这个点的祖先代表的点也都被匹配到了。反过来说，要求某个点代表串的出现次数，就是这个点和它的子树中匹配到的点数量和。 dfs一下fail树，求出dfs序。然后对trie树dfs。用树状数组在dfs序上单点修改区间查询，以表示匹配次数。进入+1，退出-1，这样dfs到某个点的时候，树状数组正好维护的是匹配这个串的结果。处理这个点有关询问即可。 代码对本蒟蒻特别不友好，写了好久。。。 一些细节：建Trie的时候要注意复杂度（见代码），注意各变量的意义，注意题目中x和y的关系，注意建AC自动机的时候会改变Trie形态，需要备份一个原Trie。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c -<span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">2333</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, ch[N][<span class="number">26</span>], chh[N][<span class="number">26</span>], fail[N], pos[N], num, fa[N],</span><br><span class="line">    size[N], ans[N], dfn[N], dd, bit[N], head[N], tot;</span><br><span class="line"><span class="keyword">char</span> ss[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125; g[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; end[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    g[++tot].to = y, g[tot].nxt = head[x],</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; x &lt;= dd; x += x &amp; -x)</span><br><span class="line">        bit[x] += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; x; x -= x &amp; -x)</span><br><span class="line">        ret += bit[x];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ss + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(ss + <span class="number">1</span>), cnt = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ss[i] == <span class="string">&#x27;P&#x27;</span>) &#123;</span><br><span class="line">            pos[++cnt] = now;</span><br><span class="line">            end[now].<span class="built_in">push_back</span>(cnt);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ss[i] == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">            now = fa[now];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> x = ss[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ch[now][x]) &#123;</span><br><span class="line">                ch[now][x] = ++num;</span><br><span class="line">                fa[num] = now;</span><br><span class="line">            &#125;</span><br><span class="line">            now = ch[now][x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">        q[y].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(pos[x], i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(chh, ch, <span class="built_in"><span class="keyword">sizeof</span></span>(ch));</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (chh[<span class="number">0</span>][i])</span><br><span class="line">            que.<span class="built_in">push</span>(chh[<span class="number">0</span>][i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chh[x][i]) &#123;</span><br><span class="line">                fail[chh[x][i]] = chh[fail[x]][i];</span><br><span class="line">                que.<span class="built_in">push</span>(chh[x][i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                chh[x][i] = chh[fail[x]][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">        <span class="built_in">addedge</span>(fail[i], i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dfn</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = ++dd; size[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="built_in">get_dfn</span>(y);</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(dfn[x], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; end[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; q[end[x][i]].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = q[end[x][i]][j].first;</span><br><span class="line">            ans[q[end[x][i]][j].second] = <span class="built_in">ask</span>(dfn[y] + size[y] - <span class="number">1</span>) - <span class="built_in">ask</span>(dfn[y] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (ch[x][i])</span><br><span class="line">            <span class="built_in">dfs</span>(ch[x][i]);</span><br><span class="line">    <span class="built_in">add</span>(dfn[x], <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">get_dfn</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> kai586123::<span class="built_in">main</span>(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOI2007 货币兑换</title>
    <url>/2019/07/31/noi2007-%E8%B4%A7%E5%B8%81%E5%85%91%E6%8D%A2/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P4027">[NOI2007] 货币兑换</a> 不怎么会分治的蒟蒻看题解都看不懂… 题里说了，一定有一种方案，使得每次都是全卖掉或者用掉所有钱买。其实不保证，也一定是这样的。 那么，令$x_i,y_i$，为$i$天两种券最多有多少。$f_i$是最多有多少钱。 $$f_i=\max_{j=1}^{i-1}a_ix_j+b_iy_j$$ 这个柿子拆开，得到这样的柿子： $$y_j=-\frac{a_i}{b_i}x_j+\frac{f_i}{b_i}$$ 可以斜率优化。 但是，本题的$\frac{a_i}{b_i},x_i$都不单调。 如果全部单调，单调队列，一个不单调，二分。两个都不单调，我们需要动态维护凸包，动态查找。 Splay可以做到动态凸包，但是太难写。还可以CDQ分治。 具体步骤是这样的：</p>
<ul>
<li>初始序列按斜率排序</li>
<li>按时间排序，分治左边</li>
<li>维护左边凸包</li>
<li>更新右边答案</li>
<li>分治右边</li>
<li>按$x$排序，返回</li>
</ul>
<p>由主定理显然是$O(nlogn)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">2333</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>, INF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> a, b, r, sl, x, y;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125; p[N], t[N];</span><br><span class="line"><span class="keyword">double</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> que[N], head, tail;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp_sl</span><span class="params">(<span class="keyword">const</span> Node &amp;x, <span class="keyword">const</span> Node &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.sl &gt; y.sl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(p[i].x - p[j].x) &lt; eps)</span><br><span class="line">        <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> (p[i].y - p[j].y) / (p[i].x - p[j].x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        f[l] = std::<span class="built_in">max</span>(f[l], f[l - <span class="number">1</span>]);</span><br><span class="line">        p[l].y = f[l] / (p[l].a * p[l].r + p[l].b);</span><br><span class="line">        p[l].x = p[l].y * p[l].r;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按id排序 </span></span><br><span class="line">    <span class="keyword">int</span> x = l, y = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i].id &lt;= mid) t[x++] = p[i];</span><br><span class="line">        <span class="keyword">else</span> t[y++] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">        p[i] = t[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">solve</span>(l, mid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护凸包 </span></span><br><span class="line">    tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= mid; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (tail &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">slope</span>(que[tail - <span class="number">1</span>], que[tail]) &lt;= <span class="built_in">slope</span>(que[tail], i))</span><br><span class="line">            --tail;</span><br><span class="line">        que[++tail] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DP </span></span><br><span class="line">    head = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (head &lt; tail &amp;&amp; <span class="built_in">slope</span>(que[head], que[head + <span class="number">1</span>]) &gt;= p[i].sl)</span><br><span class="line">            ++head;</span><br><span class="line">        <span class="keyword">int</span> j = que[head];</span><br><span class="line">        f[p[i].id] = std::<span class="built_in">max</span>(f[p[i].id], p[i].a * p[j].x + p[i].b * p[j].y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">solve</span>(mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按x排序 </span></span><br><span class="line">    x = l, y = mid + <span class="number">1</span>; <span class="keyword">int</span> z = l;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= mid &amp;&amp; y &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(p[x].x - p[y].x) &gt; eps) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[x].x &lt; p[y].x) t[z++] = p[x++];</span><br><span class="line">            <span class="keyword">else</span> t[z++] = p[y++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[x].y &lt; p[y].y) t[z++] = p[x++];</span><br><span class="line">            <span class="keyword">else</span> t[z++] = p[y++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= mid) t[z++] = p[x++];</span><br><span class="line">    <span class="keyword">while</span> (y &lt;= r) t[z++] = p[y++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) p[i] = t[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %lf&quot;</span>, &amp;n, f);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %lf&quot;</span>, &amp;p[i].a, &amp;p[i].b, &amp;p[i].r);</span><br><span class="line">        p[i].sl = -p[i].a / p[i].b;</span><br><span class="line">        p[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, comp_sl);</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>, f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOI2012骑行川藏 拉格朗日乘数法</title>
    <url>/2020/04/06/noi2012%E9%AA%91%E8%A1%8C%E5%B7%9D%E8%97%8F-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E6%95%B0%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2179">[NOI2012]骑行川藏</a> 首先要知道偏导数，就是一个很多变量的函数求关于一个变量的导数，把其他变量看作常数。记为$\frac{\delta f}{\delta x}$ 有一个拉格朗日乘数法。给定$f(x_1,x_2,…,x_k)$，并且要求满足$g(x_1,x_2,…,x_k)=c$，求$f$的极值。 求极值的方法是这样的：我们考虑对$f$作出等高线图，并且作出$g=c$。当$g$与等高线相切时，$f$取得极值。考虑这个点两函数的梯度是成正比的，即 $$\nabla f= \lambda \nabla g$$ $$\nabla f - \lambda \nabla (g-c) = 0$$ 那么引入拉格朗日乘数$\lambda$，令$L(x_1,x_2,…,x_k,\lambda)=f(x_1,x_2,…,x_k)+\lambda (g(x_1,x_2,…,x_k)-c)$，当$L$的梯度为$0$最优，只需求出$L$的极值即可。 另一个角度：考虑对$\lambda$的偏导数，即要求$g(x_1,x_2,…,x_k)-c=0$，恰好满足了限制。 回到这个题，这个题要求$\sum_{i=1}^n s_ik_i(v_i-v’<em>i)^2 \leq E$，求$\min \sum</em>{i=1}^n \frac{s_i}{v_i}$ 可以发现要求最小值，$v_i$大一些是更好的，那么直接$\sum_{i=1}^n s_ik_i(v_i-v’<em>i)^2 = E$求极值。令$f(v)=\sum</em>{i=1}^n \frac{s_i}{v_i},g(v)=\sum_{i=1}^n s_ik_i(v_i-v’_i)^2 $，令$L(v,\lambda)=f(v)-\lambda (g(v)-E)$ 求偏导，可以得到： $$\forall i, \ \ 2\lambda k_i s_i (v_i - v’_i) - \frac{s_i}{v_i^2} = 0$$ $$\sum_{i=1}^n k_i s_i (v_i - v’_i)^2 - E = 0$$ 稍微化简可得： $$2\lambda k_i v_i^2 (v_i - v’_i) = 1$$ $$\sum_{i=1}^n k_i s_i (v_i - v’_i)^2 = E$$ 题目中的式子是有意义的，$v_i &gt; v’_i$。考虑枚举$i$，给$v_i$钦定一个值，使得它满足第一个式子，即可求得解。不过$\lambda$也不知道，二分即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-12</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">pow2</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; <span class="keyword">double</span> E;</span><br><span class="line"><span class="keyword">double</span> s[N], k[N], v[N], u[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> lam, <span class="keyword">double</span> v, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * lam * <span class="built_in">pow2</span>(v) * k[i] * (v - u[i]) &lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> lam)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">double</span> l = u[i] &gt;= <span class="number">0</span> ? u[i] : <span class="number">0</span>, r = <span class="number">1e5</span>, ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps) &#123;</span><br><span class="line">      <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">check</span>(lam, mid, i))</span><br><span class="line">        ans = l = mid;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    v[i] = ans;</span><br><span class="line">    sum += k[i] * s[i] * <span class="built_in">pow2</span>(v[i] - u[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum &lt;= E;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%lf&quot;</span>, &amp;n, &amp;E);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf&quot;</span>, s + i, k + i, u + i);</span><br><span class="line">  <span class="keyword">double</span> l = <span class="number">0</span>, r = <span class="number">1e5</span>;</span><br><span class="line">  <span class="keyword">while</span> (r - l &gt; eps) &#123;</span><br><span class="line">    <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">      r = mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      l = mid;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    ans += s[i] / v[i];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOI2014动物园</title>
    <url>/2019/01/29/noi2014%E5%8A%A8%E7%89%A9%E5%9B%AD/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2375">[NOI2014]动物园</a> 题意：num[i]表示字符串1~i中不重叠（即长度&lt;=n/2）的相同前缀的后缀数量 如果没有长度限制，考虑kmp算法中的next数组，令j=next[i]，[1,j]与[i-j+1,i]相等，且j最大。num[i]=num[j]+1。 在长度限制下，我们令j=next[j]，直到区间不相交。如果一边kmp一遍维护答案，每次j都会成为最大值，会导致跳回去的代价过大（如使用一串相同字符）。所以先kmp扫一次，再统计一次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">2333</span>;</span><br><span class="line">    <span class="keyword">char</span> s[MAXN];</span><br><span class="line">    <span class="keyword">int</span> num[MAXN], next[MAXN];</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line">    ull ans;</span><br><span class="line">    <span class="keyword">const</span> ull MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            cin &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(next));</span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>); ans = <span class="number">1</span>; num[<span class="number">1</span>] = <span class="number">1</span>; num[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &amp;&amp; s[j + <span class="number">1</span>] != s[i]) j = next[j];</span><br><span class="line">                <span class="keyword">if</span> (s[j + <span class="number">1</span>] == s[i]) ++j;</span><br><span class="line">                next[i] = j;</span><br><span class="line">                num[i] = num[j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &amp;&amp; s[j + <span class="number">1</span>] != s[i]) j = next[j];</span><br><span class="line">                <span class="keyword">if</span> (s[j + <span class="number">1</span>] == s[i]) ++j;</span><br><span class="line">                <span class="keyword">while</span> (j * <span class="number">2</span> &gt; i) j = next[j];</span><br><span class="line">                ans = ans * (num[j] + <span class="number">1</span>) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOI2014起床困难综合症</title>
    <url>/2019/04/14/noi2014%E8%B5%B7%E5%BA%8A%E5%9B%B0%E9%9A%BE%E7%BB%BC%E5%90%88%E7%97%87/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3668">[NOI2014]起床困难综合症</a> 并不确定初始值是多少，枚举显然不行，位运算是位独立的，我们可以存下来操作，一位一位的贪心算。$O(nlogm)$。但是还有更精巧的做法，即使用一个全$0$串和一个全$1$串，一次操作即可得到每一位结果。然后贪心。$O(n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, t, a = <span class="number">0</span>, b = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>) - <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> opt[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, opt, &amp;t);</span><br><span class="line">        <span class="keyword">if</span> (*opt == <span class="string">&#x27;A&#x27;</span>) a &amp;= t, b &amp;= t;</span><br><span class="line">        <span class="keyword">if</span> (*opt == <span class="string">&#x27;O&#x27;</span>) a = t, b = t;</span><br><span class="line">        <span class="keyword">if</span> (*opt == <span class="string">&#x27;X&#x27;</span>) a ^= t, b ^= t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (((a &gt;&gt; i) &amp; <span class="number">1</span>)  (((b &gt;&gt; i) &amp; <span class="number">1</span>) &amp;&amp; (<span class="built_in">ans</span>  (<span class="number">1</span> &lt;&lt; i)) &lt;= m))</span><br><span class="line">            ans = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOI2014魔法森林</title>
    <url>/2019/07/03/noi2014%E9%AD%94%E6%B3%95%E6%A3%AE%E6%9E%97/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2387">[NOI2014]魔法森林</a> 两个权值，把a从小到大排序，枚举边。用LCT动态维护b的最小生成树。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> LCT &#123;</span><br><span class="line">    <span class="keyword">int</span> ch[N][<span class="number">2</span>], fa[N], val[N];</span><br><span class="line">    <span class="keyword">int</span> max[N] = &#123; -INF &#125;, max_id[N];</span><br><span class="line">    <span class="keyword">int</span> st[N], top;</span><br><span class="line">    <span class="keyword">bool</span> rev[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        max[x] = val[x]; max_id[x] = x;</span><br><span class="line">        <span class="keyword">if</span> (max[ch[x][<span class="number">0</span>]] &gt;= max[x]) &#123;</span><br><span class="line">            max[x] = max[ch[x][<span class="number">0</span>]];</span><br><span class="line">            max_id[x] = max_id[ch[x][<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max[ch[x][<span class="number">1</span>]] &gt;= max[x]) &#123;</span><br><span class="line">            max[x] = max[ch[x][<span class="number">1</span>]];</span><br><span class="line">            max_id[x] = max_id[ch[x][<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rev[x]) &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">            rev[ch[x][<span class="number">0</span>]] ^= <span class="number">1</span>;</span><br><span class="line">            rev[ch[x][<span class="number">1</span>]] ^= <span class="number">1</span>;</span><br><span class="line">            rev[x] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>] != x &amp;&amp; ch[fa[x]][<span class="number">1</span>] != x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y = fa[x], z = fa[y], k = ch[y][<span class="number">1</span>] == x;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isroot</span>(y))</span><br><span class="line">            ch[z][ch[z][<span class="number">1</span>] == y] = x;</span><br><span class="line">        fa[x] = z; ch[y][k] = ch[x][k ^ <span class="number">1</span>];</span><br><span class="line">        fa[ch[y][k]] = y; ch[x][k ^ <span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">        <span class="built_in">pushup</span>(y); <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preview</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        st[top = <span class="number">1</span>] = x;</span><br><span class="line">        <span class="keyword">for</span> ( ; !<span class="built_in">isroot</span>(x); x = fa[x])</span><br><span class="line">            st[++top] = fa[x];</span><br><span class="line">        <span class="keyword">while</span> (top) <span class="built_in">pushdown</span>(st[top--]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">preview</span>(x);</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isroot</span>(x)) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = fa[x], z = fa[y];</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isroot</span>(y))</span><br><span class="line">                <span class="built_in">rotate</span>((ch[z][<span class="number">1</span>] == y) ^ (ch[y][<span class="number">1</span>] == x) ? x : y);</span><br><span class="line">            <span class="built_in">rotate</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; x; y = x, x = fa[x])</span><br><span class="line">            <span class="built_in">splay</span>(x), ch[x][<span class="number">1</span>] = y, <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">access</span>(x); <span class="built_in">splay</span>(x);</span><br><span class="line">        rev[x] ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">access</span>(x); <span class="built_in">splay</span>(x); <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="keyword">while</span> (ch[x][<span class="number">0</span>])</span><br><span class="line">            <span class="built_in">pushdown</span>(x = ch[x][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">makeroot</span>(x); fa[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">makeroot</span>(x); <span class="built_in">access</span>(y); <span class="built_in">splay</span>(y);</span><br><span class="line">        ch[y][<span class="number">0</span>] = fa[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, a, b;</span><br><span class="line">&#125; edge[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> Edge &amp;x, <span class="keyword">const</span> Edge &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.a &lt; y.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">love</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        edge[i].x = <span class="built_in">rd</span>();</span><br><span class="line">        edge[i].y = <span class="built_in">rd</span>();</span><br><span class="line">        edge[i].a = <span class="built_in">rd</span>();</span><br><span class="line">        edge[i].b = <span class="built_in">rd</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(edge + <span class="number">1</span>, edge + m + <span class="number">1</span>, comp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        LCT::val[i] = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        LCT::val[n + i] = edge[i].b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (LCT::<span class="built_in">findroot</span>(edge[i].x) == LCT::<span class="built_in">findroot</span>(edge[i].y)) &#123;</span><br><span class="line">            LCT::<span class="built_in">makeroot</span>(edge[i].x);</span><br><span class="line">            LCT::<span class="built_in">access</span>(edge[i].y);</span><br><span class="line">            LCT::<span class="built_in">splay</span>(edge[i].y);</span><br><span class="line">            <span class="keyword">if</span> (LCT::max[edge[i].y] &lt; edge[i].b)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> id = LCT::max_id[edge[i].y];</span><br><span class="line">            LCT::<span class="built_in">cut</span>(edge[id - n].x, id);</span><br><span class="line">            LCT::<span class="built_in">cut</span>(edge[id - n].y, id);</span><br><span class="line">        &#125;</span><br><span class="line">        LCT::<span class="built_in">link</span>(edge[i].x, n + i);</span><br><span class="line">        LCT::<span class="built_in">link</span>(edge[i].y, n + i);</span><br><span class="line">        <span class="keyword">if</span> (LCT::<span class="built_in">findroot</span>(<span class="number">1</span>) == LCT::<span class="built_in">findroot</span>(n)) &#123;</span><br><span class="line">            LCT::<span class="built_in">makeroot</span>(<span class="number">1</span>);</span><br><span class="line">            LCT::<span class="built_in">access</span>(n);</span><br><span class="line">            LCT::<span class="built_in">splay</span>(n);</span><br><span class="line">            ans = std::<span class="built_in">min</span>(ans, edge[i].a + LCT::max[n]);</span><br><span class="line">            <span class="keyword">if</span> (edge[i].a + LCT::max[n] == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, edge[i].a, LCT::max[n], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans == INF ? <span class="number">-1</span> : ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">love</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOI2015品酒大会</title>
    <url>/2019/06/17/noi2015%E5%93%81%E9%85%92%E5%A4%A7%E4%BC%9A/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2178">[NOI2015]品酒大会</a> 并查集+SA。一直以为并查集是普及算法，我可能学的是假并查集… 求出来height之后，按照height排序。每次挑出来最大的height，把组成这个height的两个串合并。 某次操作的时候，两个串分别为x，y，大小为size[x]，size[y]，height是h。那么它们对“h相似”的贡献是size[x] * size[y]。这很显然，两串是连着的，可以随便挑两个组合一下。 至于第二个问题，维护每个联通块的最大最小值（负负得正），合并两个串的时候，顺便维护一下就行了。 因为这么写，维护了lcp正好是[0,n-1]的各串答案。但是每个串的a记在头部，即在最终询问中，lcp为x的串答案可以用来更新x-1的。从后向前处理（后缀和？）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">23333</span>;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">1LL</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> n; LL a[N];</span><br><span class="line"><span class="keyword">int</span> fir[N], sec[N], buc[N], sa[N], rk[N], ht[N];</span><br><span class="line"><span class="keyword">int</span> fa[N], g[N];</span><br><span class="line">LL size[N], max[N], min[N], ans1[N], ans2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, a + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++buc[fir[i] = s[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="string">&#x27;z&#x27;</span>; ++i) buc[i] += buc[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[buc[fir[i]]--] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>, k = <span class="number">1</span>; k &lt;= n; p = <span class="number">0</span>, k &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; ++i) sec[++p] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt; k) sec[++p] = sa[i] - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) buc[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++buc[fir[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) buc[i] += buc[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[buc[fir[sec[i]]]--] = sec[i];</span><br><span class="line">        std::<span class="built_in">swap</span>(fir, sec); fir[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            fir[sa[i]] = sec[sa[i]] == sec[sa[i - <span class="number">1</span>]]</span><br><span class="line">                &amp;&amp; sec[sa[i] + k] == sec[sa[i - <span class="number">1</span>] + k]</span><br><span class="line">                ? p : ++p;</span><br><span class="line">        <span class="keyword">if</span> (p == n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, p = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (p) --p;</span><br><span class="line">        <span class="keyword">while</span> (s[i + p] == s[j + p]) ++p;</span><br><span class="line">        ht[rk[i]] = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = <span class="built_in">find</span>(x), fy = <span class="built_in">find</span>(y), h = ht[x];</span><br><span class="line">    ans1[h] += size[fx] * size[fy];</span><br><span class="line">    ans2[h] = std::<span class="built_in">max</span>(ans2[h], std::<span class="built_in">max</span>(max[fx] * max[fy], min[fx] * min[fy]));</span><br><span class="line">    max[fx] = std::<span class="built_in">max</span>(max[fx], max[fy]);</span><br><span class="line">    min[fx] = std::<span class="built_in">min</span>(min[fx], min[fy]);</span><br><span class="line">    size[fa[fy] = fx] += size[fy];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ht[x] &gt; ht[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        size[fa[i] = g[i] = i] = <span class="number">1</span>;</span><br><span class="line">        min[i] = max[i] = a[sa[i]];</span><br><span class="line">        ans2[i] = -INF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(g + <span class="number">1</span>, g + n + <span class="number">1</span>, comp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(g[i]) != <span class="built_in">find</span>(g[i] - <span class="number">1</span>))</span><br><span class="line">            <span class="built_in">merge</span>(g[i], g[i] - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        ans1[i] += ans1[i + <span class="number">1</span>];</span><br><span class="line">        ans2[i] = std::<span class="built_in">max</span>(ans2[i + <span class="number">1</span>], ans2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, ans1[i], ans1[i] ? ans2[i] : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(); <span class="built_in">build</span>(); <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOI2015程序自动分析</title>
    <url>/2019/01/05/noi2015%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1955">[NOI2015]程序自动分析</a> 实际上就是个并查集，先处理全部输入的i=j组，再枚举i!=j组判断是否矛盾即可 然而本题数据范围略大，需要使用特殊手段才可以解决</p>
<h2 id="4000ms解法"><a href="#4000ms解法" class="headerlink" title="4000ms解法"></a>4000ms解法</h2><p>由题可知，虽然i,j&lt;=1e9，但是组数n&lt;=1e5 根据离散化的思想，我们可以将这些i j映射到一个小数组中，解决本问题 具体操作方法： 对于输入的i与j排序，去重后添加入一个数组a中，即可用a[k]表示原来的第k个数。在使用时只需二分查找即可 在这里我偷懒直接用了stl::map，操作简单，但是有点慢，不开O2的情况下在Luogu上有一个点TLE了…4000ms，开启O2后2000ms</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>; <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">do</span> &#123; c = <span class="built_in">getchar</span>(); &#125; <span class="keyword">while</span> (c&gt;<span class="string">&#x27;9&#x27;</span>  c&lt;<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123; a = a * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>; c = <span class="built_in">getchar</span>(); &#125; <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;c &lt;= <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">INPUT</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i, j, e;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">INPUT input[MAXN];</span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ufs[MAXN * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (rint i = <span class="number">0</span>; i&lt;MAXN * <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        ufs[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ufs[x] = x == ufs[x] ? x : <span class="built_in">find</span>(ufs[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xx = <span class="built_in">find</span>(x), yy = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">return</span> xx == yy ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xx = <span class="built_in">find</span>(x), yy = <span class="built_in">find</span>(y);</span><br><span class="line">    ufs[xx] = yy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> INPUT &amp;x, <span class="keyword">const</span> INPUT &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.e&gt;y.e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">read</span>(), tot = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        mp.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (rint i = <span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">            input[i].i = <span class="built_in">read</span>();</span><br><span class="line">            input[i].j = <span class="built_in">read</span>();</span><br><span class="line">            input[i].e = <span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(input[i].i) == mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                mp[input[i].i] = tot++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(input[i].j) == mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                mp[input[i].j] = tot++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(input, input + n, comp);</span><br><span class="line">        <span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (rint i = <span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = mp[input[i].i], y = mp[input[i].j];</span><br><span class="line">            <span class="keyword">if</span> (input[i].e == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">unite</span>(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">same</span>(x, y)) &#123;</span><br><span class="line">                    ok = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="300ms做法"><a href="#300ms做法" class="headerlink" title="300ms做法"></a>300ms做法</h2><p>然而作为一名喜欢骗分追求效率的的OIer，我使用了更加快速的玄学解法： 将输入的i与j直接%一个数字MOD，加入数组中 MOD的选择的确是个玄学，看到有人在提交时使用520817通过了此题，我就直接抄来了…… 其它的一些优化：输入时就判断e的值，分为多个数组储存避免每次的判断；使用memcpy代替循环为并查集附初值 开O2后达到了200ms，甚至冲上了最优解的第一页</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>; <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">do</span> &#123; c = <span class="built_in">getchar</span>(); &#125; <span class="keyword">while</span> (c&gt;<span class="string">&#x27;9&#x27;</span>  c&lt;<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123; a = a * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>; c = <span class="built_in">getchar</span>(); &#125; <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;c &lt;= <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> ii1[MAXN], ii2[MAXN], jj1[MAXN], jj2[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">520817</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ufs[MOD + <span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> down_ufs[MOD + <span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ufs[x] = x == ufs[x] ? x : <span class="built_in">find</span>(ufs[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xx = <span class="built_in">find</span>(x), yy = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">return</span> xx == yy ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xx = <span class="built_in">find</span>(x), yy = <span class="built_in">find</span>(y);</span><br><span class="line">    ufs[xx] = yy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (rint i = <span class="number">0</span>; i&lt;MOD + <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        down_ufs[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(ufs, down_ufs, <span class="built_in"><span class="keyword">sizeof</span></span>(ufs));</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">read</span>(), tot1 = <span class="number">-1</span>, tot2 = <span class="number">-1</span>, tmpi, tmpj, tmpe;</span><br><span class="line">        <span class="keyword">for</span> (rint i = <span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">            tmpi = <span class="built_in">read</span>() % MOD;</span><br><span class="line">            tmpj = <span class="built_in">read</span>() % MOD;</span><br><span class="line">            tmpe = <span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">if</span> (tmpe) &#123;</span><br><span class="line">                ii1[++tot1] = tmpi;</span><br><span class="line">                jj1[tot1] = tmpj;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ii2[++tot2] = tmpi;</span><br><span class="line">                jj2[tot2] = tmpj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (rint i = <span class="number">0</span>; i &lt;= tot1; ++i) &#123;</span><br><span class="line">            <span class="built_in">unite</span>(ii1[i], jj1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (rint i = <span class="number">0</span>; i &lt;= tot2; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">same</span>(ii2[i], jj2[i])) &#123;</span><br><span class="line">                ok = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(ok == <span class="literal">true</span> ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOI2015软件包管理器</title>
    <url>/2019/01/05/noi2015%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2146">[NOI2015]软件包管理器</a> 传说中NOI2015出了三道板子题，果然名不虚传，一道并查集一道Huffman树一道树链剖分… 虽然依赖条件是有向边，但是纸上画一画可以发现有向无向其实没关系。建成一棵双向边连接的，根为0的树即可。 对树进行树链剖分，每次安装时把要安装的点到根全部变成1，统计增加量，卸载时把以这个点为根的子树全部改为0，统计减少量。 区间修改的pushdown很简单，只需要把原来的+=改为=，然后lazytag改为一个特别的数，方便判断是否需要pushdown。为了节省时间，代码实现时在修改的同时直接把原来有的1的数量求了出来。安装操作答案为到根距离（即深度）-1的数量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">2333</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">G</span> &#123;</span> <span class="keyword">int</span> to, nxt; &#125; g[MAXN * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> N, Q, head[MAXN], tot, num, id[MAXN], top[MAXN], dep[MAXN], fa[MAXN], son[MAXN], sz[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; g[++tot].to = y, g[tot].nxt = head[x], head[x] = tot; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>; fa[x] = f, dep[x] = dep[f] + <span class="number">1</span>, sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y = g[i].to; i; i = g[i].nxt, y = g[i].to)</span><br><span class="line">        <span class="keyword">if</span> (y != f) &#123;</span><br><span class="line">            <span class="built_in">dfs1</span>(y, x), sz[x] += sz[y];</span><br><span class="line">            <span class="keyword">if</span> (sz[y] &gt; mx) mx = sz[y], son[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line">    id[x] = ++num, top[x] = topf;</span><br><span class="line">    <span class="keyword">if</span> (!son[x]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], topf);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y = g[i].to; i; i = g[i].nxt, y = g[i].to)</span><br><span class="line">        <span class="keyword">if</span> (y != fa[x] &amp;&amp; y != son[x]) <span class="built_in">dfs2</span>(y, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span> &#123;</span> <span class="keyword">int</span> l, r, v, lz; &#125; t[MAXN * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[p].l = l, t[p].r = r;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (l != r) <span class="built_in">build</span>(p * <span class="number">2</span>, l, mid), <span class="built_in">build</span>(p * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[p].lz == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    t[p * <span class="number">2</span>].v = t[p].lz * (t[p * <span class="number">2</span>].r - t[p * <span class="number">2</span>].l + <span class="number">1</span>), t[p * <span class="number">2</span>].lz = t[p].lz;</span><br><span class="line">    t[p * <span class="number">2</span> + <span class="number">1</span>].v = t[p].lz * (t[p * <span class="number">2</span> + <span class="number">1</span>].r - t[p * <span class="number">2</span> + <span class="number">1</span>].l + <span class="number">1</span>), t[p * <span class="number">2</span> + <span class="number">1</span>].lz = t[p].lz;</span><br><span class="line">    t[p].lz = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) &#123;</span><br><span class="line">        ans = t[p].v, t[p].lz = v; t[p].v = v * (t[p].r - t[p].l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) ans += <span class="built_in">change</span>(p * <span class="number">2</span>, l, r, v);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) ans += <span class="built_in">change</span>(p * <span class="number">2</span> + <span class="number">1</span>, l, r, v);</span><br><span class="line">    t[p].v = t[p * <span class="number">2</span>].v + t[p * <span class="number">2</span> + <span class="number">1</span>].v;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">install</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = dep[x];</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        ans -= <span class="built_in">change</span>(<span class="number">1</span>, id[top[x]], id[x], <span class="number">1</span>);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="built_in">change</span>(<span class="number">1</span>, id[x], id[y], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">uninstall</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">change</span>(<span class="number">1</span>, id[x], id[x] + sz[x] - <span class="number">1</span>, <span class="number">0</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, tmp; i &lt; N; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tmp), <span class="built_in">addedge</span>(i + <span class="number">1</span>, tmp + <span class="number">1</span>), <span class="built_in">addedge</span>(tmp + <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, N);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Q);</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="keyword">char</span> opt[<span class="number">15</span>]; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>, opt, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">install</span>(x + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">uninstall</span>(x + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOI2016优秀的拆分</title>
    <url>/2019/06/17/noi2016%E4%BC%98%E7%A7%80%E7%9A%84%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1117">[NOI2016]优秀的拆分</a> 这题用到了一种“打标记”的方法，和这个题（<a href="https://baka.online/power-strings/">Power Strings</a>）是类似的。 具体来说，枚举长度，再在长度的倍数上打标记。由调和级数，复杂度$O(nlogn)$。 具体做法：AABB很难处理，改成求出形如AA的串，拼一下就有AABB了。 枚举A的长度，打标记。显然一个A串会且仅会落在一个标记上。标记长度$i$，当前位置$j$。把正串和反串的height数组都求出来。求$j$和$j+i$位置的最长公共前后缀，记为$l$和$r$（都以当前位置为起点）。 以$r$为例：$r=min(l,lcp(j,j+i))$。用$l$限制是为了不重复。 $l+r-i$是本次求出的答案个数。 记录以每个位置为起点，终点的AA串个数。边界需要认真推一下，代码里是化简过的。 附上洛谷最后一次提交的代码(T_T)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果你好奇我为什么WA点了进来：</span></span><br><span class="line"><span class="comment">多测不清空，爆零两行泪</span></span><br><span class="line"><span class="comment">TAT</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30000</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> n, lg[N]; <span class="keyword">char</span> baka[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LOVEYYY</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> s[N];</span><br><span class="line">    <span class="keyword">int</span> x[N], y[N], c[N], sa[N], ht[N], rk[N];</span><br><span class="line">    <span class="keyword">int</span> st[N][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">char</span> ch[], <span class="keyword">bool</span> opt)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(s));</span><br><span class="line">        <span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(x));</span><br><span class="line">        <span class="built_in">memset</span>(y, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(y));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            s[opt == <span class="number">0</span> ? i : n - i + <span class="number">1</span>] = ch[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="string">&#x27;z&#x27;</span>; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i] = s[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="string">&#x27;z&#x27;</span>; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[i]]--] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, p = <span class="number">0</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>, p = <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; ++i) y[++p] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">                <span class="keyword">if</span> (sa[i] &gt; k) y[++p] = sa[i] - k;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[y[i]]]--] = y[i];</span><br><span class="line">            <span class="built_in">swap</span>(x, y); x[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">                x[sa[i]] = y[sa[i]] == y[sa[i - <span class="number">1</span>]]</span><br><span class="line">                    &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]</span><br><span class="line">                    ? p : ++p;</span><br><span class="line">            <span class="keyword">if</span> (p == n) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rk[sa[i]] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>, p = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (p) --p;</span><br><span class="line">            <span class="keyword">while</span> (s[i + p] == s[j + p]) ++p;</span><br><span class="line">            ht[rk[i]] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) st[i][<span class="number">0</span>] = ht[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">15</span>; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i)</span><br><span class="line">                st[i][j] = <span class="built_in">min</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lcp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = rk[x]; y = rk[y];</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        ++x; <span class="keyword">int</span> t = lg[y - x + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(st[x][t], st[y - (<span class="number">1</span> &lt;&lt; t) + <span class="number">1</span>][t]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; a, b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> f[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, baka + <span class="number">1</span>); n = <span class="built_in">strlen</span>(baka + <span class="number">1</span>);</span><br><span class="line">    a.<span class="built_in">init</span>(baka, <span class="number">1</span>); a.<span class="built_in">build</span>();</span><br><span class="line">    b.<span class="built_in">init</span>(baka, <span class="number">0</span>); b.<span class="built_in">build</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(g));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j + i &lt;= n; j += i) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="built_in">min</span>(i, a.<span class="built_in">lcp</span>(n - j - i + <span class="number">1</span>, n - j + <span class="number">1</span>)),</span><br><span class="line">                r = <span class="built_in">min</span>(i, b.<span class="built_in">lcp</span>(j, j + i));</span><br><span class="line">            <span class="keyword">if</span> (l + r &gt; i) &#123;</span><br><span class="line">                ++f[j + <span class="number">2</span> * i - l]; --f[j + i + r];</span><br><span class="line">                ++g[j - l + <span class="number">1</span>]; --g[j + r - i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">        g[i] += g[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        ans += (<span class="keyword">long</span> <span class="keyword">long</span>)f[i] * g[i + <span class="number">1</span>];</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">work</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOI2017游戏</title>
    <url>/2019/07/09/noi2017%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3825">[NOI2017]游戏</a> 3-SAT？不存在的。 假设没有x，就是个2-SAT的板子。发现x不多，枚举ban掉A或B就行了。（因为可以用C的方案出现过，不需要枚举C） 具体建图：如果有选$x$就要选$y$的限制，那么如果$y$不存在，$x \to x’$，表示不能选$x$。否则， $x \to y, y’ \to x’$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">2333</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, d, stack[N], top;</span><br><span class="line"><span class="keyword">char</span> cars[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125; g[N * <span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    g[++tot] = &#123; y, head[x] &#125;;</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rules</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">char</span> hx, hy;</span><br><span class="line">&#125; rule[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_ox</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> hx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hx == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cars[x] == <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hx == <span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cars[x] == <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cars[x] == <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_ix</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> hx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + (hx - <span class="string">&#x27;a&#x27;</span>) * n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = rule[i].x, hx = rule[i].hx, y = rule[i].y, hy = rule[i].hy,</span><br><span class="line">            ox = <span class="built_in">get_ox</span>(x, hx), oy = <span class="built_in">get_ox</span>(y, hy);</span><br><span class="line">        <span class="keyword">if</span> (cars[x] != hx) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cars[y] == hy)</span><br><span class="line">                <span class="built_in">addedge</span>(<span class="built_in">get_ix</span>(x, hx), <span class="built_in">get_ix</span>(x, ox));</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">addedge</span>(<span class="built_in">get_ix</span>(x, hx), <span class="built_in">get_ix</span>(y, hy));</span><br><span class="line">                <span class="built_in">addedge</span>(<span class="built_in">get_ix</span>(y, oy), <span class="built_in">get_ix</span>(x, ox));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc_id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = cars[i] != <span class="string">&#x27;a&#x27;</span> ? <span class="string">&#x27;a&#x27;</span> : cars[i] != <span class="string">&#x27;b&#x27;</span> ? <span class="string">&#x27;b&#x27;</span> : <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">            y = <span class="built_in">get_ox</span>(i, x);</span><br><span class="line">        id[i][<span class="number">0</span>] = <span class="built_in">get_ix</span>(i, x);</span><br><span class="line">        id[i][<span class="number">1</span>] = <span class="built_in">get_ix</span>(i, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[N], low[N], st[N], tp, cnt, ins[N], num, bel[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++num;</span><br><span class="line">    ins[st[++tp] = x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[y = g[i].to]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ins[y])</span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y; ++cnt;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ins[y = st[tp--]] = <span class="number">0</span>;</span><br><span class="line">            bel[y] = cnt;</span><br><span class="line">        &#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bel[id[i][<span class="number">0</span>]] == bel[id[i][<span class="number">1</span>]])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">get_name</span><span class="params">(<span class="keyword">int</span> ix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span> + (ix - <span class="number">1</span>) / n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bel[id[i][<span class="number">0</span>]] &lt; bel[id[i][<span class="number">1</span>]])</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="built_in">get_name</span>(id[i][<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="built_in">get_name</span>(id[i][<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * (tot + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>) * <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>) * <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>) * <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">memset</span>(bel, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>) * <span class="number">3</span>);</span><br><span class="line">    tot = cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>(); <span class="built_in">build</span>(); <span class="built_in">calc_id</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[id[i][<span class="number">0</span>]])</span><br><span class="line">            <span class="built_in">tarjan</span>(id[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (!dfn[id[i][<span class="number">1</span>]])</span><br><span class="line">            <span class="built_in">tarjan</span>(id[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>()) &#123;</span><br><span class="line">        <span class="built_in">print</span>(); <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (now &gt; d) &#123; <span class="built_in">solve</span>(); <span class="keyword">return</span>; &#125;</span><br><span class="line">    cars[stack[now]] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(now + <span class="number">1</span>);</span><br><span class="line">    cars[stack[now]] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(now + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s%d&quot;</span>, &amp;n, &amp;d, cars + <span class="number">1</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (cars[i] == <span class="string">&#x27;x&#x27;</span>) stack[++top] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %c%d %c&quot;</span>, &amp;rule[i].x, &amp;rule[i].hx, &amp;rule[i].y, &amp;rule[i].hy);</span><br><span class="line">        rule[i].hx = <span class="built_in">tolower</span>(rule[i].hx);</span><br><span class="line">        rule[i].hy = <span class="built_in">tolower</span>(rule[i].hy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOI2018屠龙勇士</title>
    <url>/2019/07/10/noi2018%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4774">[NOI2018]屠龙勇士</a> exCRT。 早就听说这是个exCRT题，然而学会之后来看，还是不会做</p>
<h3 id="前置芝士：exGCD"><a href="#前置芝士：exGCD" class="headerlink" title="前置芝士：exGCD"></a>前置芝士：exGCD</h3><p>貌似全世界都会啊。。。 $ax+by=c$，跑一次exGCD，求出一个$ax’+by’=(a,b)$的特解$x’$。 把原方程化成 $$a\frac{x’c}{(a,b)}+b\frac{y’c}{(a,b)}=c$$ 可以得到原方程一个解$\frac{x’c}{(a,b)}$。 通解的形式是 $$x’\frac{c}{(a,b)}+k\frac{b}{(a,b)}$$</p>
<h3 id="前置芝士：exCRT"><a href="#前置芝士：exCRT" class="headerlink" title="前置芝士：exCRT"></a>前置芝士：exCRT</h3><p>如果已经求得前面某些方程特解$x$，它们模数$p_i$有$m=lcm(p_i)$，那么带入下一条方程，$x+km \equiv a \pmod p$，可以求解一个$k$，$x=x+km$，继续算就行了。 如果$(m,p)\nmid a-x$，无解。</p>
<h3 id="本题做法："><a href="#本题做法：" class="headerlink" title="本题做法："></a>本题做法：</h3><p>发现可以预处理出来打每条龙的剑的攻击力。 用$g_i$表示打第$i$条龙剑的攻击力。 面向数据编程可知，本题中$a_i&gt;p_i$时，$p_i=1$，答案为$\lceil \frac{a_i}{g_i} \rceil$最大值。 $a_i\leq p_i$时，要想满足题意，有$a-gx \mod p = 0$，$gx \equiv a \pmod p$，先解出$x$，得到$x$的通解，化成模形式，此时$x$没有系数，用exCRT求解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>; LL b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL &amp;x, LL &amp;y, LL a, LL b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    LL gcd = <span class="built_in">exgcd</span>(y, x, b, a % b);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL x, LL y, LL z)</span> </span>&#123;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = x * <span class="number">2</span> % z)</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = (ret + x) % z;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">233</span>;</span><br><span class="line">LL a[N], p[N], g[N], s[N];</span><br><span class="line">std::multiset&lt;LL&gt; set;</span><br><span class="line">std::multiset&lt;LL&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>(), all_one = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        all_one &amp;= (p[i] = <span class="built_in">rd</span>()) == <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        s[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        set.<span class="built_in">insert</span>(<span class="built_in">rd</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        it = set.<span class="built_in">upper_bound</span>(a[i]);</span><br><span class="line">        <span class="keyword">if</span> (it != set.<span class="built_in">begin</span>())</span><br><span class="line">            --it;</span><br><span class="line">        g[i] = *it;</span><br><span class="line">        set.<span class="built_in">erase</span>(it);</span><br><span class="line">        set.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL ans = <span class="number">0</span>, lcm = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (all_one) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            ans = std::<span class="built_in">max</span>(ans, (a[i] + g[i] - <span class="number">1</span>) / g[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        LL x, y, gcd = <span class="built_in">exgcd</span>(x, y, g[i], p[i]);</span><br><span class="line">        <span class="keyword">if</span> (a[i] % gcd != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LL nx, ny, np = p[i] / gcd, na = (<span class="built_in">mul</span>(x, a[i] / gcd, np) + np) % np,</span><br><span class="line">            ngcd = <span class="built_in">exgcd</span>(nx, ny, lcm, np), nm = (((na - ans) % np) + np) % np;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nm % ngcd != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nx = <span class="built_in">mul</span>(nx, nm / ngcd, np / ngcd);</span><br><span class="line">        ans = ans + nx * lcm;</span><br><span class="line">        lcm = lcm * (np / ngcd);</span><br><span class="line">        ans %= lcm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (ans % lcm + lcm) % lcm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> T = <span class="built_in">rd</span>(); T; --T)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOI2019 游记</title>
    <url>/2019/07/19/noi2019-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>嗯。。。买了个D去旅游了，考的很爆炸，丢人。。。</p>
<h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h3><p>广州真热，在室外呆着汗就止不下来。。舍友有个上海的初一爷爷，OIerDB查了下，吓尿。。饭勉强能吃。</p>
<h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>开幕式出了点小锅，总体不错。笔试随便写了写，过了。试机的题都不会，有交互。emmmm，交互完全不会。晚上有点睡不着。</p>
<h3 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>嗯，看题，T1求最短路，那就最短路了，大力写代码，各种出bug，骗了80多分。想了想应该可以斜率优化dp，先放下了。 T2不会，20分暴力滚蛋。 T3自己yy了一个n的好几次放的暴力。打算写来着，想着多骗点分，然后仔细分析一下性质，发现了一些不错的贪心性质，能拿40分。敲代码，结果嘛，硬是没调出来。 下午查分，T3爆零了。应该先打暴力来着，自己还是too young啊。。。听讲题，T1斜率优化的确能过，T3考场yy的性质是对的。</p>
<h3 id="Day-1-5"><a href="#Day-1-5" class="headerlink" title="Day 1.5"></a>Day 1.5</h3><p>听说费用流也能40分，为什么要DP。。。。DP还没写出来，无限自闭中。。。 广州博物馆不错，不过相比之下，山西的那个真的强强。 下午颓废了。</p>
<h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>开题，T1又是最短路。。。KD Tree没写过怕yy不出来，二维线段树大约炸空间，写了70多部分分。 T2期望，这类题真的不会。。暴力走人 T3交互，猜图形状，暴力分20，想了个随机+分治的做法，码码码，然而死活卡不过去限制。。 下午查分。。。？？？？？？？T2暴力大约是炸了没分，认了。 T3CE？？？？？？看了下，应该是gedit的bug，保存大失败。。。。怪自己没再编译一次。。。真的丢人。。。 于是又自闭了。求了半天安慰，心情好多了♡ 嗯，大大小小加起来炸了70分，然后，居然过Cu线了。。。。收获垫底D类Cu一枚。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>菜是原罪，技不如人。1. 考试太少，经验不足，以后多考试。 NOI体验不错，好好学习，希望明年能再来一次。 恭喜学长们有学上了。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOI2020退役记</title>
    <url>/2332/08/19/noi2020%E9%80%80%E5%BD%B9%E8%AE%B0/</url>
    <content><![CDATA[<p>按惯例是要发这篇文章的，还是写一下 Day1T1考场上写了个很不一样的做法，十分难以维护（在下面），冲了三个多小时只有85。T2T3两个暴力，加起来96。 查分发现T1的long long没开全，变成20了。 发现T2是傻逼题，考场看到2^m部分分太香就没多想，血亏。 Day2T1考场冲了85分（剩下15分明显是bitset，感觉很难写丢了）。T2手玩了12分。T3冲了20分暴力。 快结束的时候发现T1少写了个case（m &gt; n时少个循环），挂成10分了。 查分发现T1拿了35，但是T2的12分挂了。 就很慌，感觉没银牌了。出榜发现Ag线是170多，压线Ag了。 没挂分的话应该是400多，最后280…….. 于是两天加起来差不多丢了140，从rk几十名变成了rk190多，退役了</p>
<hr>
<p>实话实说，我自认为实力是保前100冲集训队的。没想到变成了这样。 挺悲伤的，就这样吧。不知道垫底Ag有没有大学要。OI再见，文化课你好</p>
<hr>
<p>奇怪的T1做法： 考虑没有特殊点，走了很多步，会走出怎么样的路径：发现首先要走环，其次肯定走最优环，再其次肯定是简单环（最优）。那么环边权和就有上界了，DP出每个点走出的每种长度的最优环。 考虑加上特殊点怎么做：绕环若干圈，走到特殊点，再走回来。于是DP一下就可以了。</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>NOIP2005 循环</title>
    <url>/2019/07/10/noip2005-%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1050">循环</a> 为什么当年的普及组有这种题… 直接暴力不现实，一位一位的做。一个规律：每加入一位，循环节都会变成原来的倍数。 证明：其实可以感性理解一下，因为之前求的是最小循环节，当且仅当循环循环节倍数次，旧的那些数字不变。 还有一个结论：循环节长度最长为9。 证明：抽屉原理，10次可以把0到9都过一遍，如果还没有循环，那就是不循环了。 然后暴力做就行了。写个高精乘，直接乘那种。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">23333</span>, P = <span class="number">998244353</span>, G = <span class="number">3</span>, Gi = <span class="number">332748118</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lim = <span class="number">1</span>, L, rev[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">fpow</span><span class="params">(LL x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    LL ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = x * x % P)</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = ret * x % P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFT</span><span class="params">(LL f[], <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i])</span><br><span class="line">            std::<span class="built_in">swap</span>(f[i], f[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        LL T = <span class="built_in">fpow</span>(o == <span class="number">1</span> ? G : Gi, (P - <span class="number">1</span>) / (i &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += (i &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            LL w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k, w = w * T % P) &#123;</span><br><span class="line">                LL nx = f[j + k], ny = f[i + j + k] * w % P;</span><br><span class="line">                f[j + k] = (nx + ny) % P;</span><br><span class="line">                f[i + j + k] = (nx - ny + P) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> tmp[N];</span><br><span class="line"><span class="keyword">int</span> len, num[N], k;</span><br><span class="line">LL A[N], B[N], C[N], E[N], X[N];</span><br><span class="line">LL INV;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, tmp, &amp;k);</span><br><span class="line">    len = <span class="built_in">strlen</span>(tmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        num[i + <span class="number">1</span>] = tmp[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k &gt; len) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k, j = len; len &gt;= <span class="number">1</span>; --i, --j)</span><br><span class="line">            num[i] = num[j], num[j] = <span class="number">0</span>;</span><br><span class="line">        len = k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lim &lt;= len * <span class="number">2</span>)</span><br><span class="line">        lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line"></span><br><span class="line">    INV = <span class="built_in">fpow</span>(lim, P - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>)  ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    C[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i; --i)</span><br><span class="line">        B[len - i] = num[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DFT</span>(B, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> now = <span class="number">1</span>; now &lt;= k; ++now) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">            A[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i; --i)</span><br><span class="line">            A[len - i] = num[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = A[now - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">DFT</span>(A, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">            X[i] = B[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> step;</span><br><span class="line">        <span class="keyword">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">11</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; ++j)</span><br><span class="line">                E[j] = A[j] * B[j] % P;</span><br><span class="line">            <span class="built_in">DFT</span>(E, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; ++j)</span><br><span class="line">                E[j] = E[j] * INV % P;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                E[j + <span class="number">1</span>] += E[j] / <span class="number">10</span>;</span><br><span class="line">                E[j] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (E[now - <span class="number">1</span>] == start) &#123;</span><br><span class="line">                step = i;</span><br><span class="line">                ok = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; ++j)</span><br><span class="line">                    B[j] = B[j] * X[j] % P;</span><br><span class="line">                <span class="built_in">DFT</span>(B, <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; ++j)</span><br><span class="line">                    B[j] = B[j] * INV % P;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                    B[j + <span class="number">1</span>] += B[j] / <span class="number">10</span>;</span><br><span class="line">                    B[j] %= <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = len; j &lt; lim; ++j)</span><br><span class="line">                    B[j] = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">DFT</span>(B, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">            C[i] = C[i] * step;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) &#123;</span><br><span class="line">            C[i + <span class="number">1</span>] += C[i] / <span class="number">10</span>;</span><br><span class="line">            C[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = lim;</span><br><span class="line">    <span class="keyword">while</span> (!C[i]) --i;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, C[i--]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOIP2008双栈排序 二分图贪心</title>
    <url>/2019/10/30/noip2008%E5%8F%8C%E6%A0%88%E6%8E%92%E5%BA%8F-%E4%BA%8C%E5%88%86%E5%9B%BE%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P1155">双栈排序</a> 考试考了这个题… 考虑问题的简化版本：如果只有一个栈怎么办。可以发现，栈可以进行的事情，就是把原序列划分成若干不相交的段，每一段进行reverse操作。所以，一组形如$2,3,1$的数据就过不去了。 实际上，如果$\exists i &lt; j &lt; k, A_k &lt; A_i &lt; A_j $，那么$i,j$不可以存在于一个栈中。$O(n^2)$的建立一张对立关系的图并染色，可以判断每个位置可以放在哪个栈中。 然后考虑一个贪心的构造答案。由于加入总是比删除优，我们优先考虑加入，直到栈不满足从底到顶递减。注意$A$栈比$B$栈优先级高，需多次检查可否弹出。 <a href="https://www.luogu.org/paste/72drgto4">代码这里</a></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOIP2012开车旅行 倍增</title>
    <url>/2019/10/30/noip2012%E5%BC%80%E8%BD%A6%E6%97%85%E8%A1%8C-%E5%80%8D%E5%A2%9E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P1081">开车旅行</a> 考虑一个$70$分做法：可以发现对于每个人，从每个点出发，下一步到达的地方都是一定的。$O(n^2)$预处理每个人下一步到达的位置，即可$O(n)$回答询问。 优化上述两个过程。为了求出在一个点后面，且绝对值差与它小的点，可以使用STL set。$O(nlogn)$。然后考虑倍增，令$f_{x,k}$表示$x$出发，走$2^k$步到达的位置（显然是轮流走的），$g_{x,k,0 / 1}$表示$A,B$分别走过的距离。 可以发现除了$k=0$，每次都是$A$开始，$B$结尾的，因此可以简单倍增处理答案，$O(logn)$。 <a href="https://www.luogu.org/paste/qj6ng05o">代码戳这里啦</a></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOIP2009靶形数独</title>
    <url>/2019/01/05/noip2009%E9%9D%B6%E5%BD%A2%E6%95%B0%E7%8B%AC/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1074">Luogu P1074 靶形数独</a> 题意为把数独填好并且按照指定方式求出最大的和<br>即必须枚举数独所有的解法 思路：dfs+剪枝 首先解数独，三个bool数组xx,yy,zz，xx[i][j]表示x=i时本行是否有j 然后我们可以知道，按照每一行0数量多少排序，从0最少的一行开始dfs可以减少搜索次数 于是就有了下面的AC代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tot[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> ord[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">bool</span> xx[<span class="number">10</span>][<span class="number">10</span>], yy[<span class="number">10</span>][<span class="number">10</span>], zz[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> x_now;</span><br><span class="line"><span class="keyword">int</span> x_final;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_z</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (y &lt;= <span class="number">6</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt;= <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span> (y &lt;= <span class="number">6</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">if</span> (y &lt;= <span class="number">6</span>) <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_ans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rint sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (rint i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (rint j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; ++j) &#123;</span><br><span class="line">            sum += a[i][j] * w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_nxt</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">9</span>) y = <span class="number">1</span>, x = ord[x];</span><br><span class="line">    <span class="keyword">else</span> ++y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[x][y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == x_final &amp;&amp; y == <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="built_in">get_ans</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">get_nxt</span>(x, y);</span><br><span class="line">            <span class="built_in">dfs</span>(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> xxx = x, yyy = y;</span><br><span class="line">        <span class="built_in">get_nxt</span>(xxx, yyy);</span><br><span class="line">        <span class="keyword">for</span> (rint i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (xx[x][i]  yy[y][i]  zz[<span class="built_in">get_z</span>(x, y)][i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            xx[x][i] = yy[y][i] = zz[<span class="built_in">get_z</span>(x, y)][i] = <span class="literal">true</span>;</span><br><span class="line">            a[x][y] = i;</span><br><span class="line">            <span class="keyword">if</span> (x == x_final &amp;&amp; y == <span class="number">9</span>) &#123;</span><br><span class="line">                <span class="built_in">get_ans</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(xxx, yyy);</span><br><span class="line">            &#125;</span><br><span class="line">            a[x][y] = <span class="number">0</span>;</span><br><span class="line">            xx[x][i] = yy[y][i] = zz[<span class="built_in">get_z</span>(x, y)][i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (rint i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        tot[i].second = i;</span><br><span class="line">        <span class="keyword">for</span> (rint j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                ++tot[i].first;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                xx[i][a[i][j]]</span><br><span class="line">                    = yy[j][a[i][j]]</span><br><span class="line">                    = zz[<span class="built_in">get_z</span>(i, j)][a[i][j]]</span><br><span class="line">                    = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (rint i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (rint j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; ++j) &#123;</span><br><span class="line">            rint t = <span class="built_in">min</span>(<span class="built_in">min</span>(i, <span class="number">9</span> - i + <span class="number">1</span>), <span class="built_in">min</span>(j, <span class="number">9</span> - j + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">1</span>) w[i][j] = <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">2</span>) w[i][j] = <span class="number">7</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">3</span>) w[i][j] = <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">4</span>) w[i][j] = <span class="number">9</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">5</span>) w[i][j] = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(tot + <span class="number">1</span>, tot + <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (rint i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        ord[tot[i].second] = tot[i + <span class="number">1</span>].second;</span><br><span class="line">    &#125;</span><br><span class="line">    x_now = tot[<span class="number">1</span>].second;</span><br><span class="line">    x_final = tot[<span class="number">9</span>].second;</span><br><span class="line">    <span class="built_in">dfs</span>(x_now, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOIP2014 子矩阵</title>
    <url>/2019/02/23/noip2014-%E5%AD%90%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2258">NOIP2014 子矩阵</a> 首先，暴力枚举TLE，AC不能。发现如果确定了行，列有最优子结构性质可以DP，枚举行，DP列。定义f[i][j]表示前i列中选了j列，x[i]表示第i列的差值和，y[i][j]表示i列和j列的插值，则有f[i][j] = min{f[k][j - 1] + x[i] + y[k][i]}，边界是1 &lt;= i &lt;= m，1 &lt;= j &lt;= min(i, c)，j - 1 &lt;= k &lt;= i - 1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, r, c, ans = <span class="number">1e9</span>, f[N][N], g[N][N], x[N], y[N][N], choose[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tot == r + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(x)), <span class="built_in">memset</span>(y, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(y));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; r; ++j)</span><br><span class="line">                x[i] += <span class="built_in">abs</span>(g[choose[j + <span class="number">1</span>]][i] - g[choose[j]][i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> t = j + <span class="number">1</span>; t &lt;= m; ++t)</span><br><span class="line">                    y[j][t] += <span class="built_in">abs</span>(g[choose[i]][j] - g[choose[i]][t]);</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">min</span>(c, i); j; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">1</span>) f[i][j] = x[i];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> t = j - <span class="number">1</span>; t &lt;= i - <span class="number">1</span>; ++t)</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i][j], f[t][j - <span class="number">1</span>] + x[i] + y[t][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, f[i][c]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        choose[tot] = i, <span class="built_in">dfs</span>(i, tot + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; r &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOIP2012 疫情控制</title>
    <url>/2019/03/15/noip2012-%E7%96%AB%E6%83%85%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1084">疫情控制</a> 重构三次+调试到死才过。。。蒟蒻写代码，各种逗比BUG都出现了。。。 言归正转，这个题目中要求用军队堵住一些节点，让所有叶子和根不联通。题目要求一个最小时间，可以用二分+判定来做。 二分出一个限制时间$lim$。可以发现，军队肯定是越靠近根能堵住越多节点的。对于时间内到不了根的军队，留在能到的位置一定是最优方案。但是画一下样例就可以发现，对于能到达根的军队，有一些必须要越过根去控制其它子树。 先把到不了根的军队处理完，可以到根的放进数组$free[]$中，然后dfs找出没有被封锁的子树。记某军队为$x$，它属于根的某子节点$top$的子树，根到某个点的距离为$dis[x]$，下面给出一条性质： 从小到大依对$free[]$排序，然后如果$top$这个子树没有被控制，并且$dis[x]+dis[top] \ge lim$，那么它应该留在$top$。 证明：首先从代码实现上论证。最后进行判断的时候，我们采用贪心策略，用剩余路程最大的军队去最远的节点。$x$可以走到根再回到$top$，贪心时可以直接操作。然而如果这个军队无法再回去，就会错失可以到达的节点造成误判。然后论证正确性。如果$x$不去控制$top$，就需要其它地方的军队$y$越过根来控制它。然而如果$x$可以到达根再去控制一个其它节点，那么$y$直接控制那个节点可行且更优，所以$x$直接留下即可。 所以按照此策略处理，再次找出没有被封锁的子树，贪心的考虑能否控制即可。 题目中要把军队向根移动，暴力复杂度太高，可以倍增实现。总复杂度$O(nlognlog\sum w)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50000</span> + <span class="number">2333</span>, T = <span class="number">20</span>, S = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> to[N * <span class="number">2</span>], nxt[N * <span class="number">2</span>], c[N * <span class="number">2</span>], head[N], tot;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">            to[++tot] = y, nxt[tot] = head[x],</span><br><span class="line">            c[tot] = z, head[x] = tot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; g;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, army[N], que[N], head, tail, fa[N][<span class="number">25</span>],</span><br><span class="line">        top[N], not_ok_cnt, free_army_cnt;</span><br><span class="line">    ll dis[N], not_ok[N];</span><br><span class="line">    <span class="keyword">bool</span> vis[N];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Free_Army</span> &#123;</span> ll free_dis; <span class="keyword">int</span> top; &#125; free_army[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>(), c = <span class="built_in">rd</span>();</span><br><span class="line">            g.<span class="built_in">addedge</span>(x, y, c), g.<span class="built_in">addedge</span>(y, x, c);</span><br><span class="line">        &#125;</span><br><span class="line">        m = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) army[i] = <span class="built_in">rd</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vis[que[tail = <span class="number">1</span>] = S] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = que[++head];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = g.head[x]; i; i = g.nxt[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = g.to[i];</span><br><span class="line">                <span class="keyword">if</span> (!vis[y]) &#123;</span><br><span class="line">                    vis[que[++tail] = y] = <span class="literal">true</span>;</span><br><span class="line">                    fa[y][<span class="number">0</span>] = x;</span><br><span class="line">                    dis[y] = dis[x] + g.c[i];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= T; ++j)</span><br><span class="line">                        fa[y][j] = fa[fa[y][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = army[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = T; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">                <span class="keyword">if</span> (fa[x][j] &gt; <span class="number">1</span>) x = fa[x][j];</span><br><span class="line">            top[army[i]] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = g.head[x]; i; i = g.nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = g.to[i];</span><br><span class="line">            <span class="keyword">if</span> (y != father) &#123;</span><br><span class="line">                ok = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!vis[y] &amp;&amp; !<span class="built_in">dfs</span>(y, x))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ok;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">comp1</span><span class="params">(<span class="keyword">const</span> Free_Army &amp;x, <span class="keyword">const</span> Free_Army &amp;y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.free_dis &lt; y.free_dis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">comp2</span><span class="params">(<span class="keyword">const</span> Free_Army &amp;x, <span class="keyword">const</span> Free_Army &amp;y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.free_dis &gt; y.free_dis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">comp3</span><span class="params">(ll x, ll y)</span> </span>&#123; <span class="keyword">return</span> x &gt; y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(ll lim)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">        not_ok_cnt = free_army_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[army[i]] &gt;= lim) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = army[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = T; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">                    <span class="keyword">if</span> (fa[x][j] &gt; <span class="number">1</span> &amp;&amp; dis[army[i]] - dis[fa[x][j]] &lt;= lim)</span><br><span class="line">                        x = fa[x][j];</span><br><span class="line">                vis[x] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                free_army[++free_army_cnt].top = top[army[i]];</span><br><span class="line">                free_army[free_army_cnt].free_dis = lim - dis[army[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = g.head[S]; i; i = g.nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = g.to[i];</span><br><span class="line">            <span class="keyword">if</span> (!vis[y] &amp;&amp; <span class="built_in">dfs</span>(y, S))</span><br><span class="line">                vis[y] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(free_army + <span class="number">1</span>, free_army + free_army_cnt + <span class="number">1</span>, comp1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= free_army_cnt; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[free_army[i].top] &amp;&amp; free_army[i].free_dis &lt; dis[free_army[i].top]) &#123;</span><br><span class="line">                vis[free_army[i].top] = <span class="literal">true</span>;</span><br><span class="line">                free_army[i].free_dis = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = g.head[S]; i; i = g.nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = g.to[i];</span><br><span class="line">            <span class="keyword">if</span> (!vis[y] &amp;&amp; !<span class="built_in">dfs</span>(y, S))</span><br><span class="line">                not_ok[++not_ok_cnt] = dis[y];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (not_ok_cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (not_ok_cnt &gt; free_army_cnt) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(free_army + <span class="number">1</span>, free_army + free_army_cnt + <span class="number">1</span>, comp2);</span><br><span class="line">        <span class="built_in">sort</span>(not_ok + <span class="number">1</span>, not_ok + not_ok_cnt + <span class="number">1</span>, comp3);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= not_ok_cnt; ++i)</span><br><span class="line">            <span class="keyword">if</span> (not_ok[i] &gt; free_army[i].free_dis)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ll l = <span class="number">0</span>, r = <span class="number">0</span>, mid, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g.tot; i += <span class="number">2</span>)</span><br><span class="line">            r += g.c[i];</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">judge</span>(mid)) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">prework</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOIP2016 天天爱跑步</title>
    <url>/2019/07/06/noip2016-%E5%A4%A9%E5%A4%A9%E7%88%B1%E8%B7%91%E6%AD%A5/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1600">天天爱跑步</a> 被NOIP题虐出翔… 一条一条路径处理显然是不科学的，要一起处理。一条$x \to y$的路径，$lca(x,y)$可能是$x,y$中的一个点，也可能不是。如果不是，把路径拆成两部分。 然后我们得到了一堆给定起点终点，向上或者向下的路径。稍加推导可以发现，路径是否可以被一个点看到，取决于这个点的$w$和路径起点的$dep$（对于被拆开的$lca\to y$的路径，$dep$比$lca$更浅）。 这样，开个桶，然后DFS，就可做了。 然而直接这么做样例都过不去。在DFS的过程中，桶里会存下不在当前链的信息。举个例子，$x\to y, x \to z$，DFS完$z$子树之后，又去DFS$y$子树。此时$z$子树中一些结束点在$x$祖先的路径还在桶里，就凉了。 可以复杂的分类讨论解决这个问题。不过我用了一点也不NOIP的解法：线段树合并。用线段树表示桶，暴力合并就可以了。 树剖 + 线段树合并 = 一道NOIP题… 我菜的真实…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cerr;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300000</span> + <span class="number">23333</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> to[N * <span class="number">2</span>], nxt[N * <span class="number">2</span>], head[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    to[++tot] = y;</span><br><span class="line">    nxt[tot] = head[x];</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N], son[N], size[N], dep[N], top[N], num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[x] = f; size[x] = <span class="number">1</span>; dep[x] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y != f) &#123;</span><br><span class="line">            <span class="built_in">dfs1</span>(y, x);</span><br><span class="line">            <span class="keyword">if</span> (size[y] &gt; size[son[x]])</span><br><span class="line">                son[x] = y;</span><br><span class="line">            size[x] += size[y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line">    top[x] = topf;</span><br><span class="line">    <span class="keyword">if</span> (!son[x])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], topf);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y != fa[x] &amp;&amp; y != son[x])</span><br><span class="line">            <span class="built_in">dfs2</span>(y, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]])</span><br><span class="line">            std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &lt; dep[y])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, w[N], vlca[N], ans[N], cnt[N * <span class="number">2</span>];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; add_up[N], add_down[N], del_up[N], del_down[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ls[N * <span class="number">10</span>], rs[N * <span class="number">10</span>], val[N * <span class="number">10</span>], root[N], seg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) p = ++seg;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        val[p] += y;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">        <span class="built_in">add</span>(ls[p], x, y, L, mid);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">add</span>(rs[p], x, y, mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> val[p];</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(ls[p], x, L, mid);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(rs[p], x, mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!x) &#123; x = y; <span class="keyword">return</span>; &#125;</span><br><span class="line">    val[x] += val[y];</span><br><span class="line">    <span class="built_in">merge</span>(ls[x], ls[y]);</span><br><span class="line">    <span class="built_in">merge</span>(rs[x], rs[y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_seg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ls, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ls));</span><br><span class="line">    <span class="built_in">memset</span>(rs, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(rs));</span><br><span class="line">    <span class="built_in">memset</span>(val, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(val));</span><br><span class="line">    <span class="built_in">memset</span>(root, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(root));</span><br><span class="line">    seg = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y != fa[x]) &#123;</span><br><span class="line">            <span class="built_in">solve_down</span>(y);</span><br><span class="line">            <span class="built_in">merge</span>(root[x], root[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; add_down[x].<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="built_in">add</span>(root[x], add_down[x][i] + N, <span class="number">1</span>, <span class="number">0</span>, N * <span class="number">2</span>);</span><br><span class="line">    ans[x] += <span class="built_in">query</span>(root[x], dep[x] - w[x] + N, <span class="number">0</span>, N * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; del_down[x].<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="built_in">add</span>(root[x], del_down[x][i] + N, <span class="number">-1</span>, <span class="number">0</span>, N * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y != fa[x]) &#123;</span><br><span class="line">            <span class="built_in">solve_up</span>(y);</span><br><span class="line">            <span class="built_in">merge</span>(root[x], root[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; add_up[x].<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="built_in">add</span>(root[x], add_up[x][i], <span class="number">1</span>, <span class="number">0</span>, N * <span class="number">2</span>);</span><br><span class="line">    ans[x] += <span class="built_in">query</span>(root[x], dep[x] + w[x], <span class="number">0</span>, N * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; del_up[x].<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="built_in">add</span>(root[x], del_up[x][i], <span class="number">-1</span>, <span class="number">0</span>, N * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(); m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">addedge</span>(x, y);</span><br><span class="line">        <span class="built_in">addedge</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        w[i] = <span class="built_in">rd</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>(), lca = <span class="built_in">get_lca</span>(x, y);</span><br><span class="line">        <span class="keyword">if</span> (x == lca) &#123;</span><br><span class="line">            add_down[y].<span class="built_in">push_back</span>(dep[x]);</span><br><span class="line">            del_down[x].<span class="built_in">push_back</span>(dep[x]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == lca) &#123;</span><br><span class="line">            add_up[x].<span class="built_in">push_back</span>(dep[x]);</span><br><span class="line">            del_up[y].<span class="built_in">push_back</span>(dep[x]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            add_up[x].<span class="built_in">push_back</span>(dep[x]);</span><br><span class="line">            del_up[lca].<span class="built_in">push_back</span>(dep[x]);</span><br><span class="line">            <span class="keyword">if</span> (dep[x] - dep[lca] == w[lca])</span><br><span class="line">                ++vlca[lca];</span><br><span class="line">            add_down[y].<span class="built_in">push_back</span>(dep[lca] * <span class="number">2</span> - dep[x]);</span><br><span class="line">            del_down[lca].<span class="built_in">push_back</span>(dep[lca] * <span class="number">2</span> - dep[x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">solve_down</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">init_seg</span>();</span><br><span class="line">    <span class="built_in">solve_up</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i] - vlca[i]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOIP2017 列队</title>
    <url>/2019/07/07/noip2017-%E5%88%97%E9%98%9F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3960">列队</a> 正解树状数组，不会。动态开点线段树可做，不想分类讨论，放弃。Splay暴力，A了。 开$n+1$个Splay，$n$行每行一个，最后一列单独开一个。用平衡树上一个点表示一段区间，需要用某个点的时候把区间拆开拆出这个点。 然后暴力模拟题意就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">2333</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch[N][<span class="number">2</span>], fa[N], size[N], tot, root[N];</span><br><span class="line">LL id_l[N], id_r[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    size[x] = size[ch[x][<span class="number">0</span>]] + size[ch[x][<span class="number">1</span>]] + id_r[x] - id_l[x] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = fa[x], z = fa[y], k = ch[y][<span class="number">1</span>] == x;</span><br><span class="line">    ch[z][ch[z][<span class="number">1</span>] == y] = x; fa[x] = z;</span><br><span class="line">    ch[y][k] = ch[x][k ^ <span class="number">1</span>]; fa[ch[y][k]] = y;</span><br><span class="line">    ch[x][k ^ <span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">    <span class="built_in">pushup</span>(y); <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> tar, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (fa[x] != tar) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = fa[x], z = fa[y];</span><br><span class="line">        <span class="keyword">if</span> (z != tar)</span><br><span class="line">            <span class="built_in">rotate</span>((ch[z][<span class="number">1</span>] == y) ^ (ch[y][<span class="number">1</span>] == x) ? x : y);</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!tar) root[which] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_kth</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = root[which];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (size[ch[x][<span class="number">0</span>]] &lt; k &amp;&amp; size[ch[x][<span class="number">0</span>]] + id_r[x] - id_l[x] + <span class="number">1</span> &gt;= k) &#123;</span><br><span class="line">            k -= size[ch[x][<span class="number">0</span>]];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size[ch[x][<span class="number">0</span>]] &gt;= k)</span><br><span class="line">            x = ch[x][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            k -= size[ch[x][<span class="number">0</span>]] + id_r[x] - id_l[x] + <span class="number">1</span>;</span><br><span class="line">            x = ch[x][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = id_r[x] - id_l[x] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k != <span class="number">1</span>) &#123;</span><br><span class="line">        id_l[++tot] = id_l[x]; id_r[tot] = id_l[x] + k - <span class="number">2</span>;</span><br><span class="line">        id_l[x] = id_r[tot] + <span class="number">1</span>;</span><br><span class="line">        ch[fa[x]][ch[fa[x]][<span class="number">1</span>] == x] = tot; fa[tot] = fa[x];</span><br><span class="line">        fa[x] = tot; ch[tot][<span class="number">1</span>] = x;</span><br><span class="line">        ch[tot][<span class="number">0</span>] = ch[x][<span class="number">0</span>]; fa[ch[x][<span class="number">0</span>]] = tot; ch[x][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k != len) &#123;</span><br><span class="line">        id_l[++tot] = id_r[x] - len + <span class="number">1</span> + k;</span><br><span class="line">        id_r[tot] = id_r[x]; id_r[x] = id_l[tot] - <span class="number">1</span>;</span><br><span class="line">        fa[ch[x][<span class="number">1</span>]] = tot; ch[tot][<span class="number">1</span>] = ch[x][<span class="number">1</span>];</span><br><span class="line">        ch[x][<span class="number">1</span>] = tot; fa[tot] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">splay</span>(ch[x][<span class="number">1</span>] ? ch[x][<span class="number">1</span>] : x, <span class="number">0</span>, which);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(LL l, LL r, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = root[which], f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) x = ch[f = x][<span class="number">1</span>];</span><br><span class="line">    id_l[++tot] = l; id_r[tot] = r;</span><br><span class="line">    <span class="keyword">if</span> (f) fa[tot] = f, ch[f][<span class="number">1</span>] = tot;</span><br><span class="line">    <span class="built_in">splay</span>(tot, <span class="number">0</span>, which);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">splay</span>(x, <span class="number">0</span>, which);</span><br><span class="line">    <span class="keyword">if</span> (!ch[x][<span class="number">0</span>]) &#123;</span><br><span class="line">        root[which] = ch[x][<span class="number">1</span>];</span><br><span class="line">        fa[ch[x][<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> y = ch[x][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (ch[y][<span class="number">1</span>]) y = ch[y][<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">splay</span>(y, x, which);</span><br><span class="line">        ch[y][<span class="number">1</span>] = ch[x][<span class="number">1</span>]; fa[ch[x][<span class="number">1</span>]] = y;</span><br><span class="line">        fa[y] = <span class="number">0</span>; root[which] = y;</span><br><span class="line">        <span class="built_in">pushup</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>(), q = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">insert</span>((LL)(i - <span class="number">1</span>) * m + <span class="number">1</span>, (LL)i * m - <span class="number">1</span>, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">insert</span>((LL)i * m, (LL)i * m, n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">if</span> (y == m) &#123;</span><br><span class="line">            <span class="keyword">int</span> baka = <span class="built_in">get_kth</span>(x, n + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, id_l[baka]);</span><br><span class="line">            <span class="built_in">remove</span>(baka, n + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">insert</span>(id_l[baka], id_r[baka], n + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> baka = <span class="built_in">get_kth</span>(y, x), qaq = <span class="built_in">get_kth</span>(x, n + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, id_l[baka]);</span><br><span class="line">            <span class="built_in">remove</span>(baka, x);</span><br><span class="line">            <span class="built_in">insert</span>(id_l[qaq], id_r[qaq], x);</span><br><span class="line">            <span class="built_in">remove</span>(qaq, n + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">insert</span>(id_l[baka], id_r[baka], n + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOIP2018 摆渡车 斜率优化DP</title>
    <url>/2019/09/16/noip2018-%E6%91%86%E6%B8%A1%E8%BD%A6-%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P5017">摆渡车</a> 斜率优化这玩意一直都是嘴巴过题，基本没写过，于是PJ水题居然调不出来。。。。。。丢死人 DP式子很简单。$f_i$为到时间$i$答案，令$c_i,s_i$分别为到$i$有的人数，人时间前缀和。 $$f_i=\min_{j=1}^{i-m} f_j+(c_i-c_j)i + (s_i-s_j)$$ 斜率优化一下，令$j &lt; k, f_j &gt; f_k$ $$i &gt; \frac{(f_k+s_k)-(f_j+s_j)}{c_k-c_j} $$ 维护下凸包即可。 然后就是代码的坑了。。。</p>
<ol>
<li>可能$c_k-c_j$相同。此时，比较两点$y$的大小</li>
<li>可以转移来的状态是$i-m$来的</li>
<li>$[1,m]$的$f$需要预处理。然后，从$m$开始向后计算，因为$f_{m-m}=f_0$可以使用。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, mx, s[N], c[N], f[N], que[N], l = <span class="number">1</span>, r = <span class="number">1</span>, ans = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * ((f[y] + s[y]) - (f[x] + s[x])) / (c[x] == c[y] ? <span class="number">1e-9</span> : c[y] - c[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">rd</span>();</span><br><span class="line">        ++c[t];</span><br><span class="line">        s[t] += t;</span><br><span class="line">        mx = std::<span class="built_in">max</span>(mx, t);</span><br><span class="line">    &#125;</span><br><span class="line">    mx += m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mx; ++i) &#123;</span><br><span class="line">        c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        f[i] = i * c[i] - s[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= mx; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">slope</span>(que[r - <span class="number">1</span>], que[r]) &gt;= <span class="built_in">slope</span>(que[r], i - m))</span><br><span class="line">            --r;</span><br><span class="line">        que[++r] = i - m;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">slope</span>(que[l], que[l + <span class="number">1</span>]) &lt;= i)</span><br><span class="line">            ++l;</span><br><span class="line">        f[i] = f[que[l]] + (c[i] - c[que[l]]) * i - (s[i] - s[que[l]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mx - m; i &lt;= mx; ++i)</span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOIP2017 逛公园</title>
    <url>/2019/07/08/noip2017-%E9%80%9B%E5%85%AC%E5%9B%AD/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3953">逛公园</a> 首先因为路径不能长于最短路径$+k$，可以推出在任意点都不能走该点到终点最短路$+k$以上的长度。求一下到终点最短路$dis[x]$，用$f[x][k]$表示$x$点，多走了$k$，$f[x][k] = \sum f[y][k-dis[y]+dis[x]-cost]$。记忆化搜索。判断零环，就用一个数组记录$in[x][k]$是否存在即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200000</span> + <span class="number">2333</span>, M = <span class="number">400000</span> + <span class="number">2333</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, d, k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> p;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span> <span class="keyword">int</span> to, nxt, cost; &#125; g[M * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head1[N], head2[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> head[], <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    g[++tot] = &#123; y, head[x], c &#125;;</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[N]; <span class="keyword">bool</span> vis[N];</span><br><span class="line">std::priority_queue&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> head[], <span class="keyword">int</span> st)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    dis[st] = <span class="number">0</span>; que.<span class="built_in">push</span>(&#123; <span class="number">0</span>, st &#125;);</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = que.<span class="built_in">top</span>().second; que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dis[y] &gt; dis[x] + g[i].cost) &#123;</span><br><span class="line">                dis[y] = dis[x] + g[i].cost;</span><br><span class="line">                que.<span class="built_in">push</span>(&#123; -dis[y], y &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mem[N][<span class="number">55</span>];</span><br><span class="line"><span class="keyword">bool</span> in[N][<span class="number">55</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> head[], <span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in[x][k]) <span class="keyword">throw</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (mem[x][k]) <span class="keyword">return</span> mem[x][k];</span><br><span class="line">    in[x][k] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = x == n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to, c = k - dis[y] + dis[x] - g[i].cost;</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="number">0</span> &amp;&amp; c &lt;= ::k)</span><br><span class="line">            ret = (ret + <span class="built_in">dfs</span>(head, y, c)) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    in[x][k] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> mem[x][k] = ret % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head1, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head1));</span><br><span class="line">    <span class="built_in">memset</span>(head2, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head2));</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(g));</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(in));</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(mem));</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>(), k = <span class="built_in">rd</span>(), p = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>(), c = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">addedge</span>(head1, x, y, c);</span><br><span class="line">        <span class="built_in">addedge</span>(head2, y, x, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>(head1, <span class="number">1</span>); d = dis[n];</span><br><span class="line">    <span class="built_in">dijkstra</span>(head2, n);</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">dfs</span>(head1, <span class="number">1</span>, k)); &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">int</span> x) &#123; <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> QAQ = <span class="built_in">rd</span>(); <span class="keyword">while</span> (QAQ--) <span class="built_in">init</span>(), <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOIP2018保卫王国 动态DP</title>
    <url>/2019/11/13/noip2018%E4%BF%9D%E5%8D%AB%E7%8E%8B%E5%9B%BD-%E5%8A%A8%E6%80%81dp/</url>
    <content><![CDATA[<p><a href="https://loj.ac/problem/2955">保卫王国</a> 因为luogu上DDP板子是独立集所以就写了这个版本 我们可以发现这题要求的是最小覆盖,最小覆盖=全集-最大独立集,我们可以考虑求独立集 可以写一个naive的暴力DP,令$f_{x,0/1}$分别表示$x$,选或不选 $$f_{x,0} = \sum \max f_{y,0}, f_{y,1}$$ $$f_{x,1} = A_x + \sum f_{y,0}$$ 记录$g_{x,0/1}$,维护轻儿子的信息 记$y$为$x$的重儿子,这样定义$g$: $$f_{x,0} = g_{x,0} + \max f_{y,0}, f_{y,1}$$ $$f_{x,1} = g_{x,1} + f_{y,0}$$ 然后改写一下 $$f_{x,0} = \max \lbrace g_{x,0} + f_{y,0}, g_{x,0} + f_{y,1} \rbrace$$ $$f_{x,1} = \max \lbrace g_{x,1} + f_{y,0}, -\infty \rbrace$$ 我们重载矩阵的乘法操作,定义如下 $$C_{i,j} = \max A_{i,k} + B_{k,j}$$ 这样的矩阵乘法依然有好的性质: 满足结合率 所以可以用矩阵维护DP. 链剖,然后一条链上用线段树维护矩阵. 转移是从下往上的,然而线段树方向相反,所以转移矩阵在前,要写成这样 $$ \begin{bmatrix} g_{x,0} &amp; g_{x,0} \ g_{x,1} &amp; -\infty \end{bmatrix} \begin{bmatrix} f_{y,0} \ f_{y,1} \end{bmatrix}= \begin{bmatrix} f_{x,0} \ f_{x,1} \end{bmatrix} $$ 然后就可以做了 一些细节:一个点的值,是它在的链底到它乘积. 计算的时候要用到链底,所以要记录. 跳链的时候记录旧值新值,以计算新贡献 重链剖分$O(nlog^2n)$ 如果用LCT是$O(nlogn)$,不过跑得更慢 回到本题,强制选和不选可以用赋值为正负无穷解决,然后套板子就行</p>
<hr>
<p>当然实际上这个题也可以倍增. 大概思路就是我们发现钦定$a,b$状态之后,发现答案分成三部分: $a,b$的子树,二者之间的链,$lca$到根. 然后考虑倍增,$f_{x,i,j,k}$表示$x$跳了$2^i$次,两端点状态为$j,k$.合并两端的时候,枚举中间点的状态取最优,大力分类讨论即可$O(nlogn)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e15</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, A[N];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"><span class="keyword">int</span> fa[N], son[N], top[N], size[N], dep[N],</span><br><span class="line">  dfn[N], id[N], num, end[N];</span><br><span class="line">ll sum, f[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">  ll mat[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">  <span class="built_in">Matrix</span>() &#123;</span><br><span class="line">    <span class="built_in">memset</span>(mat, <span class="number">0xcf</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(mat));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">inline</span> ll* <span class="keyword">operator</span>[](<span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> mat[x];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">inline</span> Matrix <span class="keyword">operator</span>*(Matrix y) &#123;</span><br><span class="line">    Matrix ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; ++k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j)</span><br><span class="line">          ret.mat[i][j] = std::<span class="built_in">max</span>(ret.mat[i][j], mat[i][k] + y[k][j]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Matrix g[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span> &#123;</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> ls(p) p &lt;&lt; 1</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> rs(p) p &lt;&lt; 1  1</span></span><br><span class="line">  Matrix mat[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    mat[p] = mat[<span class="built_in">ls</span>(p)] * mat[<span class="built_in">rs</span>(p)];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">void</span>)(mat[p] = g[id[l]]);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(p), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R)</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">void</span>)(mat[p] = g[id[x]]);</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">      <span class="built_in">change</span>(<span class="built_in">ls</span>(p), x, L, mid);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">change</span>(<span class="built_in">rs</span>(p), x, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Matrix <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R)</span><br><span class="line">      <span class="keyword">return</span> mat[p];</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid &amp;&amp; r &gt; mid)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r, L, mid)</span><br><span class="line">        * <span class="built_in">query</span>(<span class="built_in">rs</span>(p), l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r, L, mid);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(p), l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  size[x] = <span class="number">1</span>; dep[x] = dep[fa[x]] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y : G[x]) <span class="keyword">if</span> (y != fa[x]) &#123;</span><br><span class="line">    fa[y] = x; <span class="built_in">dfs1</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (size[y] &gt; size[son[x]])</span><br><span class="line">      son[x] = y;</span><br><span class="line">    size[x] += size[y];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line">  top[x] = topf; dfn[x] = ++num;</span><br><span class="line">  id[num] = x; end[topf] = x;</span><br><span class="line"></span><br><span class="line">  f[x][<span class="number">0</span>] = <span class="number">0</span>, f[x][<span class="number">1</span>] = A[x];</span><br><span class="line">  g[x][<span class="number">0</span>][<span class="number">0</span>] = g[x][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  g[x][<span class="number">1</span>][<span class="number">0</span>] = A[x];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!son[x])</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">dfs2</span>(son[x], topf);</span><br><span class="line"></span><br><span class="line">  f[x][<span class="number">0</span>] += std::<span class="built_in">max</span>(f[son[x]][<span class="number">0</span>], f[son[x]][<span class="number">1</span>]);</span><br><span class="line">  f[x][<span class="number">1</span>] += f[son[x]][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y : G[x])</span><br><span class="line">    <span class="keyword">if</span> (y != fa[x] &amp;&amp; y != son[x]) &#123;</span><br><span class="line">      <span class="built_in">dfs2</span>(y, y);</span><br><span class="line">      f[x][<span class="number">0</span>] += std::<span class="built_in">max</span>(f[y][<span class="number">0</span>], f[y][<span class="number">1</span>]);</span><br><span class="line">      f[x][<span class="number">1</span>] += f[y][<span class="number">0</span>];</span><br><span class="line">      g[x][<span class="number">0</span>][<span class="number">0</span>] += std::<span class="built_in">max</span>(f[y][<span class="number">0</span>], f[y][<span class="number">1</span>]);</span><br><span class="line">      g[x][<span class="number">0</span>][<span class="number">1</span>] = g[x][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">      g[x][<span class="number">1</span>][<span class="number">0</span>] += f[y][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, ll y)</span> </span>&#123;</span><br><span class="line">  g[x][<span class="number">1</span>][<span class="number">0</span>] += y - A[x];</span><br><span class="line">  A[x] = y;</span><br><span class="line"></span><br><span class="line">  Matrix pre, nxt;</span><br><span class="line">  <span class="keyword">while</span> (x) &#123;</span><br><span class="line">    pre = tree.<span class="built_in">query</span>(<span class="number">1</span>, dfn[top[x]], dfn[end[top[x]]], <span class="number">1</span>, n);</span><br><span class="line">    tree.<span class="built_in">change</span>(<span class="number">1</span>, dfn[x], <span class="number">1</span>, n);</span><br><span class="line">    nxt = tree.<span class="built_in">query</span>(<span class="number">1</span>, dfn[top[x]], dfn[end[top[x]]], <span class="number">1</span>, n);</span><br><span class="line">    x = fa[top[x]];</span><br><span class="line"></span><br><span class="line">    g[x][<span class="number">0</span>][<span class="number">0</span>] += std::<span class="built_in">max</span>(nxt[<span class="number">0</span>][<span class="number">0</span>], nxt[<span class="number">1</span>][<span class="number">0</span>]) - std::<span class="built_in">max</span>(pre[<span class="number">0</span>][<span class="number">0</span>], pre[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    g[x][<span class="number">0</span>][<span class="number">1</span>] = g[x][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    g[x][<span class="number">1</span>][<span class="number">0</span>] += nxt[<span class="number">0</span>][<span class="number">0</span>] - pre[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">  &#123; <span class="keyword">char</span> op[<span class="number">5</span>]; <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op); &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    sum += (A[i] = <span class="built_in">rd</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">    G[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    G[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  tree.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="built_in">rd</span>(), x = <span class="built_in">rd</span>(), b = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">if</span> (!x &amp;&amp; !y &amp;&amp; (fa[a] == b  fa[b] == a)) &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll tmp_a = A[a], tmp_b = A[b];</span><br><span class="line">    ll new_a = !x ? INF : -INF,</span><br><span class="line">      new_b = !y ? INF : -INF;</span><br><span class="line">    <span class="built_in">update</span>(a, new_a);</span><br><span class="line">    <span class="built_in">update</span>(b, new_b);</span><br><span class="line">    Matrix ans = tree.<span class="built_in">query</span>(<span class="number">1</span>, dfn[<span class="number">1</span>], dfn[end[<span class="number">1</span>]], <span class="number">1</span>, n);</span><br><span class="line">    ll tmp = sum - tmp_a - tmp_b;</span><br><span class="line">    tmp += std::<span class="built_in">max</span>(new_a, tmp_a) + std::<span class="built_in">max</span>(new_b, tmp_b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, tmp - std::<span class="built_in">max</span>(ans[<span class="number">0</span>][<span class="number">0</span>], ans[<span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">    <span class="built_in">update</span>(a, tmp_a);</span><br><span class="line">    <span class="built_in">update</span>(b, tmp_b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NOIP2018游记</title>
    <url>/2019/01/05/noip2018%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h2><p>月考考完的周末就是初赛，期中考完的周末就是复赛…期中考炸了，郁闷了一天，晚上翘了一节晚自习去机房玩，做蚯蚓，没有思考的暴力打了85分…要是每道题都这么好骗分该多好</p>
<h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>上午摸鱼，下午去临汾了 火车上快乐聊天，还打了会osu! cwy无限循环新宝岛↓ 下午住进酒店了，旁边有个“IOI”大楼，去临汾一中试机 <img src="/wp-content/uploads/2019/01/20181109_155739.jpg" alt="IOI"> 晚餐在临汾一中食堂解决，全是五中的人？？orzzzz，说实话，不是很好吃，没带泡面有点伤心</p>
<h2 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>早晨起来，没胃口早饭基本没吃。。洛谷签到，大吉！ 第一次参加NOIP，有点紧张，加上没穿外套去，缩在座位上瑟瑟发抖 一共就半个机房的Linux，周围一圈全是dalao，蒟蒻心里只有膜拜！！ 解压，密码是纪念金庸的！然而一次没打对… CCF的老爷机换成了i7！还是8700k！内存32G！每道题都是512M！感觉有点良心0w0 看题，T1看到区间，刚自学了区间DP，联想到区间dp。然而一看数据范围…打扰了。。。 纸上画了画，发现是一块一块的处理，找了下规律，可以直接读进来，答案和比上一个高还是低有关。随便写了写，大样例过了！ T2看完小样例没看懂，打开大样例找了几个长的手算。。发现是用其中一部分数拼其它数。 然而我不知道为什么，去用扩展欧几里得推了！！！还推了几十分钟！！！！！！QAQ！！！然后突然反应过来不一定和两个数字有关。。 最鶸的是，我还没想到完全背包，只好写了个dfs凑数。。大样例秒过，就去做T3了。。（事后dalao们说是中样例，凉凉 T3，看出来要二分，然而不会找赛道。。。看数据骗分，感觉有50多分可以骗到。。 然而抱着不能放弃的心情，又研究了一会正解，直接导致时间不够用。。。50分暴力都没打完，菊花图没动，就打了个直径和链表滚粗 出来一问，全世界只有我一个人不知道是完全背包… Day1凉凉 下午睡觉吃饭摸鱼打游戏，放弃治疗了。。有dalao说三道题都是原题，各种花样AK。。。蒟蒻受到了降维打击QAQ</p>
<h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>Day1还开玩笑，js和zj的1=线要500分，今天直接破冷水。。。 T1 60%的数据是树，建图排序贪心切了。。剩下的看出来要破环，然而！！！不会写！！！码力不足，退役了！！！ T2 ？？？？？？？？？？？？Day1的T2仿佛只有我不会，所以心里想着一定要切掉T2。。推了两小时，什么也没推出来，暴力也没打。。。。凉凉。。。。 T3 没时间了，分都没骗。。。。。其实按照数据范围可以骗到不少分的。。告辞！！！！！！ 于是乎，干坐了三个半小时，写了几十分的代码。。。 其实本来如果没抱着找到正解的心态去，全打暴力骗分，这次NOIP能多点分的。。。然而后悔没有用啊。。。 十二点40才出来，下午一点的火车，飞奔到火车站，没心情写作业，睡觉了。。。</p>
<h2 id="吐槽-amp-后记"><a href="#吐槽-amp-后记" class="headerlink" title="吐槽&amp;后记"></a>吐槽&amp;后记</h2><p>考前爆肝肝出来的复习模板，基本一个也没考？？？考的一个也不会，打扰了 这次居然没有模拟题，其实模拟骗分还是很简单的。。被dp和图论打爆了</p>
<hr>
<p>Update 2018.12.4： 分数和分数线都出来了，完美GG 所有民间数据都过了1=线，只有官方没过…差了10多分。。 要是我d1背包写出来，要是我d1t3的二分没写错，要是我d2t1当时会断环，要是没死算d2t2…我就有1=了… 后悔也没用，想了半天，总结出一个字：鶸 其实当时学了三个多月，混270分也不算太不能看。。。NOIP2019，再接再厉吧！</p>
<hr>
<p>Update 2019.4.18: 删了几张照片。这几个月把除了d2t2都写了，回首看当时好弱。前几天省选发挥骗分精神怒骗一百多分，也算比noip有所进步吧。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>JSOI2008最小生成树计数 并查集最小生成树</title>
    <url>/2019/09/23/jsoi2008%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E8%AE%A1%E6%95%B0-%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P4208">[JSOI2008]最小生成树计数</a> 作为一枚蒟蒻，我完全没学过最小生成树的说！！ 最小生成树有几个好的性质，这里给出简单证明。详细证明参考这里<a href="https://blog.sengxian.com/solutions/bzoj-1016">Sengxian’s Blog</a> 性质1：一张图的所有最小生成树，把边排序后，对应下标的边边权相等。 证明：找到第一个选择的边不等的位置，记为$a_i,b_i$。如果$a_i$在$b$中出现，出现在$b_j$，那么有$j &gt; i$，$[b_i,b_j]$都相等。如果没有出现，把$a_i$加进$b$中，形成一个环。这个环上所有边权一定$\leq a_i$。为了顶替$a_i$，一定有一个$b_j = a_i, j &gt; i$。 性质2：最小生成树，从小到大加边，加完某种边权后，连通性相同 证明：如果不同，考虑Kruskal算法的过程，一定会把差异的边加上。 性质3：如果某种边权在一种最小生成树中出现$k$次，在此边权中任意选$k$条边加上，只要没有形成环，都是可行方案。 证明：如果没有形成环，一定形成了树，且边权，连通性相同。 有了这三个定理，又因为每种边权不超过$10$条，可以枚举使用了哪些边来求解答案。使用可撤销并查集，复杂度$O(2^{10} m logn)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">233</span>, P = <span class="number">31011</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans, fa[N], vis[N], st[N], pick[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, c;</span><br><span class="line">&#125; e[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Edge &amp;a, <span class="keyword">const</span> Edge &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.c &lt; b.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> d, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d == st[s + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == pick[s])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">find</span>(e[d].x), y = <span class="built_in">find</span>(e[d].y), ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">        fa[x] = y;</span><br><span class="line">        ret += <span class="built_in">dfs</span>(s, d + <span class="number">1</span>, p + <span class="number">1</span>);</span><br><span class="line">        fa[x] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret + <span class="built_in">dfs</span>(s, d + <span class="number">1</span>, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        e[i].x = <span class="built_in">rd</span>(), e[i].y = <span class="built_in">rd</span>(), e[i].c = <span class="built_in">rd</span>();</span><br><span class="line">    std::<span class="built_in">sort</span>(e + <span class="number">1</span>, e + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">find</span>(e[i].x), y = <span class="built_in">find</span>(e[i].y);</span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            fa[x] = y;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans != n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">if</span> (e[i].c != e[i - <span class="number">1</span>].c)</span><br><span class="line">            st[++tot] = i;</span><br><span class="line">    st[tot + <span class="number">1</span>] = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = st[i]; j &lt; st[i + <span class="number">1</span>]; ++j)</span><br><span class="line">            <span class="keyword">if</span> (vis[j])</span><br><span class="line">                ++pick[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= tot; ++s) &#123;</span><br><span class="line">        ans = ans * <span class="built_in">dfs</span>(s, st[s], <span class="number">0</span>) % P;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = st[s]; i &lt; st[s + <span class="number">1</span>]; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">find</span>(e[i].x), y = <span class="built_in">find</span>(e[i].y);</span><br><span class="line">            <span class="keyword">if</span> (x != y)</span><br><span class="line">                fa[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>NSUBSTR - Substrings</title>
    <url>/2019/06/17/nsubstr-substrings/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/SP8222">NSUBSTR - Substrings</a> 这题显然可以用SA做。。。SAM也可以。。。 建出来SAM，每个节点能表示的串个数为right集合的大小，能表示的长度为[min, max]。用right更新f[max]，最后用f[i+1]更新f[i]。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">250000</span> * <span class="number">2</span> + <span class="number">2333</span>;</span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> last = <span class="number">1</span>, root = <span class="number">1</span>, tot = <span class="number">1</span>, fa[N], ch[N][<span class="number">26</span>], len[N], sz[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = last, np = ++tot;</span><br><span class="line">    last = np; len[np] = len[p] + <span class="number">1</span>; sz[np] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; !ch[p][c])</span><br><span class="line">        ch[p][c] = np, p = fa[p];</span><br><span class="line">    <span class="keyword">if</span> (!p) fa[np] = root;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> q = ch[p][c];</span><br><span class="line">        <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)</span><br><span class="line">            fa[np] = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> nq = ++tot;</span><br><span class="line">            len[nq] = len[p] + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="built_in"><span class="keyword">sizeof</span></span>(ch[q]));</span><br><span class="line">            fa[nq] = fa[q];</span><br><span class="line">            fa[q] = fa[np] = nq;</span><br><span class="line">            <span class="keyword">while</span> (p &amp;&amp; ch[p][c] == q)</span><br><span class="line">                ch[p][c] = nq, p = fa[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], c[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>); n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">insert</span>(s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) ++c[len[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tot; i &gt;= <span class="number">1</span>; --i) a[c[len[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tot; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        sz[fa[a[i]]] += sz[a[i]];</span><br><span class="line">        f[len[a[i]]] = <span class="built_in">max</span>(f[len[a[i]]], sz[a[i]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) f[i] = <span class="built_in">max</span>(f[i], f[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>PHRASES - Relevant Phrases of Annihilation</title>
    <url>/2019/06/14/phrases-relevant-phrases-of-annihilation/</url>
    <content><![CDATA[<p>求每个字符串至少出现两次且不重叠的最长子串。 <a href="https://www.luogu.org/problemnew/show/SP220">PHRASES - Relevant Phrases of Annihilation</a> 二分答案长度，判断。如果每个串里都出现了两次，sa_max-sa_min&gt;=k，那么合法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">15000</span> + <span class="number">10</span>, M = N * <span class="number">10</span> + <span class="number">2333</span>, S = <span class="number">894</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, mx, s[M], bl[M], x[M], y[M], c[M], sa[M], ht[M], rk[M];</span><br><span class="line"><span class="keyword">char</span> ch[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(s));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m); n = <span class="number">0</span>; mx = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ch + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(ch + <span class="number">1</span>);</span><br><span class="line">        mx = std::<span class="built_in">min</span>(mx, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len; ++j)</span><br><span class="line">            s[++n] = ch[j], bl[n] = i;</span><br><span class="line">        s[++n] = i + <span class="number">233</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i] = s[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>, k = <span class="number">1</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>, p = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; ++i) y[++p] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt; k) y[++p] = sa[i] - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[y[i]]]--] = y[i];</span><br><span class="line">        std::<span class="built_in">swap</span>(x, y); x[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            x[sa[i]] = y[sa[i]] == y[sa[i - <span class="number">1</span>]]</span><br><span class="line">                &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]</span><br><span class="line">                ? p : ++p;</span><br><span class="line">        <span class="keyword">if</span> (p == n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, p = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (p) --p;</span><br><span class="line">        <span class="keyword">while</span> (s[i + p] == s[j + p]) ++p;</span><br><span class="line">        ht[rk[i]] = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> max_sa[<span class="number">15</span>], min_sa[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) cnt[i] = <span class="number">0</span>, max_sa[i] = <span class="number">-1</span>, min_sa[i] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ht[i] &lt; k) &#123;</span><br><span class="line">            <span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &lt; <span class="number">2</span>  max_sa[j] - min_sa[j] &lt; k) &#123;</span><br><span class="line">                    ok = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (ok) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                cnt[j] = <span class="number">0</span>, max_sa[j] = <span class="number">-1</span>, min_sa[j] = n + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = bl[sa[i]];</span><br><span class="line">        ++cnt[x];</span><br><span class="line">        max_sa[x] = std::<span class="built_in">max</span>(max_sa[x], sa[i]);</span><br><span class="line">        min_sa[x] = std::<span class="built_in">min</span>(min_sa[x], sa[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = mx, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">judge</span>(mid)) l = mid + <span class="number">1</span>, ans = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">SA</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>PKUWC/SC 乱做</title>
    <url>/2019/12/17/pkuwc-sc-%E4%B9%B1%E5%81%9A/</url>
    <content><![CDATA[<h2 id="Minimax"><a href="#Minimax" class="headerlink" title="Minimax"></a>Minimax</h2><p>之前写过题解，在<a href="https://baka.online/pkuwc2018-minimax/">这里</a> 很好想，不过代码有点难写…</p>
<h2 id="Slay-the-Spire"><a href="#Slay-the-Spire" class="headerlink" title="Slay the Spire"></a>Slay the Spire</h2><p>看错输入啦OAO。以为强化牌可以有小数w。 强化牌$ &gt; 1$，并且都是整数的情况下，出强化一定比出攻击优秀。 分类讨论，有两种情况： 选的强化牌$\geq k - 1$，那么出$k-1$次，然后攻击一次。这种情况下剩下的牌两种都可以选。 选的强化牌$ &lt; k - 1 $，全出然后攻击。这种情况下多出来的牌只能选攻击牌。 那么定义$f_{i,j},g_{i,j}$分别表示前$i$张牌，选了$j$张强化，各方案价值积的和，与前$i$张选了$j$张攻击价值和的和。然后分类随便统计即可。</p>
<h2 id="斗地主"><a href="#斗地主" class="headerlink" title="斗地主"></a>斗地主</h2><p>大模拟，咕咕咕</p>
<h2 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h2><p>考虑一个$O(3^nn)$的大暴力。令$f_{s1,s2}$表示$s1$集合，构成的独立集是$s2$的方案。枚举加点转移。 发现最优答案一定是由一个子最优状态扩展来的。那么可以压掉具体独立集的状态。 具体来说我们令$f_s,g_s$表示$s$集合构成最大独立集方案，最大独立集大小。 考虑加入一个点$x$，令$w_x$表示$x$与所有和$x$相连点的集合。 首先更新$g$，如果变大把$f$清零。 $$f_{s \cup w_x} \leftarrow f_s P_{n - s - 1}^{w_x - (w_x \cap s) - 1}$$</p>
<h2 id="猎人杀"><a href="#猎人杀" class="headerlink" title="猎人杀"></a>猎人杀</h2><p>首先做一个非常脑洞的转化：一个猎人死了，不把它删掉，留在集合中。更改打枪方案为：如果打到的是死人，就继续再打一枪。 记录人数和为$A$，挂掉的人数为$K$。令打中某个人，原来的概率，新的概率为$P_1,P_2$ $$P_1 = \frac{ w_i }{A - K }$$ $$P_2 = \frac{K}{ A } P_2 + \frac{w_i}{A}$$ 可以发现$P_1 = P_2$ 那么一个容斥，枚举在$1$之后被打死的集合$s$。记$s$的$w$和为$S$ $$ans = \sum_{s} (-1)^{ s } \sum_{i=0}^{\infty} (1- \frac{S + w_1}{A}) \frac{w_i}{A} $$ 拿出后面的部分，发现是收敛的，直接提出来： $$ \sum_{i=0}^{\infty} (1- \frac{S + w_1}{A}) \frac{w_i}{A} = \frac{w_1}{S + w_1}$$ $$ans = \sum_{s} (-1)^{ s }\frac{w_1}{S + w_1} = w_1 \sum_{s} \frac{ (-1)^{ s } }{S + w_1} $$ 考虑记录对于$S$，$\sum (-1)^{s}$是多少。 构造生成函数$F(x)$ $$F(x) = \prod_{i=2}^{A - w_1} (1 - x^{w_i}) $$ 那么$[x^i]F(x)$就是要的东西。 这个式子可以用分治FFT求出来。</p>
<h2 id="随机游走"><a href="#随机游走" class="headerlink" title="随机游走"></a>随机游走</h2><p>考虑$\rm{min-max}$容斥，求出到每个集合的$\min$即可。枚举集合$s$，定义$f_x$为$x$点走进$s$的期望步数。 如果$x \in s$，$f_x = 0$ 否则有： $$f_x = \frac{1}{deg_x} (f_{fa} + \sum_{y \in son} f_y) + 1$$ 有一个树上高斯消元的套路：每个$f$都可以被表示为$f_x = A_x f_{fa} + B_x$ 推一下式子： $$deg_x f_x = f_{fa} + \sum_{y} A_y f_x + B_y $$ $$f_x = \frac{1}{deg_x - \sum_y a_y} f_{fa} + \frac{\sum_y b_y + deg_x}{deg_x - \sum_y a_y} $$ 那么可以快速求出$f_{root}$。</p>
<hr>
<h2 id="真实排名"><a href="#真实排名" class="headerlink" title="真实排名"></a>真实排名</h2><p>签到题，考虑哪些选手翻倍不会影响自己。 如果自己不翻倍，翻倍后还是比自己小的，和本来就大于等于自己的可以动。 如果自己翻倍，那么翻倍前到翻倍后的一段都要翻。 组合数算一算就好了。</p>
<h2 id="最大前缀和"><a href="#最大前缀和" class="headerlink" title="最大前缀和"></a>最大前缀和</h2><p>观察数据范围发现显然是$O(2^nn)$的算法。考虑状压DP，钦定一些点是本次答案点。 用$f_s,g_s$分别表示$s$集合排列，使得最后一个位置前缀和最大的方案数，与$s$集合排列，任意时刻前缀和$ \leq 0$的方案数。 $$f_s = \sum_{s - i} f_{s - i} (sum_{s - i} &gt; 0)$$ $$g_s = \sum_{s - i} g_{s - i} (sum_s \leq 0) $$ 第二个意义很明确。第一个转移的意思是，把$i$元素插到$s-i$排列的最前面。 注意到本题中最小前缀和必须选择至少一个数字，所以这样转移合法。 最后用两个数组计算答案即可。</p>
<h2 id="主斗地"><a href="#主斗地" class="headerlink" title="主斗地"></a>主斗地</h2><p>并没有什么思维难度的恶心搜索题。。。还没写。。。</p>
<h2 id="星际穿越"><a href="#星际穿越" class="headerlink" title="星际穿越"></a>星际穿越</h2><p>观察可以发现，最优秀的方案要么是直接向左跳，要么是向右跳一次再一直向左。钦定一个起点，向左走的距离一定是一段一段的。 于是利用性质可以考虑一个$O(n^2)$的简单暴力，计算出任意点对的距离就行了。 优化这个暴力，把记录两点间距离，改成记录一个点跳$i$次最左可以跳到哪里。倍增优化。 具体来说，定义数组$f_{x,i}$表示从$\forall x \in [x, n]$点开始跳$2^i$次可以跳到哪里。 求出$f$后，记录$g_{x,i}$表示跳整个$[f_{x,i},x-1]$的点一共需要多少次。 最后统计答案。首先向左跳一次，然后用$f$数组计算答案。容易发现这样是没有问题的。</p>
<h2 id="神仙的游戏"><a href="#神仙的游戏" class="headerlink" title="神仙的游戏"></a>神仙的游戏</h2><p>考虑一个做法。问号是匹配符，无视之。我们定义$A(x),B(x)$，使得$A(x)=\sum [S_i == 0] x^i,B(x) = \sum [S_i == 1] x^i$，然后做一个减法卷积。 然而这样是有问题的。对于长度大于一半的$border$，会有重复部分，然而这样匹配出的方案可能一个问号分别充当了$0,1$各一次。 考虑$border$和$period$的关系。如果存在一个$border$长度为$x$，那么剩下的部分在$\mod S - x $意义下相等。这个显然是不相交的。 NTT求一下减法卷积，然后枚举每一段检查。复杂度是一个调和级数。</p>
<h2 id="PKUSC"><a href="#PKUSC" class="headerlink" title="PKUSC"></a>PKUSC</h2><p>把每个点的概率加起来就行了。考虑把一个点放在一个圆上，它与多边形交的弧长就是答案。 那么直接解方程解出所有的交点，极角排序，判断每一段弧在多边形内还是外。 判断一个点在多边形内外，可以考虑向任意方向作射线，如果没有和点相交，可根据与边交点数量奇偶性判断内外。 本题中坐标都是整数，所以选要判断的弧上一个非整数点作射线即可避免交到点上的事情。</p>
<hr>
<p>下面的题并没有地方交OAO <a href="https://www.cnblogs.com/xzz_233/p/10292983.html">题面</a></p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>令$f_s$表示集合$s$的方案数，枚举拓扑序最后的点再枚举出边转移。</p>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><p>钦定一个点或边做代表元素，考虑过这个元素的方案。把点和边分开计算，减一下，发现每种方案只被算了一次。 令$f_i$为有$i$种颜色经过的点的数量，则有 $$ans_x = \sum_{i=x}^n f_i \binom{i}{k}$$ 然后卷卷就行了。</p>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p>不会斗地主。</p>
<h2 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h2><p>网上找到的题和题解貌似不符，233，咕了</p>
<h2 id="T5"><a href="#T5" class="headerlink" title="T5"></a>T5</h2><p>如果两个环有公共边，它们在一个强联通内。先求强联通，考虑每个分量，把有向边变无向，可以感性理解到，如果有公共边一定在一个点双内。</p>
<h2 id="T6"><a href="#T6" class="headerlink" title="T6"></a>T6</h2><p>咕。</p>
<hr>
<p><a href="https://blog.csdn.net/xgc_woker/article/details/90632710">题在这里</a></p>
<h2 id="T1-1"><a href="#T1-1" class="headerlink" title="T1"></a>T1</h2><p>猜结论可以猜到就是逆序对数量</p>
<h2 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a>T2</h2><p>大概就是做一个DP，记录$f_{i,j,s}$，$s$表示其他桌子的状态。$s$记录大小关系。然后不会了233</p>
<h2 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a>T3</h2><p>可以交换Trie的左右儿子，于是做一个小DP，bitset优化。</p>
<h2 id="T4-1"><a href="#T4-1" class="headerlink" title="T4"></a>T4</h2><p>做一个暴力大DP：$f_{i,j}$表示$i$点颜色$j$，转移显然。发现很多$j$的答案都是一样的，记录被钦定ban掉的颜色集合即可。然后做一个线段树合并。</p>
<h2 id="T5-1"><a href="#T5-1" class="headerlink" title="T5"></a>T5</h2><p>咕咕</p>
<h2 id="T6-1"><a href="#T6-1" class="headerlink" title="T6"></a>T6</h2><p>咕咕</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>PKUWC2020 游记</title>
    <url>/2019/12/19/pkuwc2020-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h2><p>什么都不会，还病了，凉了 嗓子疼的厉害，面试要凉 然而热动分析了一下我肯定进不了面试 蛤蛤蛤</p>
<h2 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h2><p>咕</p>
<h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>生病考场难受摸鱼睡觉 正解头疼想不到 暴力不会打凉了</p>
<h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>凉了 yy到的神奇idea能出一个新题，然而就是不能切这些题，凉了</p>
<h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><p>凉了 本来就菜，状态也不在线，考场yy到的做法还都翻车，滚了 PKUSC2020见</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>PKUWC2018 Minimax</title>
    <url>/2019/07/30/pkuwc2018-minimax/</url>
    <content><![CDATA[<p><a href="https://loj.ac/problem/2537">[PKUWC2018]Minimax</a> 发现叶子权值全不一样，直觉告诉我们是线段树合并。 发现是二叉树，直觉告诉我们分类讨论。 于是，可以写出DP方程。 令$f_{x,k}$表示$x$点，取值为$k$的概率。 如果从左儿子转移来： $$f_{x,k}=f_{ls,k}(p_x \sum_{i=1}^{k-1}f_{rs,i}+(1-p_x)\sum_{i=k+1}^mf_{rs,i})$$ 如果从右儿子转移来： $$f_{x,k}=f_{rs,k}(p_x \sum_{i=1}^{k-1}f_{ls,i}+(1-p_x)\sum_{i=k+1}^mf_{ls,i})$$ 这个柿子可以线段树合并优化。 递归合并的时候，维护两个前缀和，两个后缀和，就是柿子里那些东西。 线段树合并保证复杂度，重要的一点是如果一边空了就返回。 具体到这道题，如果一棵树某子树空了，那么另一棵树转移乘的东西就不变了。线段树打个lazytag。 然后代码完全不会写了…各种坑…参考了各种博客，调了很久之后：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">233</span>, P = <span class="number">998244353</span>, INV = <span class="number">796898467</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans, son[N][<span class="number">2</span>], raw_val[N], val[N], tmp[N], nn,</span><br><span class="line">    ls[N * <span class="number">50</span>], rs[N * <span class="number">50</span>], tag[N * <span class="number">50</span>], f[N * <span class="number">50</span>], root[N], num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    f[p] = (f[ls[p]] + f[rs[p]]) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag[p] != <span class="number">1</span>) &#123;</span><br><span class="line">        tag[ls[p]] = (LL)tag[ls[p]] * tag[p] % P;</span><br><span class="line">        tag[rs[p]] = (LL)tag[rs[p]] * tag[p] % P;</span><br><span class="line">        f[ls[p]] = (LL)f[ls[p]] * tag[p] % P;</span><br><span class="line">        f[rs[p]] = (LL)f[rs[p]] * tag[p] % P;</span><br><span class="line">        tag[p] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">single_init</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> x, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) p = ++num, tag[p] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123; f[p] = <span class="number">1</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">single_init</span>(ls[p], x, L, mid);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">single_init</span>(rs[p], x, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> la, <span class="keyword">int</span> ra, <span class="keyword">int</span> lb, <span class="keyword">int</span> rb, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x &amp;&amp; !y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (y) <span class="built_in">pushdown</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (x &amp;&amp; !y) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = ((LL)p * lb % P + (LL)(<span class="number">1</span> - p + P) % P * rb % P) % P;</span><br><span class="line">        f[x] = (LL)f[x] * tmp % P;</span><br><span class="line">        tag[x] = (LL)tag[x] * tmp % P;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!x &amp;&amp; y) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = ((LL)p * la % P + (LL)(<span class="number">1</span> - p + P) % P * ra % P) % P;</span><br><span class="line">        f[y] = (LL)f[y] * tmp % P;</span><br><span class="line">        tag[y] = (LL)tag[y] * tmp % P;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now = ++num;</span><br><span class="line">    tag[now] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> a = f[ls[x]], b = f[ls[y]];</span><br><span class="line">    ls[now] = <span class="built_in">merge</span>(ls[x], ls[y], la, (ra + f[rs[x]]) % P, lb, (rb + f[rs[y]]) % P, p);</span><br><span class="line">    rs[now] = <span class="built_in">merge</span>(rs[x], rs[y], (la + a) % P, ra, (lb + b) % P, rb, p);</span><br><span class="line">    <span class="built_in">pushup</span>(now);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!son[x][<span class="number">0</span>] &amp;&amp; !son[x][<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">single_init</span>(root[x], val[x], <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (son[x][<span class="number">0</span>] &amp;&amp; !son[x][<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">dfs_solve</span>(son[x][<span class="number">0</span>]);</span><br><span class="line">        root[x] = root[son[x][<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (son[x][<span class="number">0</span>] &amp;&amp; son[x][<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">dfs_solve</span>(son[x][<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">dfs_solve</span>(son[x][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> p = (LL)val[x] * INV % P;</span><br><span class="line">        root[x] = <span class="built_in">merge</span>(root[son[x][<span class="number">0</span>]], root[son[x][<span class="number">1</span>]], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc_ans</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        ans = (ans + (LL)L * tmp[L] % P * f[x] % P * f[x] % P) % P;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">calc_ans</span>(ls[x], L, mid);</span><br><span class="line">    <span class="built_in">calc_ans</span>(rs[x], mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(); <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">if</span> (son[x][<span class="number">0</span>]) son[x][<span class="number">1</span>] = i;</span><br><span class="line">        <span class="keyword">else</span> son[x][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        val[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!son[i][<span class="number">0</span>] &amp;&amp; !son[i][<span class="number">1</span>])</span><br><span class="line">            tmp[++nn] = val[i];</span><br><span class="line">    std::<span class="built_in">sort</span>(tmp + <span class="number">1</span>, tmp + nn + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!son[i][<span class="number">0</span>] &amp;&amp; !son[i][<span class="number">1</span>])</span><br><span class="line">            val[i] = std::<span class="built_in">lower_bound</span>(tmp + <span class="number">1</span>, tmp + nn + <span class="number">1</span>, val[i]) - tmp;</span><br><span class="line">    <span class="built_in">dfs_solve</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">calc_ans</span>(root[<span class="number">1</span>], <span class="number">1</span>, n);</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>POI2000病毒</title>
    <url>/2019/04/10/poi2000%E7%97%85%E6%AF%92/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2444">[POI2000]病毒</a> 如果给定一个串，检查里面有没有病毒串，我们可以用AC自动机。如果有无限长的无病毒串，想象一下字符串在AC自动机上跑的过程，它会在AC自动机上的一个没有病毒串的环上转圈。 所以我们需要构建出来AC自动机，然后在上面找一个没有结束标记的环。首先病毒串的结尾都有标记，然后如果一个点fail指向的位置有标记，则这个点也要有标记。这是由于AC自动机fail指针的性质。dfs找环就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30000</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> n, ch[N][<span class="number">2</span>], end[N], fail[N], num, vis[N], ins[N];;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ch[now][s[i] - <span class="string">&#x27;0&#x27;</span>])</span><br><span class="line">            ch[now][s[i] - <span class="string">&#x27;0&#x27;</span>] = ++num;</span><br><span class="line">        now = ch[now][s[i] - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    end[now] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>][i]) que.<span class="built_in">push</span>(ch[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch[x][i]) &#123;</span><br><span class="line">                fail[ch[x][i]] = ch[fail[x]][i];</span><br><span class="line">                end[ch[x][i]] = end[ch[fail[x]][i]];</span><br><span class="line">                que.<span class="built_in">push</span>(ch[x][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ch[x][i] = ch[fail[x]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ins[x]) <span class="built_in">puts</span>(<span class="string">&quot;TAK&quot;</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (vis[x]  end[x]) <span class="keyword">return</span>;</span><br><span class="line">    ins[x] = vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(ch[x][<span class="number">0</span>]), <span class="built_in">dfs</span>(ch[x][<span class="number">1</span>]);</span><br><span class="line">    ins[x] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--) cin &gt;&gt; str, <span class="built_in">insert</span>(str);</span><br><span class="line">    <span class="built_in">build</span>(), <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;NIE&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>POI2008BLO-Blockade</title>
    <url>/2019/01/14/poi2008blo-blockade/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3469">[POI2008]BLO-Blockade</a> 某谷智能推荐给我的题，在无向图上求出去掉每个点和连着的边之后有多少对点无法互相到达。 比较裸的割点题。删掉不是割点的点只会使所有点和它的连接被切断，减少$(N - 1) \times 2$对。而删掉割点之后除了切断这个点和原图的连接，还会让图变得不联通，减少几个联通块之间的对数共$\sum y \times (N - y - 1)$对，其中$y$为联通块大小。 所以答案就很明确了，Tarjan求割点，一边扫一边统计即可。复杂度O(N)。 （机房NOI Linux输入法打字真捉急</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">2333</span>, MAXM = MAXN * <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">G</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125; g[MAXM * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAXN], tot, N, M, dfn[MAXN], low[MAXN], num, root;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[MAXN], sz[MAXN];;</span><br><span class="line"><span class="keyword">bool</span> cut[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    g[++tot].to = y, g[tot].nxt = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++num;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> all = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y = g[i].to; i; i = g[i].nxt, y = g[i].to) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            sz[x] += sz[y];</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">            <span class="keyword">if</span> (dfn[x] &lt;= low[y]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (++flag &gt; <span class="number">1</span>  x != root)</span><br><span class="line">                    cut[x] = <span class="literal">true</span>;</span><br><span class="line">                ans[x] += sz[y] * (N - sz[y] - <span class="number">1</span>);</span><br><span class="line">                all += sz[y];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cut[x]) ans[x] = (N - <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> ans[x] += (N - <span class="number">1</span>) * <span class="number">2</span> + (N - all - <span class="number">1</span>) * all;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = <span class="built_in">rd</span>(), M = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">addedge</span>(x, y), <span class="built_in">addedge</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) &#123;</span><br><span class="line">            root = i;</span><br><span class="line">            <span class="built_in">tarjan</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>POI2015LOG</title>
    <url>/2019/05/29/poi2015log/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3586">[POI2015]LOG</a> 实际上这题的询问操作和数字顺序没关系。要操作$s$次，如果存在$\ge s$的数，可以每次都用。我们需要维护$\ge s$的数的数目$k$和$ &lt; s$的数字和$sum$。易知$sum$中最少也有$\frac{sum}{s-1}$个数字。用掉$k$个数，如果$(c-k)*s\le sum$，就可以，因为剩下的数字从数目和大小上都满足了要求。 可以用splay或者动态开点的线段树维护这玩意。splay从来没不debug一次写对过，果断线段树。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000000</span> + <span class="number">2333</span>, M = N * <span class="number">10</span>, LIM = <span class="number">1e9</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, num;</span><br><span class="line">    LL sum;</span><br><span class="line">&#125; t[M];</span><br><span class="line"><span class="keyword">int</span> num, root, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    t[p].sum = t[t[p].l].sum + t[t[p].r].sum;</span><br><span class="line">    t[p].num = t[t[p].l].num + t[t[p].r].num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) p = ++num;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        t[p].num += y;</span><br><span class="line">        t[p].sum += x * y;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">        <span class="built_in">change</span>(t[p].l, x, y, L, mid);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">change</span>(t[p].r, x, y, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_num</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R)</span><br><span class="line">        <span class="keyword">return</span> t[p].num;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">        ret += <span class="built_in">query_num</span>(t[p].l, l, r, L, mid);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">        ret += <span class="built_in">query_num</span>(t[p].r, l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query_sum</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R)</span><br><span class="line">        <span class="keyword">return</span> t[p].sum;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">        ret += <span class="built_in">query_sum</span>(t[p].l, l, r, L, mid);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">        ret += <span class="built_in">query_sum</span>(t[p].r, l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>(); <span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">change</span>(root, <span class="number">0</span>, n, <span class="number">0</span>, LIM);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;U&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">change</span>(root, a[x], <span class="number">-1</span>, <span class="number">0</span>, LIM);</span><br><span class="line">            a[x] = y;</span><br><span class="line">            <span class="built_in">change</span>(root, a[x], <span class="number">1</span>, <span class="number">0</span>, LIM);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="built_in">query_num</span>(root, y, LIM, <span class="number">0</span>, LIM);</span><br><span class="line">            LL sum = <span class="built_in">query_sum</span>(root, <span class="number">0</span>, y - <span class="number">1</span>, <span class="number">0</span>, LIM);</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)(x - k) * y &lt;= sum)</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;TAK&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NIE&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> kai586123::<span class="built_in">main</span>(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>poj1639 Picnic Planning 限制某个点度数的MST</title>
    <url>/2019/03/07/poj1639-picnic-planning-%E9%99%90%E5%88%B6%E6%9F%90%E4%B8%AA%E7%82%B9%E5%BA%A6%E6%95%B0%E7%9A%84mst/</url>
    <content><![CDATA[<p><a href="http://poj.org/problem?id=1639">Picnic Planning</a> 题意：给定一张图，某个点有度数限制，求MST（保证有解）。 做法：记限制的点为$s$。既然要限制这个点，那么就求出没有这个点的MST森林。然后$s$向每个MST连一条最短的边。 向任意MST加一条边，那么就构成了一个环。然后我们可以删掉这个环上最长的一条边。最长边的求解可以用dp实现。$f(i)=max(f(i),f(fa(i))$，其中$fa(i)$为dfs中的父节点。这个过程和求解次小生成树还是很像的。 枚举加边删边，使用最优方案，直到加到限制或者加所有边都只会让答案变大为止。得到的树即为答案。 AC Code</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>, M = N * N, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> <span class="keyword">int</span> x, y, c; &#125; kru[M], dp[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> Node &amp;x, <span class="keyword">const</span> Node &amp;y)</span> </span>&#123; <span class="keyword">return</span> x.c &lt; y.c; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, g[N][N];</span><br><span class="line"><span class="keyword">bool</span> used[N][N];</span><br><span class="line">map&lt;string, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ufs[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == ufs[x] ? x : ufs[x] = <span class="built_in">find</span>(ufs[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(g));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        string x, y; <span class="keyword">int</span> c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span> (mp.<span class="built_in">find</span>(x) == mp.<span class="built_in">end</span>()) mp[x] = ++n;</span><br><span class="line">        <span class="keyword">if</span> (mp.<span class="built_in">find</span>(y) == mp.<span class="built_in">end</span>()) mp[y] = ++n;</span><br><span class="line">        <span class="keyword">int</span> id_x = mp[x], id_y = mp[y];</span><br><span class="line">        kru[i].x = id_x, kru[i].y = id_y, kru[i].c = c;</span><br><span class="line">        g[id_x][id_y] = g[id_y][id_x] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ufs[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(kru + <span class="number">1</span>, kru + m + <span class="number">1</span>, comp);</span><br><span class="line">    <span class="keyword">int</span> st = mp[<span class="string">&quot;Park&quot;</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = kru[i].x, y = kru[i].y, xx = <span class="built_in">find</span>(x), yy = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x != st &amp;&amp; y != st &amp;&amp; xx != yy) &#123;</span><br><span class="line">            ufs[xx] = yy;</span><br><span class="line">            used[x][y] = used[y][x] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i != x &amp;&amp; i != fa &amp;&amp; used[x][i]) &#123;</span><br><span class="line">            dp[i] = dp[x];</span><br><span class="line">            <span class="keyword">if</span> (g[x][i] &gt; dp[i].c) &#123;</span><br><span class="line">                dp[i].c = g[x][i];</span><br><span class="line">                dp[i].x = x, dp[i].y = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dfs</span>(i, x);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i != x &amp;&amp; i != fa &amp;&amp; used[x][i])</span><br><span class="line">            ans += g[x][i] + <span class="built_in">calc</span>(i, x);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> key[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> st = mp[<span class="string">&quot;Park&quot;</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i != st &amp;&amp; g[st][key[<span class="built_in">find</span>(i)]] &gt; g[st][i])</span><br><span class="line">            key[<span class="built_in">find</span>(i)] = i;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (key[i])</span><br><span class="line">        used[st][key[i]] = used[key[i]][st] = ++cnt;;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">calc</span>(st, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt + <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        dp[st].c = dp[st].x = dp[st].y = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(st, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> minn = INF, pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (j != st &amp;&amp; !used[st][j] &amp;&amp; g[st][j] - dp[j].c &lt; minn) &#123;</span><br><span class="line">                minn = g[st][j] - dp[j].c;</span><br><span class="line">                pos = j;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (minn &gt; <span class="number">0</span>  pos == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        used[dp[pos].x][dp[pos].y] = used[dp[pos].y][dp[pos].x] = <span class="literal">false</span>;</span><br><span class="line">        used[st][pos] = used[pos][st] = <span class="literal">true</span>;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, <span class="built_in">calc</span>(st, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total miles driven: &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">kruskal</span>();</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>poj1135 Domino Effect</title>
    <url>/2019/02/28/poj1135-domino-effect/</url>
    <content><![CDATA[<p><a href="http://poj.org/problem?id=1135">[poj1135] Domino Effect</a> 题意人话ver：无向图，点1开始同时走，求最晚到达的地方和时间（可能在点上可能在边上）。 水题，先跑个最短路，然后枚举每条边，如果可能在边上相遇，则用相遇时间更新答案。 数据有坑，注意m=0的答案问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">550</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, nxt, c;</span><br><span class="line">&#125; g[M * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    g[++tot].from = x, g[tot].to = y,</span><br><span class="line">    g[tot].nxt = head[x], g[tot].c = c;</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> que[M * <span class="number">10</span>], l, r, dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> kase;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n &amp;&amp; !m) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(g));</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>(), c = <span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">addedge</span>(x, y, c), <span class="built_in">addedge</span>(y, x, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">        dis[que[l = <span class="number">0</span>, r = <span class="number">1</span>] = <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l != r) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = que[++l];</span><br><span class="line">            vis[x] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">                <span class="keyword">if</span> (dis[y] &gt; dis[x] + g[i].c) &#123;</span><br><span class="line">                    dis[y] = dis[x] + g[i].c;</span><br><span class="line">                    <span class="keyword">if</span> (!vis[y]) &#123;</span><br><span class="line">                        vis[y] = <span class="literal">true</span>;</span><br><span class="line">                        que[++r] = y;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> max_dis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max_dis &lt;= dis[i]) &#123;</span><br><span class="line">                max_dis = dis[i];</span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> max_edge = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos1, pos2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = g[i].from, y = g[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dis[y] &lt; dis[x] + g[i].c) &#123;</span><br><span class="line">                <span class="keyword">double</span> c = dis[y] + (<span class="keyword">double</span>)(g[i].c - (dis[y] - dis[x])) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (max_edge &lt;= c) &#123;</span><br><span class="line">                    max_edge = c;</span><br><span class="line">                    pos1 = x, pos2 = y;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;System #%d\n&quot;</span>, ++kase);</span><br><span class="line">        <span class="keyword">if</span> (max_dis &gt;= max_edge)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The last domino falls after %.1f seconds, at key domino %d.\n&quot;</span>, max_dis, pos);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;The last domino falls after %.1f seconds, between key dominoes %d and %d.\n&quot;</span>,</span><br><span class="line">            max_edge, <span class="built_in">min</span>(pos1, pos2), <span class="built_in">max</span>(pos1, pos2));</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>POJ3889 Fractal Streets</title>
    <url>/2019/01/05/poj3889-fractal-streets/</url>
    <content><![CDATA[<p><a href="http://poj.org/problem?id=3889">Fractal Streets</a> 一道标准的搜索题，然而和poj（g++？）的蜜汁bug（printf）斗争了一小时……. 顺便吐槽下，本题描述图片n=2，房子7和8画反了….. 观察可以知道，从n-1变成n时：</p>
<ul>
<li>左上顺时针旋转90°再水平翻转</li>
<li>右上形状不变</li>
<li>右下形状不变</li>
<li>左下逆时针旋转90°，再水平翻转</li>
</ul>
<p>房子编号按照上面列举的顺序，于是可以分为四块处理 先递归求出n-1时房子的位置，然后判断在哪一块，旋转即可 为了方便（偷懒），把题目输入的两个房号都-1 搜索部分代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">long</span> <span class="keyword">long</span> t, <span class="keyword">long</span> <span class="keyword">long</span> &amp;a, <span class="keyword">long</span> <span class="keyword">long</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123; a = b = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="comment">// edge是二分之一边长，size是四分之一面积</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> edge = <span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>), size = <span class="number">1</span> &lt;&lt; (<span class="number">2</span> * n - <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">f</span>(n - <span class="number">1</span>, t % size, a, b);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> block = t / size;</span><br><span class="line">    <span class="keyword">if</span> (block == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp = a, a = b, b = tmp;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (block == <span class="number">1</span>)</span><br><span class="line">        b += edge;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (block == <span class="number">2</span>)</span><br><span class="line">        a += edge, b += edge;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp = a, a = <span class="number">2</span> * edge - b - <span class="number">1</span>, b = edge - tmp - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>踩到的几个坑：</p>
<ul>
<li>本题数据范围万恶，采用long long</li>
<li>输出应该用printf(“%.0f”,ans);保证精度</li>
<li>  不要写printf(“%.0lf”,ans);，因为这个TLE了很久….poj首页有写原因</li>
</ul>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>Power Strings</title>
    <url>/2019/06/12/power-strings/</url>
    <content><![CDATA[<p>求循环同构串的最大循环长度（求最小循环节）。 <a href="https://www.luogu.org/problemnew/show/UVA10298">Power Strings</a></p>
<h4 id="方法1：KMP"><a href="#方法1：KMP" class="headerlink" title="方法1：KMP"></a>方法1：KMP</h4><p>循环节的题用KMP可做。n%(n-next[n])为0，答案是n/(n-next[n])，否则为1。 证明：灵魂画手不请自来（ <img src="https://baka.online/wp-content/uploads/2019/06/TIM%E6%88%AA%E5%9B%BE20190612205148.png"> 如图是两个串串，红色中间夹着的相同，所以这四个绿色的块块也相同（等于红块）。如果可以整除，那么可以以n-next[n]为循环节铺满。因为next[]最大，所以找出的循环节最小，答案最大。 如果不整除，说明铺到最后会有一截变短，串没有循环节。</p>
<h4 id="方法2：SA"><a href="#方法2：SA" class="headerlink" title="方法2：SA"></a>方法2：SA</h4><p>枚举长度约数，判断是否循环即可。判断用LCP，lcp(1,i+1)=n-i。 然鹅因为奇怪的原因一直TLETLETLE，优化了下复杂度删掉了ST表。 具体方法是，因为本题中lcp询问的一端总是1，直接从rank[1]向两边扩展，维护最小值就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000000</span> + <span class="number">2333</span>, S = <span class="number">233</span>;</span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> x[N], y[N], c[N], sa[N], rk[N], ht[N];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(x));</span><br><span class="line">    <span class="built_in">memset</span>(y, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(y));</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line">    <span class="built_in">memset</span>(sa, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(sa));</span><br><span class="line">    <span class="built_in">memset</span>(rk, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(rk));</span><br><span class="line">    <span class="built_in">memset</span>(ht, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ht));</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i] = s[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, p = <span class="number">0</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>, p = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; ++i) y[++p] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt; k) y[++p] = sa[i] - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[y[i]]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[y[i]]]--] = y[i];</span><br><span class="line">        <span class="built_in">swap</span>(x, y); x[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            x[sa[i]] = y[sa[i]] == y[sa[i - <span class="number">1</span>]]</span><br><span class="line">                &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]</span><br><span class="line">                ? p : ++p;</span><br><span class="line">        <span class="keyword">if</span> (p == n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, p = <span class="number">0</span>, j; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (p) --p;</span><br><span class="line">        <span class="keyword">while</span> (s[i + p] == s[j + p]) ++p;</span><br><span class="line">        ht[rk[i]] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">1e9</span>, r = rk[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= <span class="number">2</span>; --i)</span><br><span class="line">        m = <span class="built_in">min</span>(m, ht[i]), ans[sa[i - <span class="number">1</span>]] = m;</span><br><span class="line">    m = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r + <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        m = <span class="built_in">min</span>(m, ht[i]), ans[sa[i]] = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span> &amp;&amp; ans[i + <span class="number">1</span>] == n - i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n / i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SCOI2008奖励关</title>
    <url>/2019/04/27/scoi2008%E5%A5%96%E5%8A%B1%E5%85%B3/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2473">[SCOI2008]奖励关</a> 期望+状压DP。我们用f[i][j]表示i轮，状态为j的答案。期望DP，逆推是套路，因为答案是f[1][0]，有效状态，不需要考虑奇怪的无效状态。 如果某状态下可以取某物品，那么加上一个选/不选的最优值，如果不可以取，加上一个不选的答案。因为求的是期望，然而考虑了所有物品，除以一个n。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k, n, v[<span class="number">200</span>], d[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">double</span> f[<span class="number">105</span>][<span class="number">33000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; tmp;</span><br><span class="line">        <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">            d[i] = <span class="number">1</span> &lt;&lt; (tmp - <span class="number">1</span>);</span><br><span class="line">            cin &gt;&gt; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i; --i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= n; ++t) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((d[t] &amp; j) == d[t])</span><br><span class="line">                    f[i][j] += <span class="built_in">max</span>(f[i + <span class="number">1</span>][j], f[i + <span class="number">1</span>][<span class="built_in">j</span>  (<span class="number">1</span> &lt;&lt; (t - <span class="number">1</span>))] + v[t]);</span><br><span class="line">                <span class="keyword">else</span> f[i][j] += f[i + <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            f[i][j] /= n;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>, f[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SCOI2010生成字符串</title>
    <url>/2019/02/14/scoi2010%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1641">[SCOI2010]生成字符串</a> 考虑建立坐标系，从点(0, 0)走整点到(n, n)，且经过的所有位置都在(0, 0)到(n, n)连线之下。众所周知，方案数即为Catalan数，即C(2n, n) / (n + 1)。 考虑证明此结论。将向右走记为1，向上为0，形成01序列，01各有n个。因此，从(0, 0)到(n, n)的所有方案数为C(2n, n)。 <img src="https://baka.online/wp-content/uploads/2019/02/TIM%E6%88%AA%E5%9B%BE20190214231618.png"> 从全集中减去不合法方案数。将(0, 0)到(n, n)的连线向上平移一格，则所有不合法路径都经过了这条线。将它们沿这条线翻折（即图中红线），这些不合法路径与起点为(-1, 1)，终点为(n, n)的路径一一对应。方案数为C(2n, n - 1)。 所以合法方案数 = C(2n, n) - C(2n, n - 1) = C(2n, n) / (n + 1)。 下面回到本题，本题中终点为(n, m)，所以答案为C(n + m, m) - C(n + m, m - 1)。因为数据过大，可以求出1 ~ (n + m)的阶乘与阶乘逆元来计算答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">20100403</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m, fac[MOD] = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, inv[MOD];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> fac[n] * inv[m] % MOD * inv[n - m] % MOD; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n + m; ++i)</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">    inv[n + m] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> x = fac[n + m], y = MOD - <span class="number">2</span>; y; y &gt;&gt;= <span class="number">1</span>, x = x * x % MOD)</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            inv[n + m] = inv[n + m] * x % MOD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        inv[i] = (i + <span class="number">1</span>) * inv[i + <span class="number">1</span>] % MOD;</span><br><span class="line">    cout &lt;&lt; ((<span class="built_in">C</span>(n + m, m) - <span class="built_in">C</span>(n + m, m - <span class="number">1</span>) + MOD) % MOD) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SCOI2005骑士精神</title>
    <url>/2019/01/05/scoi2005%E9%AA%91%E5%A3%AB%E7%B2%BE%E7%A5%9E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2324">Luogu P2324 [SCOI2005]骑士精神</a> 把输入的棋子还原成题目要求的状态，求最小步数 第一次写IDA*，有点小激动www 如果考虑骑士（和马走法一样）的移动，情况过于复杂。发现只有一个空白位置，可以考虑移动空白位置 题目要求求出步数，而变换情况过多，难以直接搜索 这时候，迭代加深DFS就可以派上用场了，限定步数搜索，枚举$i = 1$到$i = 15$即可</p>
<hr>
<p>并且，显然爆搜是布星的，结合估价函数，使用IDA*算法 从图中看出黑骑士白骑士排列顺序，把黑骑士标记为1，白骑士标记为0（对应题目输入），空格标记为2,则可以得到目标状态 每次移动只可以移动一个骑士，每有一个骑士不在目标颜色，就要多移动至少一次</p>
<hr>
<p>设计估价函数$f(x) = d(x) + dep$，其中$d(x)$表示有几处不同，$dep$表示目前步数，明显有与实际步数$g(x)$比，有$f(x) \leq g(x)$，可以使用 设计出以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> value[<span class="number">5</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (rint i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) <span class="keyword">for</span> (rint j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++j)</span><br><span class="line">        <span class="keyword">if</span> (a[i][j] != value[i][j])</span><br><span class="line">            ++sum;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了IDA*核心的估价函数，写出暴力DFS即可 完整代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> value[<span class="number">5</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++j)</span><br><span class="line">        <span class="keyword">if</span> (a[i][j] != value[i][j])</span><br><span class="line">            ++sum;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ok;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span> &#125;,</span><br><span class="line">    dy[] = &#123; <span class="number">2</span>, <span class="number">-2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> dep, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> max_dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep == max_dep) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">judge</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            ok = <span class="literal">true</span>;</span><br><span class="line">            ans = max_dep;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (nx &lt; <span class="number">0</span>  ny &lt; <span class="number">0</span>  nx &gt; <span class="number">4</span>  ny &gt; <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">swap</span>(a[x][y], a[nx][ny]);</span><br><span class="line">        <span class="keyword">if</span> (dep + <span class="built_in">judge</span>() &lt;= max_dep)</span><br><span class="line">            <span class="built_in">dfs</span>(dep + <span class="number">1</span>, nx, ny, max_dep);</span><br><span class="line">        <span class="keyword">if</span> (ok) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">swap</span>(a[x][y], a[nx][ny]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">char</span> c; <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++j) &#123;</span><br><span class="line">                cin &gt;&gt; c;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    a[i][j] = <span class="number">2</span>;</span><br><span class="line">                    x = i;</span><br><span class="line">                    y = j;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    a[i][j] = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">judge</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">-1</span>; ok = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(<span class="number">0</span>, x, y, i);</span><br><span class="line">            <span class="keyword">if</span> (ok) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SCOI2009windy数</title>
    <url>/2019/05/11/scoi2009windy%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2657">[SCOI2009]windy数</a> 数位DP第一题。首先转化下题意，统计$[a,b]$答案即$[1,b]-[1,a-1]$。 设计状态$f[i][j]$表示第$i$位，上一个数字是$j$的答案。记忆化搜索一下。搜的时候还要记录有没有前导0，有没有限制。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dig[<span class="number">20</span>], f[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> pre, <span class="keyword">bool</span> lim, <span class="keyword">bool</span> zero)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!lim &amp;&amp; !zero &amp;&amp; f[pos][pre] != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> f[pos][pre];</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, up = lim ? dig[pos] : <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= up; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (zero) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                ret += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, i, lim &amp;&amp; i == up, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">else</span> ret += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, i, lim &amp;&amp; i == up, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(i - pre) &lt; <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> ret += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, i, lim &amp;&amp; i == up, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!lim &amp;&amp; !zero)</span><br><span class="line">        f[pos][pre] = ret;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; x; x /= <span class="number">10</span>)</span><br><span class="line">        dig[++len] = x % <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(len, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">solve</span>(b) - <span class="built_in">solve</span>(a - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SCOI2012 喵星球上的点名</title>
    <url>/2019/07/25/scoi2012-%E5%96%B5%E6%98%9F%E7%90%83%E4%B8%8A%E7%9A%84%E7%82%B9%E5%90%8D/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P2336">[SCOI2012]喵星球上的点名</a> 一个悲伤的故事：从前，有一个蒟蒻，他觉得用map的SAM比SA慢，于是写了SA，调试n久… 你们SA有一个好，就是复杂度比SAM高，代码还比SAM长 首先，每次点名之后，要找出来这个点名串在原串的哪部分中出现过。 SA做法：把姓名，询问离线存下来，建height，二分。 SAM做法：广义SAM，把询问在上面跑，终点和它的子树全部出现过。 不管是SA还是SAM，匹配询问后，都得到了一段询问出现的区间。原问题转化为序列上给定区间，区间内数颜色，颜色数包含它的区间。 莫队可以做，但是太慢了。用树状数组。 把区间按右端点排序。第一个问题就是HH的项链。第二个问题，扫到区间$[L,R]$的$L$时，$L+1$，扫到$R+1$时，$L-1$。扫到位置$i$的时候，$ans+=ask(i)-ask(last[color[i]])$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">2333</span>, S = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, str[N], tot, cat[N], tea[N], bel[N], lg[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fir[N], sec[N], buc[N], sa[N], rank[N], height[N], st[N][<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_sa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) ++buc[fir[i] = str[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) buc[i] += buc[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tot; i; --i) sa[buc[fir[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, p = <span class="number">0</span>; k &lt;= tot; k &lt;&lt;= <span class="number">1</span>, p = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tot - k + <span class="number">1</span>; i &lt;= tot; ++i) sec[++p] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt; k) sec[++p] = sa[i] - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) buc[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) ++buc[fir[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) buc[i] += buc[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tot; i; --i) sa[buc[fir[sec[i]]]--] = sec[i];</span><br><span class="line">        std::<span class="built_in">swap</span>(fir, sec); fir[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= tot; ++i)</span><br><span class="line">            fir[sa[i]] = sec[sa[i]] == sec[sa[i - <span class="number">1</span>]]</span><br><span class="line">                &amp;&amp; sec[sa[i] + k] == sec[sa[i - <span class="number">1</span>] + k]</span><br><span class="line">                ? p : ++p;</span><br><span class="line">        <span class="keyword">if</span> (p == tot) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) rank[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = <span class="number">0</span>; i &lt;= tot; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rank[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span>) --k;</span><br><span class="line">        <span class="keyword">int</span> j = sa[rank[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (str[i + k] == str[j + k]) ++k;</span><br><span class="line">        height[rank[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) st[i][<span class="number">0</span>] = height[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= tot; ++i)</span><br><span class="line">            st[i][j] = std::<span class="built_in">min</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= tot; ++i) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = lg[y - x + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">min</span>(st[x][t], st[y - (<span class="number">1</span> &lt;&lt; t) + <span class="number">1</span>][t]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n * <span class="number">2</span> + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) cat[i / <span class="number">2</span>] = tot + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len; ++j)</span><br><span class="line">            str[++tot] = <span class="built_in">rd</span>(), bel[tot] = i / <span class="number">2</span>;</span><br><span class="line">        str[++tot] = S + i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        tea[i] = tot + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len; ++j)</span><br><span class="line">            str[++tot] = <span class="built_in">rd</span>();</span><br><span class="line">        str[++tot] = S + n * <span class="number">2</span> + i;</span><br><span class="line">    &#125;</span><br><span class="line">    tea[m + <span class="number">1</span>] = tot + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> first, second, id;</span><br><span class="line">&#125; op[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> Node &amp;x, <span class="keyword">const</span> Node &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.second &lt; y.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> &amp;first, <span class="keyword">int</span> &amp;second)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height[x + <span class="number">1</span>] &lt; y)</span><br><span class="line">        second = x;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> l = x + <span class="number">1</span>, r = tot;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">lcp</span>(x + <span class="number">1</span>, mid) &gt;= y)</span><br><span class="line">                l = mid + <span class="number">1</span>, second = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (height[x] &lt; y)</span><br><span class="line">        first = x;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = x - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">lcp</span>(mid + <span class="number">1</span>, x) &gt;= y)</span><br><span class="line">                r = mid - <span class="number">1</span>, first = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; ins[N], rem[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        op[i].id = i;</span><br><span class="line">        <span class="built_in">search</span>(rank[tea[i]], tea[i + <span class="number">1</span>] - tea[i] - <span class="number">1</span>, op[i].first, op[i].second);</span><br><span class="line">        ins[op[i].first].<span class="built_in">push_back</span>(op[i].first);</span><br><span class="line">        rem[op[i].second + <span class="number">1</span>].<span class="built_in">push_back</span>(op[i].first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bit1[N], bit2[N], ans1[N], ans2[N], last[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c[], <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; x &lt;= tot; x += x &amp; -x)</span><br><span class="line">        c[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> c[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; x; x -= x &amp; -x)</span><br><span class="line">        ret += c[x];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitwork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(op + <span class="number">1</span>, op + m + <span class="number">1</span>, comp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (op[i].second &gt; op[i - <span class="number">1</span>].second) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = op[i - <span class="number">1</span>].second + <span class="number">1</span>; j &lt;= op[i].second; ++j) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">unsigned</span> k = <span class="number">0</span>; k &lt; ins[j].<span class="built_in">size</span>(); ++k)</span><br><span class="line">                    <span class="built_in">add</span>(bit2, ins[j][k], <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">unsigned</span> k = <span class="number">0</span>; k &lt; rem[j].<span class="built_in">size</span>(); ++k)</span><br><span class="line">                    <span class="built_in">add</span>(bit2, rem[j][k], <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bel[sa[j]] == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                ans2[bel[sa[j]]] += <span class="built_in">ask</span>(bit2, j) - <span class="built_in">ask</span>(bit2, last[bel[sa[j]]]);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">add</span>(bit1, last[bel[sa[j]]], <span class="number">-1</span>);</span><br><span class="line">                last[bel[sa[j]]] = j;</span><br><span class="line">                <span class="built_in">add</span>(bit1, j, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans1[op[i].id] = <span class="built_in">ask</span>(bit1, op[i].second) - <span class="built_in">ask</span>(bit1, op[i].first - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans1[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans2[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">build_sa</span>();</span><br><span class="line">    <span class="built_in">binary</span>();</span><br><span class="line">    <span class="built_in">bitwork</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>HAOI2012道路</title>
    <url>/2019/02/06/haoi2012%E9%81%93%E8%B7%AF/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2505">[HAOI2012]道路</a> 一句话题意：求出每条边有多少条最短路经过。 题目没指定起点，于是枚举起点S，跑SPFA（Dijkstra被卡TLE了….）。 考虑对于起点S的一棵最短路径树，我们把在其它最短路径上的边也添加进这棵树上，则它成为了一个DAG。原因显然，边权全部为正，边是不可能开倒车的。 对于一条边x-&gt;y，由乘法原理，经过的最短路数=(S到x的最短路方案数)*(y到其它点的最短路方案数)。 记两个值的数组分别为cnt1[]，cnt2[]。我们可以在DAG上正序DP跑出cnt1，倒序跑出cnt2。 具体方法：cnt1[S] = 1，对于x-&gt;y，cnt1[y] += cnt1[x]。cnt2的每个点先设置为1，即自己到自己的方案数。拓扑倒序DP，对于x-&gt;y，cnt2[x] += cnt2[y]。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1600</span>, M = <span class="number">5100</span>, MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> from, to, nxt, c;</span><br><span class="line">    &#125; g[M * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N], tot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        g[++tot].to = y, g[tot].nxt = head[x],</span><br><span class="line">        g[tot].c = c, g[tot].from = x, </span><br><span class="line">        head[x] = tot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> ans[M], cnt1[N], cnt2[N], dis[N], in[N];</span><br><span class="line">    <span class="keyword">int</span> que[M * <span class="number">2</span>], l, r;</span><br><span class="line">    <span class="keyword">bool</span> ins[M], vis[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(ins, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ins));</span><br><span class="line">        dis[que[l = <span class="number">0</span>, r = <span class="number">1</span>] = s] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l != r) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = que[++l];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y = g[i].to; i; i = g[i].nxt, y = g[i].to) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[y] &gt; dis[x] + g[i].c) &#123;</span><br><span class="line">                    dis[y] = dis[x] + g[i].c;</span><br><span class="line">                    <span class="keyword">if</span> (!vis[y])</span><br><span class="line">                        que[++r] = y;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[x] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="keyword">if</span> (dis[g[i].from] + g[i].c == dis[g[i].to])</span><br><span class="line">                ins[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt1, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt1));</span><br><span class="line">        <span class="built_in">memset</span>(cnt2, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt2));</span><br><span class="line">        <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(in));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="keyword">if</span> (ins[i])</span><br><span class="line">                ++in[g[i].to];</span><br><span class="line">        que[l = <span class="number">0</span>, r = <span class="number">1</span>] = s, cnt1[s] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l != r) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = que[++l];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y = g[i].to; i; i = g[i].nxt, y = g[i].to) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ins[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (--in[y] == <span class="number">0</span>)</span><br><span class="line">                        que[++r] = y;</span><br><span class="line">                    cnt1[y] += cnt1[x], cnt1[y] %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = que[i]; cnt2[x] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y = g[i].to; i; i = g[i].nxt, y = g[i].to)</span><br><span class="line">                <span class="keyword">if</span> (ins[i])</span><br><span class="line">                    cnt2[x] += cnt2[y], cnt2[x] %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">spfa</span>(s), <span class="built_in">topo</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="keyword">if</span> (ins[i]) &#123;</span><br><span class="line">                ans[i] += (<span class="keyword">long</span> <span class="keyword">long</span>)cnt1[g[i].from] * cnt2[g[i].to];</span><br><span class="line">                ans[i] %= MOD;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>(), c = <span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">addedge</span>(x, y, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">solve</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SCOI2014舌尖上的方伯伯 DP计算几何</title>
    <url>/2020/01/11/scoi2014%E8%88%8C%E5%B0%96%E4%B8%8A%E7%9A%84%E6%96%B9%E4%BC%AF%E4%BC%AF-dp%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3289">[SCOI2014]舌尖上的方伯伯</a> 本题需要计算几何，把蔬菜看作点处理。 题目中有一个很强的限制：点必须被更近的井灌溉。考虑一种合法的方案，把两组点用一条线划分成两部分。可以发现，因为题目中的限制，一定可以通过一条直线来分割点。 如果可以画出一条分割线，它一个点也没有过，那么可以通过移动与旋转这条线，使得它压在一个点上，分割出的点集不变。如果存在一些点，离$A,B$两井距离相同，那么它们在一条分割线上。对这两种分割线进行讨论。 所以可以枚举一对点$(x,y)$，确定一条分割线。这条线至少过了两个点。 然后把这条分割线绕$x$旋转一个小角度，因为题目输入都是整数，它现在只交一个点。 对于过一个点的情况，记录所有划分方案，去重，检查是否合法即可。注意需要检查，距离两井距离相同的点数$\leq 1$。 对于过多个点的情况，注意到两个井连线一定关于分割线对称，先求出$A,B$分别需要包含分割线上的多少点。 按顺序考虑线上的点，考虑$f_{i,j,k}$表示前$i$个，选了$j$个点，和为$k$。记录方案数$f_{i,j,k}=f_{i-1,j,k}+f_{i-1,j-1,k-w_i}$。枚举$k$找到一种合法方案给答案贡献即可。 第一部分复杂度为$O(n^2)$，第二部分对$x$个点形成的线求一次，复杂度为$O(60x^3)$，平均每个点承担了大约$300$多次计算，总复杂度为$O(n^4)$。 PS：这题卡精度，#define double long double之后分会变低…窝太菜没办法特判了一点才过的…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; <span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">fabs</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> -x;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fabs</span>(x - y) &lt; eps)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> x &lt; y ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Grid</span> &#123;</span></span><br><span class="line">  <span class="keyword">double</span> x, y;</span><br><span class="line">&#125; Vector, Point;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;a, <span class="keyword">const</span> Point &amp;b) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; a.x + b.x, a.y + b.y &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span>/(<span class="keyword">const</span> Point &amp;a, <span class="keyword">double</span> b) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; a.x / b, a.y / b &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span>*(<span class="keyword">const</span> Point &amp;a, <span class="keyword">double</span> b) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; a.x * b, a.y * b &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Vector <span class="keyword">operator</span>-(<span class="keyword">const</span> Point &amp;a, <span class="keyword">const</span> Point &amp;b) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; a.x - b.x, a.y - b.y &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="keyword">operator</span>^(<span class="keyword">const</span> Vector &amp;a, <span class="keyword">const</span> Vector &amp;b) &#123;</span><br><span class="line">  <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">const</span> Point &amp;a, <span class="keyword">const</span> Point &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">sqrt</span>((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a, <span class="keyword">const</span> Point &amp;b) &#123;</span><br><span class="line">  <span class="keyword">return</span> !<span class="built_in">dcmp</span>(a.x, b.x) ? a.y &lt; b.y : a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get_val</span><span class="params">(<span class="keyword">const</span> Point &amp;a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.x &lt; a.y ? a.y : a.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point pt[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">  Point s, e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">on_line</span><span class="params">(<span class="keyword">const</span> Line &amp;a, <span class="keyword">const</span> Point &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !<span class="built_in">dcmp</span>((b - a.s) ^ (b - a.e));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">on_right</span><span class="params">(<span class="keyword">const</span> Line &amp;a, <span class="keyword">const</span> Point &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">dcmp</span>((b - a.s) ^ (a.e - a.s)) == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">is_vertical</span><span class="params">(<span class="keyword">const</span> Line &amp;a, <span class="keyword">const</span> Line &amp;b)</span> </span>&#123;</span><br><span class="line">  Vector va = a.e - a.s, vb = b.e - b.s;</span><br><span class="line">  <span class="keyword">return</span> !<span class="built_in">dcmp</span>(va.x * vb.x, va.y * vb.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">const</span> Line &amp;a, <span class="keyword">const</span> Point &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">abs</span>((b - a.s) ^ (a.e - a.s)) / <span class="built_in">get_dis</span>(a.s, a.e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">get_foot</span><span class="params">(<span class="keyword">const</span> Line &amp;a, <span class="keyword">const</span> Point &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> dis = <span class="built_in">get_dis</span>(a, b), xy = std::<span class="built_in">sqrt</span>(<span class="built_in">get_dis</span>(b, a.s) * <span class="built_in">get_dis</span>(b, a.s) - dis * dis);</span><br><span class="line">  Vector r = (a.e - a.s) * xy / <span class="built_in">get_dis</span>(a.s, a.e);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">get_dis</span>(a.s + r, b) == dis)</span><br><span class="line">    <span class="keyword">return</span> a.s + r;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> a.s - r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[N][N], ol[N], tot;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">2</span>][N][N * N];</span><br><span class="line"><span class="keyword">int</span> now;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fuck;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc1</span><span class="params">(<span class="keyword">const</span> Line &amp;line)</span> </span>&#123;</span><br><span class="line">  tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">on_line</span>(line, pt[i]))</span><br><span class="line">      ol[++tot] = i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; ++j)</span><br><span class="line">      vis[ol[i]][ol[j]] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  Point a = &#123; <span class="number">0</span>, <span class="number">0</span> &#125;, b = &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> xa = <span class="number">0</span>, xb = <span class="number">0</span>, ya = <span class="number">0</span>, yb = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> ca = <span class="number">0</span>, cb = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">on_line</span>(line, pt[i])) &#123;</span><br><span class="line">      Point foot = <span class="built_in">get_foot</span>(line, pt[i]);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">on_right</span>(line, pt[i])) &#123;</span><br><span class="line">        a = a + pt[i];</span><br><span class="line">        ++ca;</span><br><span class="line">        xa += <span class="built_in">get_dis</span>(line, pt[i]);</span><br><span class="line">        ya += <span class="built_in">get_val</span>(foot - pt[ol[<span class="number">1</span>]]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b = b + pt[i];</span><br><span class="line">        ++cb;</span><br><span class="line">        xb += <span class="built_in">get_dis</span>(line, pt[i]);</span><br><span class="line">        yb += <span class="built_in">get_val</span>(foot - pt[ol[<span class="number">1</span>]]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> need = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">dcmp</span>(xa * (cb + tot - i), xb * (ca + i))) &#123;</span><br><span class="line">      need = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (need == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">  now = <span class="number">0</span>;</span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) &#123;</span><br><span class="line">    now ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> del = <span class="built_in">get_val</span>(pt[ol[i]] - pt[ol[<span class="number">1</span>]]);</span><br><span class="line">    sum += del;</span><br><span class="line">    <span class="built_in">memset</span>(f[now], <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f[now]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">60</span> * i; ++k) &#123;</span><br><span class="line">        f[now][j][k] = f[now ^ <span class="number">1</span>][j][k];</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; k &gt;= del) &#123;</span><br><span class="line">          f[now][j][k] += f[now ^ <span class="number">1</span>][j - <span class="number">1</span>][k - del];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt;= tot * <span class="number">60</span>; ++w) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">dcmp</span>((ya + w) / (ca + need), (yb + sum - w) / (cb + tot - need))) &#123;</span><br><span class="line">      ans += f[now][need][w];</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_st</span><span class="params">(Line line, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (i != id &amp;&amp; <span class="built_in">on_line</span>(line, pt[i]))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> s = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == id)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">on_right</span>(line, pt[i]))</span><br><span class="line">      s = <span class="number">1ll</span> &lt;&lt; i;</span><br><span class="line">  &#125;</span><br><span class="line">  st.<span class="built_in">push_back</span>(s);</span><br><span class="line">  st.<span class="built_in">push_back</span>(<span class="built_in">s</span>  (<span class="number">1ll</span> &lt;&lt; id));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc2</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> s)</span> </span>&#123;</span><br><span class="line">  Point a = &#123; <span class="number">0</span>, <span class="number">0</span> &#125;, b = &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(s &amp; (<span class="number">1ll</span> &lt;&lt; i)))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    ++cnt;</span><br><span class="line">    a = a + pt[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!cnt  cnt == n)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  a = a / cnt;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s &amp; (<span class="number">1ll</span> &lt;&lt; i))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    b = b + pt[i];</span><br><span class="line">  &#125;</span><br><span class="line">  b = b / (n - cnt);</span><br><span class="line">  <span class="keyword">int</span> cnt_line = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s &amp; (<span class="number">1ll</span> &lt;&lt; i)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">dcmp</span>(<span class="built_in">get_dis</span>(a, pt[i]), <span class="built_in">get_dis</span>(b, pt[i])) == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">dcmp</span>(<span class="built_in">get_dis</span>(a, pt[i]), <span class="built_in">get_dis</span>(b, pt[i])) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">dcmp</span>(<span class="built_in">get_dis</span>(a, pt[i]), <span class="built_in">get_dis</span>(b, pt[i])))</span><br><span class="line">      ++cnt_line;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cnt_line &lt;= <span class="number">1</span>)</span><br><span class="line">    ++ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">56</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;17&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">24</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    std::cin &gt;&gt; pt[i].x &gt;&gt; pt[i].y;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">sort</span>(pt + <span class="number">1</span>, pt + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (vis[i][j])</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      Line line = &#123; pt[i], pt[j] &#125;;</span><br><span class="line">      <span class="built_in">calc1</span>(line);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">      Line line = &#123; pt[i], pt[j] &#125;;</span><br><span class="line">      line.e.x -= eps * <span class="number">5</span>;</span><br><span class="line">      line.e.y += eps * <span class="number">5</span>;</span><br><span class="line">      <span class="built_in">add_st</span>(line, i);</span><br><span class="line">      line.e = pt[j];</span><br><span class="line">      line.e.x += eps * <span class="number">5</span>;</span><br><span class="line">      line.e.y -= eps * <span class="number">5</span>;</span><br><span class="line">      <span class="built_in">add_st</span>(line, i);</span><br><span class="line">      line.e = pt[j];</span><br><span class="line">      line.e.x += eps * <span class="number">5</span>;</span><br><span class="line">      line.e.y += eps * <span class="number">5</span>;</span><br><span class="line">      <span class="built_in">add_st</span>(line, i);</span><br><span class="line">      line.e = pt[j];</span><br><span class="line">      line.e.x -= eps * <span class="number">5</span>;</span><br><span class="line">      line.e.y -= eps * <span class="number">5</span>;</span><br><span class="line">      <span class="built_in">add_st</span>(line, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)st.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(st[i] &amp; <span class="number">2</span>)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        st[i] ^= <span class="number">1ll</span> &lt;&lt; j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">sort</span>(st.<span class="built_in">begin</span>(), st.<span class="built_in">end</span>());</span><br><span class="line">  st.<span class="built_in">resize</span>(std::<span class="built_in">unique</span>(st.<span class="built_in">begin</span>(), st.<span class="built_in">end</span>()) - st.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i : st)</span><br><span class="line">    <span class="keyword">if</span> (i &amp;&amp; i != ((<span class="number">1ll</span> &lt;&lt; (n + <span class="number">1</span>)) - <span class="number">2</span>))</span><br><span class="line">      <span class="built_in">calc2</span>(i);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SCP-S模拟测试55</title>
    <url>/2019/09/29/scp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9555/</url>
    <content><![CDATA[<p><a href="https://baka.online/wp-content/uploads/2019/09/problems.pdf">看题</a></p>
<h3 id="T1-T2"><a href="#T1-T2" class="headerlink" title="T1,T2"></a>T1,T2</h3><p>两个水题不说了（虽然T2调了114514年但是她真的是水题… 顺便吐槽下，全世界T2都写的枚举选了多少公共物品，只有我写的先把只能一个人选的选满再退回去…</p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>把苹果看成点，吃苹果的关系看作边建图。 我们记$f_{x}$表示$x$是否可以最终活下来。$g_{x,y}$表示钦定$y$活下来，$x$能否活下来。 如果一对点可以一起存活，那么首先，它们必须能单独活下来，其次，它们不能因为钦定某个点活下来就挂掉。 考虑一下如何判断一个点会影响另一个点的存亡。可以发现，删掉一个点之后，删除关系会顺着边传递。如果一条边的编号是$id_i$，另一条是$id_j &gt; id_i$，且两边相连，关系就会传递。 于是，可以处理出每个点顺着边的$id$能到达哪些点，再枚举点对计算。$O(nm+n^3)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;bits/stdc++.h&amp;gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">410</span>, M = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, A[M], B[M], qwq[N], qaq[N][N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &amp;lt;= m; ++i)</span><br><span class="line">        A[i] = <span class="built_in">rd</span>(), B[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &amp;lt;= n; ++i) &#123;</span><br><span class="line">        qwq[i] = qaq[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j; --j) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = A[j], b = B[j];</span><br><span class="line">            <span class="keyword">if</span> (qaq[i][a] &amp;amp;&amp;amp; qaq[i][b]) &#123;</span><br><span class="line">                qwq[i] = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (qaq[i][a]  qaq[i][b])</span><br><span class="line">                qaq[i][a] = qaq[i][b] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &amp;lt;= n; ++i) <span class="keyword">if</span> (qwq[i])</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &amp;lt;= n; ++j) <span class="keyword">if</span> (qwq[j]) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &amp;lt;= n; ++k)</span><br><span class="line">                <span class="keyword">if</span> (qaq[i][k] &amp;amp;&amp;amp; qaq[j][k]) &#123;</span><br><span class="line">                    --ans; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(&amp;quot;%d\n&amp;quot;, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SDOI2011染色</title>
    <url>/2019/01/15/sdoi2011%E6%9F%93%E8%89%B2/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2486">[SDOI2011]染色</a> 洛谷疯狂推树剖题中… 题意：树上区间颜色修改&amp;&amp;询问区间有几段颜色 线段树维护区间内有几段颜色的思想很奇妙，即记录每一段最左边和最右边的颜色。某段有几段颜色等于分成两段后颜色数量和，如果断开处相同（即左段右端点与右段左端点颜色相同），则把答案-1。 有了这样的分析，本题解法就很明确了：树链剖分，维护区间内颜色数量。在询问时还要特别记录每一条链顶端颜色，以在合并两条链结果时处理相同颜色。</p>
<hr>
<p>手速巨慢选手半小时随便码出来的（然后因为Coding能力太弱又找了半小时错），丑就丑吧= =…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">2333</span>;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">G</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125; g[MAXN * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAXN], tot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w[MAXN], wt[MAXN], son[MAXN], fa[MAXN], sz[MAXN], dep[MAXN], top[MAXN], id[MAXN], num;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, lc, rc, cnt, lazy;</span><br><span class="line">&#125; t[MAXN * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    g[++tot].to = y, g[tot].nxt = head[x],</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[x] = f, dep[x] = dep[f] + <span class="number">1</span>, sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mxson = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="keyword">if</span> (y != f) &#123;</span><br><span class="line">            <span class="built_in">dfs1</span>(y, x);</span><br><span class="line">            sz[x] += sz[y];</span><br><span class="line">            <span class="keyword">if</span> (sz[y] &gt; mxson) &#123;</span><br><span class="line">                mxson = sz[y];</span><br><span class="line">                son[x] = y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line">    id[x] = ++num, wt[num] = w[x], top[x] = topf;</span><br><span class="line">    <span class="keyword">if</span> (!son[x]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], topf);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="keyword">if</span> (y != fa[x] &amp;&amp; y != son[x]) &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(y, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    t[p].cnt = t[p * <span class="number">2</span>].cnt + t[p * <span class="number">2</span> + <span class="number">1</span>].cnt;</span><br><span class="line">    <span class="keyword">if</span> (t[p * <span class="number">2</span>].rc == t[p * <span class="number">2</span> + <span class="number">1</span>].lc) --t[p].cnt;</span><br><span class="line">    t[p].lc = t[p * <span class="number">2</span>].lc, t[p].rc = t[p * <span class="number">2</span> + <span class="number">1</span>].rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[p].lazy) &#123;</span><br><span class="line">        t[p * <span class="number">2</span>].lc = t[p * <span class="number">2</span>].rc = t[p].lazy;</span><br><span class="line">        t[p * <span class="number">2</span> + <span class="number">1</span>].lc = t[p * <span class="number">2</span> + <span class="number">1</span>].rc = t[p].lazy;</span><br><span class="line">        t[p * <span class="number">2</span>].cnt = t[p * <span class="number">2</span> + <span class="number">1</span>].cnt = <span class="number">1</span>;</span><br><span class="line">        t[p * <span class="number">2</span>].lazy = t[p * <span class="number">2</span> + <span class="number">1</span>].lazy = t[p].lazy;</span><br><span class="line">        t[p].lazy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[p].l = l, t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        t[p].lc = t[p].rc = wt[l];</span><br><span class="line">        t[p].cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) &#123;</span><br><span class="line">        t[p].cnt = <span class="number">1</span>, t[p].lc = t[p].rc = t[p].lazy = c;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">change</span>(p * <span class="number">2</span>, l, r, c);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) <span class="built_in">change</span>(p * <span class="number">2</span> + <span class="number">1</span>, l, r, c);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt, lc, rc;</span><br><span class="line">    <span class="built_in">Query</span>(<span class="keyword">int</span> _cnt = <span class="number">0</span>, <span class="keyword">int</span> _lc = <span class="number">0</span>, <span class="keyword">int</span> _rc = <span class="number">0</span>) &#123;</span><br><span class="line">        cnt = _cnt, lc = _lc, rc = _rc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Query <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Query</span>(t[p].cnt, t[p].lc, t[p].rc);</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">bool</span> visl = <span class="literal">false</span>, visr = <span class="literal">false</span>;</span><br><span class="line">    Query ans1, ans2;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) &#123;</span><br><span class="line">        ans1 = <span class="built_in">query</span>(p * <span class="number">2</span>, l, r);</span><br><span class="line">        visl = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) &#123;</span><br><span class="line">        ans2 = <span class="built_in">query</span>(p * <span class="number">2</span> + <span class="number">1</span>, l, r);</span><br><span class="line">        visr = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visl &amp;&amp; visr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[p * <span class="number">2</span>].rc == t[p * <span class="number">2</span> + <span class="number">1</span>].lc)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Query</span>(ans1.cnt + ans2.cnt - <span class="number">1</span>, ans1.lc, ans2.rc);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Query</span>(ans1.cnt + ans2.cnt, ans1.lc, ans2.rc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (visl)</span><br><span class="line">        <span class="keyword">return</span> ans1;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (visr)</span><br><span class="line">        <span class="keyword">return</span> ans2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">range_change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>, id[top[x]], id[x], c);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="built_in">change</span>(<span class="number">1</span>, id[x], id[y], c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">range_query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, c1 = <span class="number">-1</span>, c2 = <span class="number">-1</span>;</span><br><span class="line">    Query q;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">            <span class="built_in">swap</span>(c1, c2);</span><br><span class="line">        &#125;</span><br><span class="line">        q = <span class="built_in">query</span>(<span class="number">1</span>, id[top[x]], id[x]);</span><br><span class="line">        ans += q.cnt;</span><br><span class="line">        <span class="keyword">if</span> (c1 == q.rc) --ans;</span><br><span class="line">        c1 = q.lc;</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; dep[y]) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="built_in">swap</span>(c1, c2);</span><br><span class="line">    &#125;</span><br><span class="line">    q = <span class="built_in">query</span>(<span class="number">1</span>, id[x], id[y]);</span><br><span class="line">    ans += q.cnt;</span><br><span class="line">    <span class="keyword">if</span> (q.lc == c1) --ans;</span><br><span class="line">    <span class="keyword">if</span> (q.rc == c2) --ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    N = <span class="built_in">rd</span>(), M = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) cin &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">addedge</span>(x, y), <span class="built_in">addedge</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> opt;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;opt);</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> z = <span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">range_change</span>(x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">range_query</span>(x, y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SCP-S模拟测试59</title>
    <url>/2019/10/04/scp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9559/</url>
    <content><![CDATA[<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>考虑直接跑bfs，发现复杂度不太对，原因是边太多了。于是可以优化一下。 两种优化方法：</p>
<ol>
<li>发现能访问的位置可以奇偶讨论。用set存点，每次某个点被访问过之后就删掉。</li>
<li>线段树维护区间max，如果发现可以更新max，就递归下去找点。</li>
</ol>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>发现较小的值不影响较大的值，可以把$A,B$都排一下序，从大到小。枚举高度考虑问题。 对于新的一种高度，一定在原来已经算过的区域外扩展了一段$L$形的区域。 记上一次$A,B$方向到达了位置$l_A,l_B$，这次扩展的长度为$a,b$。 搞一个DP，$f_x$表示$a$方向$\geq x$行没放好的方案数（列全部放好了）。设当前考虑的数字为$v$，那么每个位置有$v+1$个数字可以放。 $$f_i = \binom{a}{i} (v^i (v+1)^{a-i})^{l_B} (v^i ((v+1)^{l_A+a-i} - v^{l_A+a-i} ))^b$$ 加上一个容斥 $$ \sum_{i} (-1)^i f_i$$</p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>不会。我事脑瘫（悲</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SDOI2011计算器</title>
    <url>/2019/04/21/sdoi2011%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2485">[SDOI2011]计算器</a> 这题一共三问。 第一问是裸快速幂不说了。第三问是BSGS，刚写过，也不多说了。 第二问，$ax \equiv b \pmod p$，即$ax + py = b$，exgcd可解。这里复习一下解法。由裴蜀定理，方程有解时，$gcd(a,p) \mid b$。先exgcd求一组特解，问题是通解怎么推。如果有$x1,y1,x2,y2$两组解，减一下，$a(x1-x2)=p(y2-y1)$，同除最大公约数，$a’(x1-x2)=p’(y2-y1)$，因为$gcd(a’,b’)=1$，所以$b’ \mid (x1-x2),a’ \mid (y2-y1)$。由此，通解是$x+kb’,y-ka’$。本题要求的答案即最小正整数通解，模一下完事。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fpow</span><span class="params">(ll x, ll y, ll p)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = x * x % p)</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = ans * x % p;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll r = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">bsgs</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123;</span><br><span class="line">    map&lt;ll, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">if</span> (a % p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p));</span><br><span class="line">    mp[b % p] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        mp[<span class="function">b * <span class="title">fpow</span><span class="params">(a, i, p)</span> % p] </span>= i;</span><br><span class="line">    ll t = <span class="built_in">fpow</span>(a, m, p), x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        x = x * t % p;</span><br><span class="line">        <span class="keyword">if</span> (mp[x]) &#123;</span><br><span class="line">            ll ans = i * m - mp[x];</span><br><span class="line">            <span class="keyword">return</span> (ans % p + p) % p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="keyword">int</span> T, k;</span><br><span class="line">    cin &gt;&gt; T &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll y, z, p;</span><br><span class="line">        cin &gt;&gt; y &gt;&gt; z &gt;&gt; p;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">            cout &lt;&lt; <span class="built_in">fpow</span>(y, z, p) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k == <span class="number">2</span>) &#123;</span><br><span class="line">            ll x, xx, g = <span class="built_in">exgcd</span>(y, p, x, xx);</span><br><span class="line">            <span class="keyword">if</span> (z % g != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Orz, I cannot find x!&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ll t1 = p / g, t2 = z / g;</span><br><span class="line">            cout &lt;&lt; ((x * t2 % t1) + t1) % t1 &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k == <span class="number">3</span>) &#123;</span><br><span class="line">            ll ans = <span class="built_in">bsgs</span>(y, z, p);</span><br><span class="line">            <span class="keyword">if</span> (ans == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Orz, I cannot find x!&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SDOI2015序列统计 FFT生成函数</title>
    <url>/2019/09/11/sdoi2015%E5%BA%8F%E5%88%97%E7%BB%9F%E8%AE%A1-fft%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P3321">[SDOI2015]序列统计</a> 当你复制错数据，导致出不了结果，你就自闭了 这题求的是乘法，假设求的是加法，考虑一下怎么做。 构造一枚生成函数$A$。 $$[x^i]A(x)=[i \in S]$$ 求一下$A^n(x)$即可。 现在变成了乘法，可以考虑使用原根转化为加法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">8000</span> * <span class="number">5</span> + <span class="number">233</span>, P = <span class="number">1004535809</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">fpow</span><span class="params">(LL x, <span class="keyword">int</span> y, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    LL ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = x * x % p)</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = ret * x % p;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G = <span class="number">3</span>, Gi = <span class="built_in">fpow</span>(G, P - <span class="number">2</span>, P);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, x, s, val[N], g, phi, pri[N], tot, map[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lim = <span class="number">1</span>, L, rev[N], INV;</span><br><span class="line">LL F1[N], F2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFT</span><span class="params">(LL f[], <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i])</span><br><span class="line">            std::<span class="built_in">swap</span>(f[i], f[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        LL T = <span class="built_in">fpow</span>(o == <span class="number">1</span> ? G : Gi, (P - <span class="number">1</span>) / (i &lt;&lt; <span class="number">1</span>), P);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += i &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">            LL w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k, w = w * T % P) &#123;</span><br><span class="line">                LL nx = f[j + k], ny = w * f[i + j + k] % P;</span><br><span class="line">                f[j + k] = (nx + ny) % P;</span><br><span class="line">                f[i + j + k] = (nx - ny + P) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>(), x = <span class="built_in">rd</span>(), s = <span class="built_in">rd</span>();</span><br><span class="line"></span><br><span class="line">    phi = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= phi; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (phi % i == <span class="number">0</span>) &#123;</span><br><span class="line">            pri[++tot] = i;</span><br><span class="line">            <span class="keyword">while</span> (phi % i == <span class="number">0</span>)</span><br><span class="line">                phi /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (phi &gt; <span class="number">1</span>)</span><br><span class="line">        pri[++tot] = phi;</span><br><span class="line">    phi = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, ok = <span class="number">1</span>; i &lt;= phi; ++i, ok = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; ++j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fpow</span>(i, phi / pri[j], m) == <span class="number">1</span>) &#123;</span><br><span class="line">                ok = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">            g = i; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m - <span class="number">2</span>; ++i)</span><br><span class="line">        map[<span class="built_in">fpow</span>(g, i, m)] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>() % m;</span><br><span class="line">        <span class="keyword">if</span> (x) F1[map[x]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lim &lt;= m &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">    INV = <span class="built_in">fpow</span>(lim, P - <span class="number">2</span>, P);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>)  ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (F2[<span class="number">0</span>] = <span class="number">1</span>; n; n &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">DFT</span>(F1, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">DFT</span>(F2, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">                F2[i] = F1[i] * F2[i] % P;</span><br><span class="line">            <span class="built_in">DFT</span>(F2, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">                F2[i] = F2[i] * INV % P;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lim - <span class="number">1</span>; i &gt;= m - <span class="number">1</span>; --i) &#123;</span><br><span class="line">                F2[i - m + <span class="number">1</span>] = (F2[i] + F2[i - m + <span class="number">1</span>]) % P;</span><br><span class="line">                F2[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">            F1[i] = F1[i] * F1[i] % P;</span><br><span class="line">        <span class="built_in">DFT</span>(F1, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">            F1[i] = F1[i] * INV % P;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lim - <span class="number">1</span>; i &gt;= m - <span class="number">1</span>; --i) &#123;</span><br><span class="line">            F1[i - m + <span class="number">1</span>] = (F1[i] + F1[i - m + <span class="number">1</span>]) % P;</span><br><span class="line">            F1[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, F2[map[x]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SDOI2014旅行</title>
    <url>/2019/06/04/sdoi2014%E6%97%85%E8%A1%8C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3313">[SDOI2014]旅行</a> 树剖，因为每次操作都是针对一种宗教的，每种宗教开一棵线段树。空间会炸，开动态开点的。 于是因为线段树写炸，这水题调了好久…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125; g[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot_1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    g[++tot_1].to = y, g[tot_1].nxt = head[x],</span><br><span class="line">    head[x] = tot_1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> rank[N], belief[N], fa[N], size[N],</span><br><span class="line">    son[N], dep[N], top[N], tot_2, id[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fat)</span> </span>&#123;</span><br><span class="line">    fa[x] = fat; dep[x] = dep[fat] + <span class="number">1</span>; size[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="keyword">if</span> (y == fat)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y, x);</span><br><span class="line">        <span class="keyword">if</span> (size[y] &gt; size[son[x]])</span><br><span class="line">            son[x] = y;</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line">    id[x] = ++tot_2; top[x] = topf;</span><br><span class="line">    <span class="keyword">if</span> (!son[x])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], topf);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="keyword">if</span> (y == fa[x]  y == son[x])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(y, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ls[N * <span class="number">50</span>], rs[N * <span class="number">50</span>], root[N], sum[N * <span class="number">50</span>], mx[N * <span class="number">50</span>], tot_3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) p = ++tot_3;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        sum[p] = mx[p] = y;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">change</span>(ls[p], x, y, L, mid);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(rs[p], x, y, mid + <span class="number">1</span>, R);</span><br><span class="line">    sum[p] = sum[ls[p]] + sum[rs[p]];</span><br><span class="line">    mx[p] = <span class="built_in">max</span>(mx[ls[p]], mx[rs[p]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_sum</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R)</span><br><span class="line">        <span class="keyword">return</span> sum[p];</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">        ret += <span class="built_in">query_sum</span>(ls[p], l, r, L, mid);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">        ret += <span class="built_in">query_sum</span>(rs[p], l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_max</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R)</span><br><span class="line">        <span class="keyword">return</span> mx[p];</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">        ret = <span class="built_in">max</span>(ret, <span class="built_in">query_max</span>(ls[p], l, r, L, mid));</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">        ret = <span class="built_in">max</span>(ret, <span class="built_in">query_max</span>(rs[p], l, r, mid + <span class="number">1</span>, R));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">range_query_sum</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]])</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">        ret += <span class="built_in">query_sum</span>(root[c], id[top[x]], id[x], <span class="number">1</span>, n);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; dep[y])</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">return</span> ret + <span class="built_in">query_sum</span>(root[c], id[x], id[y], <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">range_query_max</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]])</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">        ret = <span class="built_in">max</span>(ret, <span class="built_in">query_max</span>(root[c], id[top[x]], id[x], <span class="number">1</span>, n));</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; dep[y])</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(ret, <span class="built_in">query_max</span>(root[c], id[x], id[y], <span class="number">1</span>, n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(); m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        rank[i] = <span class="built_in">rd</span>();</span><br><span class="line">        belief[i] = <span class="built_in">rd</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">addedge</span>(x, y);</span><br><span class="line">        <span class="built_in">addedge</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">change</span>(root[belief[i]], id[i], rank[i], <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> opt[<span class="number">5</span>]; <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, opt);</span><br><span class="line">        x = <span class="built_in">rd</span>(); y = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (opt[<span class="number">1</span>] == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">change</span>(root[belief[x]], id[x], <span class="number">0</span>, <span class="number">1</span>, n);</span><br><span class="line">                belief[x] = y;</span><br><span class="line">                <span class="built_in">change</span>(root[belief[x]], id[x], rank[x], <span class="number">1</span>, n);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rank[x] = y;</span><br><span class="line">                <span class="built_in">change</span>(root[belief[x]], id[x], rank[x], <span class="number">1</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (opt[<span class="number">1</span>] == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">range_query_sum</span>(belief[x], x, y));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">range_query_max</span>(belief[x], x, y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">// freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> kai586123::<span class="built_in">main</span>(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SDOI2014数表</title>
    <url>/2019/07/12/sdoi2014%E6%95%B0%E8%A1%A8/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3312">[SDOI2014]数表</a> 劲爆反演题。 $$Ans = \sum_{i=1}^n \sum_{j=1}^m \sum_{d \mid i,j}d$$ $$= \sum_{d=1}^nd \lfloor \frac{n}{d} \rfloor \lfloor \frac{m}{d} \rfloor$$ 然后就做完了 如果没有那个万恶的限制，就做完了。加上限制不可做。 那肿么办呢OAO 加特技： 有个结论： $$id=\sigma * \mu$$ 证明： $$id * I=\sigma=\sigma * \mu * I$$ 于是得到这玩意： $$\sum_{d=1}^n \lfloor \frac{n}{d} \rfloor \lfloor \frac{m}{d} \rfloor \sum_{k \mid d}\sigma(k)\mu(\frac{d}{k})$$ 后面这玩意记为$f$，$a \geq \sigma(k)$时，$\sigma(k)\mu(\frac{d}{k})$才对$f$有贡献。 用树状数组维护$f$，就可做了。 还有个问题是怎么筛$\sigma$。 $$\sigma(p^k)=\sum_{i=0}^kp^i$$ 维护$low(i)$，表示$i$的最小$p$的$p^{k+1}$（等比求和）。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SDOI2015约数个数和</title>
    <url>/2019/06/23/sdoi2015%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3327">[SDOI2015]约数个数和</a> $$d(nm)=\sum_{i \mid n} \sum_{j \mid m}[gcd(i,j)=1]$$ 证明：$令n=\prod p_i^{x_i},m=\prod p_i^{y_i},i=\prod p_i^{a_i},j=\prod p_i^{b_i}$。如果$gcd(i,j)=1$，考虑第一个因子$p_1$，$i,j$中必有一个$p_1$的指数为$0$。一共有$x_1+y_1+1$种情况，对总个数贡献为$x_1+y_1+1$。这玩意乘起来和因数个数公式长得一样。 $$\sum_{i=1}^n \sum_{j=1}^md(ij)$$ $$\sum_{i=1}^n \sum_{j=1}^m \sum_{x \mid i} \sum_{y \mid j}[gcd(x,y)=1]$$ 先枚举$x,y$ $$\sum_{x=1}^n \sum_{y=1}^m \lfloor \frac{n}{x} \rfloor \lfloor \frac{m}{y} \rfloor [gcd(x,y)=1]$$ $$\sum_{x=1}^n \sum_{y=1}^m \lfloor \frac{n}{x} \rfloor \lfloor \frac{m}{y} \rfloor \sum_{d \mid gcd(x,y)} \mu (d)$$ 先枚举$d$ $$\sum_{d=1}^{min(n,m)} \mu (d) \sum_{x=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{y=1}^{\lfloor \frac{m}{d} \rfloor} \lfloor \frac{n}{dx} \rfloor \lfloor \frac{m}{dy} \rfloor $$ $$\sum_{d=1}^{min(n,m)} \mu (d) \sum_{x=1}^{\lfloor \frac{n}{d} \rfloor} \lfloor \frac{n}{dx} \rfloor \sum_{y=1}^{\lfloor \frac{m}{d} \rfloor} \lfloor \frac{m}{dy} \rfloor $$ $\mu$，以及两个求和式都能预处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50000</span> + <span class="number">2333</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[N], mu[N], tot, pre[N], g[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) prime[++tot] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt; N; ++j) &#123;</span><br><span class="line">            vis[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i * prime[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= i; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = i / (i / l);</span><br><span class="line">            g[i] += (r - l + <span class="number">1</span>) * (i / l);</span><br><span class="line">        &#125;</span><br><span class="line">        pre[i] = pre[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, ans = <span class="number">0</span>; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) <span class="built_in">swap</span>(n, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = <span class="built_in">min</span>(n / (n / l), m / (m / l));</span><br><span class="line">        ans += (pre[r] - pre[l - <span class="number">1</span>]) * g[n / l] * g[m / l];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(); <span class="keyword">int</span> T; cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SDOI2016生成魔咒</title>
    <url>/2019/06/11/sdoi2016%E7%94%9F%E6%88%90%E9%AD%94%E5%92%92/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4070">[SDOI2016]生成魔咒</a> 一个不是那么板的板子题，入门用。</p>
<h4 id="解法1：SA"><a href="#解法1：SA" class="headerlink" title="解法1：SA"></a>解法1：SA</h4><p>如果给定一个串，求不同子串数目，有以下做法： 用SA求出height，答案是$n(n+1)/2-\sum height$。 长度为$n$的串，字串个数为$n(n+1)/2$。相同串的数目就是$\sum height$。原因是每次都去掉了和上一个串重复的串。 本题动态添加后缀，可以把串反转，看作动态添加前缀。离线求出最终串的height。插入新字符$x$时，在已经存在的串里$sa$的前后缀为$pre,suf$，对于重复串个数$cnt$，$cnt=cnt-lcp(pre,suf)+lcp(pre,i)+lcp(i,suf)$。 用set或者链表维护前后缀可做。$O(nlogn)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">233</span>, INF = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> n, nn, a[N], s[N];</span><br><span class="line"><span class="keyword">int</span> fir[N], sec[N], buc[N], sa[N], rk[N], ht[N];</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">20</span>], lg2[N];</span><br><span class="line">std::set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lcp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> n - x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lg = lg2[y - x];</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">min</span>(st[x + <span class="number">1</span>][lg], st[y - (<span class="number">1</span> &lt;&lt; lg) + <span class="number">1</span>][lg]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) buc[i] = a[i] = <span class="built_in">rd</span>();</span><br><span class="line">    std::<span class="built_in">sort</span>(buc + <span class="number">1</span>, buc + n + <span class="number">1</span>);</span><br><span class="line">    nn = std::<span class="built_in">unique</span>(buc + <span class="number">1</span>, buc + n + <span class="number">1</span>) - buc - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = std::<span class="built_in">lower_bound</span>(buc + <span class="number">1</span>, buc + n + <span class="number">1</span>, a[i]) - buc;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) s[n - i + <span class="number">1</span>] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) buc[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++buc[fir[i] = s[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) buc[i] += buc[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[buc[fir[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>, k = <span class="number">1</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>, p = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; ++i) sec[++p] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt; k) sec[++p] = sa[i] - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) buc[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++buc[fir[sec[i]]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) buc[i] += buc[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[buc[fir[sec[i]]]--] = sec[i];</span><br><span class="line">        std::<span class="built_in">swap</span>(fir, sec); p = fir[sa[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            fir[sa[i]] = sec[sa[i]] == sec[sa[i - <span class="number">1</span>]]</span><br><span class="line">                &amp;&amp; sec[sa[i] + k] == sec[sa[i - <span class="number">1</span>] + k]</span><br><span class="line">                ? p : ++p;</span><br><span class="line">        <span class="keyword">if</span> (p == n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, p = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; <span class="number">0</span>) --p;</span><br><span class="line">        j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (s[i + p] == s[j + p]) ++p;</span><br><span class="line">        ht[rk[i]] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        st[i][<span class="number">0</span>] = ht[i];</span><br><span class="line">        lg2[i] = <span class="built_in">log2</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">20</span>; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i)</span><br><span class="line">            st[i][j] = std::<span class="built_in">min</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    set.<span class="built_in">insert</span>(INF); set.<span class="built_in">insert</span>(-INF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n, cnt = <span class="number">0</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> pre = *--set.<span class="built_in">lower_bound</span>(rk[i]), suf = *set.<span class="built_in">lower_bound</span>(rk[i]);</span><br><span class="line">        <span class="keyword">if</span> (pre != -INF) cnt += <span class="built_in">lcp</span>(pre, rk[i]);</span><br><span class="line">        <span class="keyword">if</span> (suf != INF) cnt += <span class="built_in">lcp</span>(rk[i], suf);</span><br><span class="line">        <span class="keyword">if</span> (pre != -INF &amp;&amp; suf != INF) cnt -= <span class="built_in">lcp</span>(pre, suf);</span><br><span class="line">        set.<span class="built_in">insert</span>(rk[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (<span class="keyword">long</span> <span class="keyword">long</span>)(n - i + <span class="number">1</span>) * (n - i + <span class="number">2</span>) / <span class="number">2</span> - cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法2：SAM"><a href="#解法2：SAM" class="headerlink" title="解法2：SAM"></a>解法2：SAM</h4><p>SAM上的每个点都可以表示一些串。如果能表示的长度为$[min,max]$，那么这个点$p$能表示的不同串个数为$max[p]-min[p]+1=len[p]-len[fa[p]]$。$O(n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> last = <span class="number">1</span>, fa[N * <span class="number">2</span>], len[N * <span class="number">2</span>], tot = <span class="number">1</span>;</span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ch[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = last, np = ++tot;</span><br><span class="line">    last = np; len[np] = len[p] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; ch[p].<span class="built_in">find</span>(c) == ch[p].<span class="built_in">end</span>())</span><br><span class="line">        ch[p][c] = np, p = fa[p];</span><br><span class="line">    <span class="keyword">if</span> (!p) &#123; fa[np] = <span class="number">1</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> q = ch[p][c];</span><br><span class="line">    <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) &#123; fa[np] = q; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> nq = ++tot; len[nq] = len[p] + <span class="number">1</span>;</span><br><span class="line">    ch[nq] = ch[q]; fa[nq] = fa[q]; fa[q] = fa[np] = nq;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; ch[p].<span class="built_in">find</span>(c) != ch[p].<span class="built_in">end</span>() &amp;&amp; ch[p][c] == q)</span><br><span class="line">        ch[p][c] = nq, p = fa[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="built_in">insert</span>(n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans += len[last] - len[fa[last]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SDOI2017数字表格</title>
    <url>/2019/06/23/sdoi2017%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3704">[SDOI2017]数字表格</a> 令$n \leq m$，题目所求： $$\prod_{i=1}^n \prod_{j=1}^mf[gcd(i,j)]$$ 枚举$gcd(i,j)=d$ $$\prod_{d=1}^n\prod_{i=1}^n \prod_{j=1}^mf[d][gcd(i,j)=d]$$ 把相同的$f$放在一起 $$\prod_{d=1}^n f[d] ^ { \sum_{i=1} ^ { \lfloor \frac{n}{d} \rfloor} \sum_{j=1} ^ { \lfloor \frac{m}{d} \rfloor} [gcd(i,j)=1] }$$ 处理右上角那一坨： $$\sum_{i=1} ^ { \lfloor \frac{n}{d} \rfloor} \sum_{j=1} ^ { \lfloor \frac{m}{d} \rfloor} [gcd(i,j)=1]$$ $$\sum_{i=1} ^ { \lfloor \frac{n}{d} \rfloor} \sum_{j=1} ^ { \lfloor \frac{m}{d} \rfloor} \sum_{k \mid gcd(i,j)} \mu(k)$$ $$\sum_{k=1}^{ \lfloor \frac{n}{d} \rfloor } \mu (d) \lfloor \frac{n}{kd} \rfloor \lfloor \frac{m}{kd} \rfloor$$ 根据套路，此时应该枚举$kd$了 令$T=kd$，原式可化为 $$\prod_{T=1}^n \prod_{d \mid T}f[d] ^ { \mu (\frac{T}{d}) \lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor }$$ 把和$d$有关无关的分开 $$\prod_{T=1}^n (\prod_{d \mid T}f[d] ^ { \mu (\frac{T}{d}) } ) ^ { \lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor }$$ 然后如果里面可以快速知道，就能分块了。 实际上因为数据范围只有$1e6$，可以枚举因数预处理里面的东西。预处理斐波那契数列和逆元，从而求出里面这东西的前缀乘积和逆元。 复杂度大约算了一下，预处理是$O(nlogn + nlogP)$，询问是$O(T \sqrt n log P)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">2333</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N], tot, mu[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N]; LL f1[N], f2[N], g1[N], g2[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">fpow</span><span class="params">(LL x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    LL ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = x * x % P)</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = ret * x % P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) prime[++tot] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt; N; ++j) &#123;</span><br><span class="line">            vis[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i * prime[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f1[<span class="number">1</span>] = f2[<span class="number">1</span>] =  <span class="number">1</span>;</span><br><span class="line">    g1[<span class="number">0</span>] = g1[<span class="number">1</span>] = g2[<span class="number">0</span>] = g2[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        f1[i] = (f1[i - <span class="number">1</span>] + f1[i - <span class="number">2</span>]) % P;</span><br><span class="line">        f2[i] = <span class="built_in">fpow</span>(f1[i], P - <span class="number">2</span>);</span><br><span class="line">        g1[i] = g2[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mu[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; N; j += i)</span><br><span class="line">            g1[j] = g1[j] * (mu[i] == <span class="number">1</span> ? f1[j / i] : f2[j / i]) % P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        g1[i] = g1[i] * g1[i - <span class="number">1</span>] % P;</span><br><span class="line">        g2[i] = <span class="built_in">fpow</span>(g1[i], P - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) <span class="built_in">swap</span>(n, m);</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = <span class="built_in">min</span>(n / (n / l), m / (m / l));</span><br><span class="line">        ans = ans * <span class="built_in">fpow</span>(g1[r] * g2[l - <span class="number">1</span>] % P,</span><br><span class="line">            <span class="number">1LL</span> * (n / l) * (m / l) % (P - <span class="number">1</span>)) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(); <span class="keyword">int</span> T; cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SDOI2017树点涂色</title>
    <url>/2019/07/03/sdoi2017%E6%A0%91%E7%82%B9%E6%B6%82%E8%89%B2/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3703">[SDOI2017]树点涂色</a> 这个1操作看着像LCT的Access，感觉起来像Access，那么它就是Access。 操作一把一个点到根染成同一种颜色，考虑LCT维护这个树。发现一个点到根的值，就是它到根路上虚边的个数。 操作2可以转化为三个单点查询（查的两个点和LCA）。操作三是子树查询。考虑线段树维护答案。 然后再观察LCT的Access，断开一条实边的时候，子树答案+1，连接一条实边的时候，子树答案-1。 最后大力敲代码，线段树+树剖+LCT=200行。 注意，Access的时候，对于某个点的右儿子，要找到它所在树的根，从根那里+-1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">2333</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SEG &#123;</span><br><span class="line">    <span class="keyword">int</span> max[N * <span class="number">4</span>], lazy[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        max[p] = std::<span class="built_in">max</span>(max[p &lt;&lt; <span class="number">1</span>], max[p &lt;&lt; <span class="number">1</span>  <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazy[p]) &#123;</span><br><span class="line">            lazy[p &lt;&lt; <span class="number">1</span>] += lazy[p];</span><br><span class="line">            lazy[p &lt;&lt; <span class="number">1</span>  <span class="number">1</span>] += lazy[p];</span><br><span class="line">            max[p &lt;&lt; <span class="number">1</span>] += lazy[p];</span><br><span class="line">            max[p &lt;&lt; <span class="number">1</span>  <span class="number">1</span>] += lazy[p];</span><br><span class="line">            lazy[p] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> f[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            max[p] = f[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid, f);</span><br><span class="line">        <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>  <span class="number">1</span>, mid + <span class="number">1</span>, r, f);</span><br><span class="line">        <span class="built_in">pushup</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R) &#123;</span><br><span class="line">            max[p] += v;</span><br><span class="line">            lazy[p] += v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(p);</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">            <span class="built_in">add</span>(p &lt;&lt; <span class="number">1</span>, l, r, v, L, mid);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">            <span class="built_in">add</span>(p &lt;&lt; <span class="number">1</span>  <span class="number">1</span>, l, r, v, mid + <span class="number">1</span>, R);</span><br><span class="line">        <span class="built_in">pushup</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R)</span><br><span class="line">            <span class="keyword">return</span> max[p];</span><br><span class="line">        <span class="built_in">pushdown</span>(p);</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">            ret = std::<span class="built_in">max</span>(ret, <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>, l, r, L, mid));</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">            ret = std::<span class="built_in">max</span>(ret, <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>  <span class="number">1</span>, l, r, mid + <span class="number">1</span>, R));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="keyword">int</span> to[N * <span class="number">2</span>], nxt[N * <span class="number">2</span>], head[N], tot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        to[++tot] = y;</span><br><span class="line">        nxt[tot] = head[x];</span><br><span class="line">        head[x] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HLD &#123;</span><br><span class="line">    <span class="keyword">int</span> n, fa[N], son[N], size[N], dep[N],</span><br><span class="line">        top[N], w[N], id[N], tot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> Graph::head;</span><br><span class="line">    <span class="keyword">using</span> Graph::nxt;</span><br><span class="line">    <span class="keyword">using</span> Graph::to;</span><br><span class="line">    <span class="keyword">using</span> Graph::addedge;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> SEG::add;</span><br><span class="line">    <span class="keyword">using</span> SEG::query;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fath)</span> </span>&#123;</span><br><span class="line">        fa[x] = fath; size[x] = <span class="number">1</span>; dep[x] = dep[fath] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (y != fath) &#123;</span><br><span class="line">                <span class="built_in">dfs1</span>(y, x);</span><br><span class="line">                <span class="keyword">if</span> (size[y] &gt; size[son[x]])</span><br><span class="line">                    son[x] = y;</span><br><span class="line">                size[x] += size[y];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line">        top[x] = topf; id[x] = ++tot; w[tot] = dep[x];</span><br><span class="line">        <span class="keyword">if</span> (!son[x])</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(son[x], topf);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (y != fa[x] &amp;&amp; y != son[x])</span><br><span class="line">                <span class="built_in">dfs2</span>(y, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]])</span><br><span class="line">                <span class="built_in">swap</span>(x, y);</span><br><span class="line">            x = fa[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dep[x] &lt; dep[y])</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tree_add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">1</span>, id[x], id[x] + size[x] - <span class="number">1</span>, v, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">range_query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lca = <span class="built_in">get_lca</span>(x, y),</span><br><span class="line">            xx = <span class="built_in">query</span>(<span class="number">1</span>, id[x], id[x], <span class="number">1</span>, n),</span><br><span class="line">            yy = <span class="built_in">query</span>(<span class="number">1</span>, id[y], id[y], <span class="number">1</span>, n),</span><br><span class="line">            ll = <span class="built_in">query</span>(<span class="number">1</span>, id[lca], id[lca], <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">return</span> xx + yy - ll * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">tree_query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>, id[x], id[x] + size[x] - <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> LCT &#123;</span><br><span class="line">    <span class="keyword">int</span> fa[N], ch[N][<span class="number">2</span>], st[N], top;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>] != x &amp;&amp; ch[fa[x]][<span class="number">1</span>] != x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y = fa[x], z = fa[y], k = ch[y][<span class="number">1</span>] == x;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isroot</span>(y)) ch[z][ch[z][<span class="number">1</span>] == y] = x;</span><br><span class="line">        fa[x] = z; ch[y][k] = ch[x][k ^ <span class="number">1</span>];</span><br><span class="line">        fa[ch[y][k]] = y; ch[x][k ^ <span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isroot</span>(x)) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = fa[x], z = fa[y];</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isroot</span>(y))</span><br><span class="line">                <span class="built_in">rotate</span>((ch[z][<span class="number">1</span>] == y) ^ (ch[y][<span class="number">1</span>] == x) ? x : y);</span><br><span class="line">            <span class="built_in">rotate</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ch[x][<span class="number">0</span>])</span><br><span class="line">            x = ch[x][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; x; x = fa[y = x]) &#123;</span><br><span class="line">            <span class="built_in">splay</span>(x);</span><br><span class="line">            <span class="keyword">if</span> (ch[x][<span class="number">1</span>])</span><br><span class="line">                HLD::<span class="built_in">tree_add</span>(<span class="built_in">findroot</span>(ch[x][<span class="number">1</span>]), <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ((ch[x][<span class="number">1</span>] = y))</span><br><span class="line">                HLD::<span class="built_in">tree_add</span>(<span class="built_in">findroot</span>(ch[x][<span class="number">1</span>]), <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">love</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    HLD::n = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">        Graph::<span class="built_in">addedge</span>(x, y);</span><br><span class="line">        Graph::<span class="built_in">addedge</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HLD::<span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    HLD::<span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    SEG::<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n, HLD::w);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        LCT::fa[i] = HLD::fa[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op = <span class="built_in">rd</span>(), x = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            LCT::<span class="built_in">access</span>(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, HLD::<span class="built_in">range_query</span>(x, <span class="built_in">rd</span>()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, HLD::<span class="built_in">tree_query</span>(x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">love</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SDOI2017切树游戏 FWT动态DP</title>
    <url>/2020/04/27/sdoi2017%E5%88%87%E6%A0%91%E6%B8%B8%E6%88%8F-fwt%E5%8A%A8%E6%80%81dp/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3781">[SDOI2017]切树游戏</a> orz rqy。首先可以知道，维护每种值的方案即可。令$F_x$为$x$为根的子树的集合幂级数，只需要用$\prod (F_y+1)$更新即可。 那么无脑FWT一下。之后考虑动态化。那么就维护轻儿子和重链。令$H_x$表示$x$轻儿子合并后的东西，那么有$F_x=H_x(F_y+1)=H_x+H_xH_{xx’}+…$，也就是一堆积的和。 就可以知道一条链的答案就是所有子区间的积的和，线段树可以维护。 之后就是一些（很多）细节问题了。列举一二： FWT直接单点就可以了。考虑贡献发现就是更改正负号。 在修改时，因为不是用矩阵的方式维护的，要直接从某个$H$中除掉一部分。但是当是倍数的时候，没有逆元。解决方法是手写一个东西，维护每个点轻儿子中，有多少个$0$，以及剩下的乘积。 代码在洛谷T了两个点，不知道为什么，貌似被卡了，loj过了。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// orz rqy jiejie</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cerr;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_op</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isalpha</span>(c)) c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> c == <span class="string">&#x27;Q&#x27;</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e4</span> + <span class="number">233</span>, M = <span class="number">130</span>, P = <span class="number">10007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, val[N], cnt[N], inv[N];</span><br><span class="line"><span class="keyword">int</span> fa[N], son[N], size[N], top[N], dfn[N], id[N], num, bot[N];</span><br><span class="line"><span class="keyword">int</span> ans[M];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Int</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a, p;</span><br><span class="line">  <span class="built_in">Int</span>(<span class="keyword">int</span> t = <span class="number">0</span>) &#123;</span><br><span class="line">    a = (t == <span class="number">0</span> ? <span class="number">1</span> : t);</span><br><span class="line">    p = (t == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Int</span>(<span class="keyword">int</span> _a, <span class="keyword">int</span> _p) &#123; a = _a, p = _p; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> !p ? a : <span class="number">0</span>; &#125;</span><br><span class="line">  Int <span class="keyword">operator</span>+(<span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((x %= P) != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Int</span>(p &gt; <span class="number">0</span> ? x : (a + x) % P, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Int&amp; <span class="keyword">operator</span>*=(<span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(x %= P)) ++p;</span><br><span class="line">    <span class="keyword">else</span> a = a * x % P;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Int&amp; <span class="keyword">operator</span>/=(<span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(x %= P)) --p;</span><br><span class="line">    <span class="keyword">else</span> a = a * inv[(x + P) % P] % P;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Int H[N][M];</span><br><span class="line"><span class="keyword">int</span> F[N][M];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> sum[M], pre[M], suf[M], mul[M];</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="keyword">sizeof</span> pre);</span><br><span class="line">    <span class="built_in">memset</span>(suf, <span class="number">0</span>, <span class="keyword">sizeof</span> suf);</span><br><span class="line">    <span class="built_in">memset</span>(mul, <span class="number">0</span>, <span class="keyword">sizeof</span> mul);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">      mul[i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Node</span>() &#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line">  <span class="built_in">Node</span>(Int H[]) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">      sum[i] = pre[i] = suf[i] = mul[i] = H[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">friend</span> Node <span class="keyword">operator</span>*(<span class="keyword">const</span> Node &amp;l, <span class="keyword">const</span> Node &amp;r) &#123;</span><br><span class="line">    Node ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">      ret.sum[i] = (l.sum[i] + r.sum[i] + l.suf[i] * r.pre[i]) % P;</span><br><span class="line">      ret.pre[i] = (l.pre[i] + l.mul[i] * r.pre[i]) % P;</span><br><span class="line">      ret.suf[i] = (r.suf[i] + r.mul[i] * l.suf[i]) % P;</span><br><span class="line">      ret.mul[i] = l.mul[i] * r.mul[i] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; seg[N * <span class="number">4</span>], tmp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (p &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (ls  1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((L + R) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L != R)</span><br><span class="line">    seg[p] = seg[ls] * seg[rs];</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    seg[p] = <span class="built_in">Node</span>(H[id[L]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L != R) &#123;</span><br><span class="line">    <span class="built_in">build</span>(ls, L, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, R);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pushup</span>(p, L, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L != R)</span><br><span class="line">    x &lt;= mid ? <span class="built_in">modify</span>(ls, x, L, mid)</span><br><span class="line">      : <span class="built_in">modify</span>(rs, x, mid + <span class="number">1</span>, R);</span><br><span class="line">  <span class="built_in">pushup</span>(p, L, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R)</span><br><span class="line">    <span class="keyword">return</span> tmp = tmp * seg[p], <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">query</span>(ls, l, r, L, mid);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) <span class="built_in">query</span>(rs, l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dad)</span> </span>&#123;</span><br><span class="line">  fa[x] = dad, size[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y : G[x]) <span class="keyword">if</span> (y != dad) &#123;</span><br><span class="line">    <span class="built_in">dfs1</span>(y, x);</span><br><span class="line">    size[x] += size[y];</span><br><span class="line">    <span class="keyword">if</span> (size[son[x]] &lt; size[y])</span><br><span class="line">      son[x] = y;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // what the fuck ??</span></span><br><span class="line"><span class="comment">    if (!son[x]  size[son[x]] + 50 &lt; size[y])</span></span><br><span class="line"><span class="comment">      son[x] = y;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  top[x] = topf, id[dfn[x] = ++num] = x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!son[x]) &#123;</span><br><span class="line">    bot[x] = x;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], topf);</span><br><span class="line">    bot[x] = bot[son[x]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    H[x][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y : G[x])</span><br><span class="line">    <span class="keyword">if</span> (y != fa[x] &amp;&amp; y != son[x]) &#123;</span><br><span class="line">      <span class="built_in">dfs2</span>(y, y);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        H[x][i] *= F[y][i] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    <span class="keyword">if</span> (cnt[i &amp; val[x]] &amp; <span class="number">1</span>)</span><br><span class="line">      H[x][i] *= <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    F[x][i] = H[x][i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (son[x])</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">      F[x][i] = F[x][i] * (F[son[x]][i] + <span class="number">1</span>) % P;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    ans[i] = (ans[i] + F[x][i]) % P;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">modify</span>(<span class="number">1</span>, dfn[x], <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">int</span> y = top[x];</span><br><span class="line">  <span class="built_in">cut</span>(fa[y]);</span><br><span class="line">  tmp.<span class="built_in">init</span>();</span><br><span class="line">  <span class="built_in">query</span>(<span class="number">1</span>, dfn[y], dfn[bot[y]], <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    ans[i] = (ans[i] - tmp.sum[i] + P) % P;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    H[fa[y]][i] /= tmp.pre[i] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">modify</span>(<span class="number">1</span>, dfn[x], <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">int</span> y = top[x];</span><br><span class="line">  tmp.<span class="built_in">init</span>();</span><br><span class="line">  <span class="built_in">query</span>(<span class="number">1</span>, dfn[y], dfn[bot[y]], <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    ans[i] = (ans[i] + tmp.sum[i]) % P;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    H[fa[y]][i] *= tmp.pre[i] + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">link</span>(fa[y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cut</span>(x);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    <span class="keyword">if</span> (cnt[i &amp; val[x]] &amp; <span class="number">1</span>)</span><br><span class="line">      H[x][i] *= <span class="number">-1</span>;</span><br><span class="line">  val[x] = y;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    <span class="keyword">if</span> (cnt[i &amp; val[x]] &amp; <span class="number">1</span>)</span><br><span class="line">      H[x][i] *= <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">link</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">  inv[<span class="number">1</span>] = cnt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; P; ++i) &#123;</span><br><span class="line">    inv[i] = P - P / i * inv[P % i] % P;</span><br><span class="line">    cnt[i] = cnt[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    val[i] = <span class="built_in">rd</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">    G[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    G[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  q = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    <span class="keyword">int</span> op = <span class="built_in">get_op</span>(), x = <span class="built_in">rd</span>(), y = op == <span class="number">2</span> ? <span class="built_in">rd</span>() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        sum = (sum + (cnt[i &amp; x] &amp; <span class="number">1</span> ? P - <span class="number">1</span> : <span class="number">1</span>) * ans[i]) % P;</span><br><span class="line">      sum = (sum * inv[m] % P + P) % P;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">modify</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  tmp.<span class="built_in">init</span>();</span><br><span class="line">  <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SDOI2019世界地图 最小生成树</title>
    <url>/2020/05/18/sdoi2019%E4%B8%96%E7%95%8C%E5%9C%B0%E5%9B%BE-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5360">[SDOI2019]世界地图</a> 只需要把前缀后缀的MST合并。考虑加入边的过程，只会删掉原来的环上的边。也就是说明只需要维护一些环即可。进一步的，可以把环上的链缩起来。 想法很简单，之后代码就不会写了。。网上冲浪后学习到了实现技巧： 直接暴力Kruskal合并两棵树。之后只需要在新树上缩掉一些边即可。 进行两次DFS：设置叶子节点为初始可用节点。随便选一个叶子开始DFS1。 在DFS1过程中，一个点子树中叶子的数量。如果超过两个叶子，说明这个点在叶子的环上，打标记。 在DFS2过程中，把两个端点都有标记的点加入新树中。用一个变量维护删掉的边的和并累计入答案。 注意到DFS过程是从一个叶子开始的，可以分析出，DFS不需要考虑父亲的情况。这样就简单的实现出来了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调试懒得删了</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cerr;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>, M = <span class="number">10005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> SA, SB, SC;</span><br><span class="line"><span class="keyword">int</span> n, m, q, lim, ri[M][N], dn[M][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SA ^= SA &lt;&lt; <span class="number">16</span>;</span><br><span class="line">  SA ^= SA &gt;&gt; <span class="number">5</span>;</span><br><span class="line">  SA ^= SA &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> t = SA;</span><br><span class="line">  SA = SB;</span><br><span class="line">  SB = SC;</span><br><span class="line">  SC ^= t ^ SA;</span><br><span class="line">  <span class="keyword">return</span> SC % lim + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x, y; <span class="keyword">long</span> <span class="keyword">long</span> w;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Edge &amp;a, <span class="keyword">const</span> Edge &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MST</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line">  std::vector&lt;Edge&gt; E;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">MST</span>() &#123; id = sum = <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="built_in">MST</span>(<span class="keyword">int</span> v[]) &#123;</span><br><span class="line">    id = n, E.<span class="built_in">resize</span>(n - <span class="number">1</span>), sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">      E[i - <span class="number">1</span>] = &#123; i, i + <span class="number">1</span>, v[i] &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = sum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : E)</span><br><span class="line">      ret += e.w;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; pre[M], suf[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> to, nxt, w;</span><br><span class="line">&#125; G[M * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[M], etot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  G[++etot] = &#123; y, head[x], w &#125;, head[x] = etot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">const</span> Edge &amp;e)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">addedge</span>(e.x, e.y, e.w);</span><br><span class="line">  <span class="built_in">addedge</span>(e.y, e.x, e.w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;Edge&gt; E;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tag[M];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mark all vertexs on line</span></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// std::cout &lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line">  <span class="keyword">int</span> son = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = G[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = G[i].to;</span><br><span class="line">    <span class="keyword">if</span> (y != fa)</span><br><span class="line">      son += !!<span class="built_in">dfs1</span>(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (son &gt;= <span class="number">2</span>)</span><br><span class="line">    tag[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// std::cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; son + tag[x] &lt;&lt; std::endl;</span></span><br><span class="line">  <span class="comment">// std::cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; tag[x] &lt;&lt; std::endl;</span></span><br><span class="line">  <span class="keyword">return</span> son + tag[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> ver, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tag[x]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ver)</span><br><span class="line">      E.<span class="built_in">push_back</span>(&#123; tag[x], ver, val &#125;);</span><br><span class="line">    ver = tag[x];</span><br><span class="line">    sum -= val;</span><br><span class="line">    val = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = G[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = G[i].to;</span><br><span class="line">    <span class="keyword">if</span> (y != fa) &#123;</span><br><span class="line">      <span class="built_in">dfs2</span>(y, x, ver, std::<span class="built_in">max</span>(val, G[i].w));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> MST <span class="title">merge</span><span class="params">(<span class="keyword">const</span> MST &amp;a, <span class="keyword">const</span> MST &amp;b, <span class="keyword">int</span> v[])</span> </span>&#123;</span><br><span class="line">  id = a.id + b.id;</span><br><span class="line">  E.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> e : a.E)</span><br><span class="line">    E.<span class="built_in">push_back</span>(e);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> e : b.E)</span><br><span class="line">    E.<span class="built_in">push_back</span>(&#123; e.x + a.id, e.y + a.id, e.w &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    E.<span class="built_in">push_back</span>(&#123; a.id - n + i, a.id + i, v[i] &#125;);</span><br><span class="line">  std::<span class="built_in">sort</span>(E.<span class="built_in">begin</span>(), E.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= id; ++i) &#123;</span><br><span class="line">    fa[i] = i;</span><br><span class="line">    head[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= n  i &gt;= id - n + <span class="number">1</span>)</span><br><span class="line">      tag[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      tag[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  etot = <span class="number">0</span>;</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> e : E) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">find</span>(e.x), y = <span class="built_in">find</span>(e.y);</span><br><span class="line">    <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">      <span class="built_in">addedge</span>(e);</span><br><span class="line">      fa[x] = y;</span><br><span class="line">      sum += e.w;</span><br><span class="line">      <span class="comment">// std::cout &lt;&lt; e.x &lt;&lt; &quot; &quot; &lt;&lt; e.y &lt;&lt; std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  E.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  for (int i = 1; i &lt;= id; ++i)</span></span><br><span class="line"><span class="comment">    cerr &lt;&lt; tag[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">  cerr &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= id; ++i)</span><br><span class="line">    <span class="keyword">if</span> (tag[i]) tag[i] = ++num;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cerr &lt;&lt; num &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  MST ret; ret.sum = a.sum + b.sum;</span><br><span class="line">  ret.sum += sum;</span><br><span class="line">  ret.E = E, ret.id = num;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  E.clear();</span></span><br><span class="line"><span class="comment">  for (int i = 1; i &lt;= etot; i += 2)</span></span><br><span class="line"><span class="comment">    E.push_back(&#123; G[i].to, G[i + 1].to, G[i].w &#125;);</span></span><br><span class="line"><span class="comment">  MST ret; ret.sum = 0;</span></span><br><span class="line"><span class="comment">  ret.E = E, ret.id = id;</span></span><br><span class="line"><span class="comment">  return ret;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; SA &gt;&gt; SB &gt;&gt; SC &gt;&gt; lim;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">      ri[j][i] = <span class="built_in">get_weight</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">      dn[j][i] = <span class="built_in">get_weight</span>();</span><br><span class="line"></span><br><span class="line">  pre[<span class="number">1</span>] = <span class="built_in">MST</span>(dn[<span class="number">1</span>]);</span><br><span class="line">  suf[m] = <span class="built_in">MST</span>(dn[m]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    pre[i] = <span class="built_in">merge</span>(pre[i - <span class="number">1</span>], <span class="built_in">MST</span>(dn[i]), ri[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if (i == 3)</span></span><br><span class="line"><span class="comment">      exit(0);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt; <span class="number">1</span>; --i)</span><br><span class="line">    suf[i] = <span class="built_in">merge</span>(<span class="built_in">MST</span>(dn[i]), suf[i + <span class="number">1</span>], ri[i]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  std::cin &gt;&gt; q;</span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    <span class="keyword">int</span> l, r; std::cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="number">1</span> &amp;&amp; r == m)</span><br><span class="line">      ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l == <span class="number">1</span>)</span><br><span class="line">      ans = suf[r + <span class="number">1</span>].<span class="built_in">calc</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r == m)</span><br><span class="line">      ans = pre[l - <span class="number">1</span>].<span class="built_in">calc</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ans = <span class="built_in">merge</span>(suf[r + <span class="number">1</span>], pre[l - <span class="number">1</span>], ri[m]).<span class="built_in">calc</span>();</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>IOI2018狼人 Kruskal重构树主席树</title>
    <url>/2019/10/21/ioi2018%E7%8B%BC%E4%BA%BA-kruskal%E9%87%8D%E6%9E%84%E6%A0%91%E4%B8%BB%E5%B8%AD%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://loj.ac/problem/2865">[IOI2018]狼人</a> Kruskal重构树是对边玩的，不过也可以对点玩，不新建点就行了。 建立两棵Kruskal重构树，那么可以求出从$s,e$出发，分别可以到达的所有$&gt; L, &lt; R$的点。 在重构树上标号，发现是连续序列，可以看作二维数点，主席树随便维护。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;werewolf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Kruskal_Rebuild_Tree</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> type, fa[N][<span class="number">21</span>], ufs[N], dfn[N], size[N], num;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;<span class="keyword">int</span>&gt; T[N];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == ufs[x] ? x : ufs[x] = <span class="built_in">find</span>(ufs[x]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = ++num;</span><br><span class="line">    size[x] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; ++i)</span><br><span class="line">      fa[x][i] = fa[fa[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : T[x]) &#123;</span><br><span class="line">      <span class="built_in">dfs</span>(y);</span><br><span class="line">      size[x] += size[y];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; ~i; --i)</span><br><span class="line">      <span class="keyword">if</span> (fa[x][i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (fa[x][i] &gt;= k)</span><br><span class="line">            x = fa[x][i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (fa[x][i] &lt;= k)</span><br><span class="line">            x = fa[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      ufs[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> x = n; x; --x)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y : G[x])</span><br><span class="line">          <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">            <span class="keyword">int</span> _x = <span class="built_in">find</span>(x), _y = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_x == _y)</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            T[_x].<span class="built_in">push_back</span>(_y);</span><br><span class="line">            fa[_y][<span class="number">0</span>] = ufs[_y] = _x;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y : G[x])</span><br><span class="line">          <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">            <span class="keyword">int</span> _x = <span class="built_in">find</span>(x), _y = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_x == _y)</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            T[_x].<span class="built_in">push_back</span>(_y);</span><br><span class="line">            fa[_y][<span class="number">0</span>] = ufs[_y] = _x;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">dfs</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; A, B;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> ls, rs, size;</span><br><span class="line">&#125; tree[N * <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> &amp;now, <span class="keyword">int</span> pre, <span class="keyword">int</span> x, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  tree[now = ++tot] = tree[pre];</span><br><span class="line">  ++tree[now].size;</span><br><span class="line">  <span class="keyword">if</span> (L == R)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">    <span class="built_in">change</span>(tree[now].ls, tree[pre].ls, x, L, mid);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">change</span>(tree[now].rs, tree[pre].rs, x, mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R)</span><br><span class="line">    <span class="keyword">return</span> tree[y].size - tree[x].size;</span><br><span class="line">  <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">    ret += <span class="built_in">query</span>(tree[x].ls, tree[y].ls, l, r, L, mid);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">    ret += <span class="built_in">query</span>(tree[x].rs, tree[y].rs, l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id[N];</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">check_validity</span><span class="params">(<span class="keyword">int</span> N, std::vector&lt;<span class="keyword">int</span>&gt; X, std::vector&lt;<span class="keyword">int</span>&gt; Y,</span></span></span><br><span class="line"><span class="params"><span class="function">                                std::vector&lt;<span class="keyword">int</span>&gt; S, std::vector&lt;<span class="keyword">int</span>&gt; E,</span></span></span><br><span class="line"><span class="params"><span class="function">                                std::vector&lt;<span class="keyword">int</span>&gt; L, std::vector&lt;<span class="keyword">int</span>&gt; R)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n = N;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; X.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = X[i] + <span class="number">1</span>, y = Y[i] + <span class="number">1</span>;</span><br><span class="line">    G[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    G[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  A.type = <span class="number">1</span>, A.<span class="built_in">build</span>();</span><br><span class="line">  B.type = <span class="number">-1</span>, B.<span class="built_in">build</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    id[A.dfn[i]] = B.dfn[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">change</span>(root[i], root[i - <span class="number">1</span>], id[i], <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">  std::vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> s = S[i] + <span class="number">1</span>, e = E[i] + <span class="number">1</span>, l = L[i] + <span class="number">1</span>, r = R[i] + <span class="number">1</span>,</span><br><span class="line">      x = A.<span class="built_in">get</span>(s, l), y = B.<span class="built_in">get</span>(e, r);</span><br><span class="line"></span><br><span class="line">    ans.<span class="built_in">push_back</span>((<span class="keyword">bool</span>)(<span class="built_in">query</span>(root[A.dfn[x] - <span class="number">1</span>], root[A.dfn[x] + A.size[x] - <span class="number">1</span>],</span><br><span class="line">      B.dfn[y], B.dfn[y] + B.size[y] - <span class="number">1</span>, <span class="number">1</span>, n)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SHOI2012 信用卡凸包 计算几何凸包</title>
    <url>/2019/08/07/shoi2012-%E4%BF%A1%E7%94%A8%E5%8D%A1%E5%87%B8%E5%8C%85-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%87%B8%E5%8C%85/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P3829">[SHOI2012] 信用卡凸包</a> 一个性质：最终的凸包圆角部分长度，就是一个圆。 证明：把圆角两侧的边延长，交于一点。整个凸包构成一个凸多边形。由于圆弧交界处可以看做直线是圆弧的切线，所以过圆心向这里作垂线，一定垂直。 这样，令多边形角为$x$，圆心角为$y$，$x_i+y_i=\pi, \sum x_i=(n-2)\pi,\sum y_i=2\pi$ 把信用卡的直边向内平移$r$，得到的新矩形求凸包，加上圆就是答案。 向量的旋转： $$(x,y) \to (\cos\alpha x-\sin\alpha y,\sin\alpha x+\cos\alpha y)$$ 旋转矩阵： $$ \begin{bmatrix} \cos\theta &amp; -\sin\theta \ \sin\theta &amp; \cos\theta \end{bmatrix} $$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50000</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt, stk[N], top;</span><br><span class="line"><span class="keyword">double</span> A, B, R, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">fabs</span>(x - y) &lt; eps ? <span class="number">0</span> : x &lt; y ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">double</span> _x, <span class="keyword">double</span> _y) &#123;</span><br><span class="line">        x = _x, y = _y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a, <span class="keyword">const</span> Point &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">dcmp</span>(a.x, b.x) ? a.y &lt; b.y : a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;a, <span class="keyword">const</span> Point &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Point</span>(a.x + b.x, a.y + b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point &amp;a, <span class="keyword">const</span> Point &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Point</span>(a.x - b.x, a.y - b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> <span class="keyword">operator</span>^(<span class="keyword">const</span> Point &amp;a, <span class="keyword">const</span> Point &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lf%lf%lf&quot;</span>, &amp;n, &amp;A, &amp;B, &amp;R);</span><br><span class="line">    A = (A - R * <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    B = (B - R * <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">double</span> x, y, t, sin, cos;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf&quot;</span>, &amp;x, &amp;y, &amp;t);</span><br><span class="line">        sin = std::<span class="built_in">sin</span>(t), cos = std::<span class="built_in">cos</span>(t);</span><br><span class="line">        p[++cnt] = <span class="built_in">Point</span>(cos * B - sin * A, sin * B + cos * A) + <span class="built_in">Point</span>(x, y);</span><br><span class="line">        p[++cnt] = <span class="built_in">Point</span>(cos * -B - sin * A, sin * -B + cos * A) + <span class="built_in">Point</span>(x, y);</span><br><span class="line">        p[++cnt] = <span class="built_in">Point</span>(cos * B - sin * -A, sin * B + cos * -A) + <span class="built_in">Point</span>(x, y);</span><br><span class="line">        p[++cnt] = <span class="built_in">Point</span>(cos * -B - sin * -A, sin * -B + cos * -A) + <span class="built_in">Point</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(p + <span class="number">1</span>, p + cnt + <span class="number">1</span>);</span><br><span class="line">    stk[top = <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">dcmp</span>((p[stk[top]] - p[stk[top - <span class="number">1</span>]]) ^ (p[i] - p[stk[top]])) != <span class="number">1</span>)</span><br><span class="line">            --top;</span><br><span class="line">        stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= top; ++i) &#123;</span><br><span class="line">        ans += std::<span class="built_in">sqrt</span>(std::<span class="built_in">pow</span>(p[stk[i]].x - p[stk[i - <span class="number">1</span>]].x, <span class="number">2</span>)</span><br><span class="line">            + std::<span class="built_in">pow</span>(p[stk[i]].y - p[stk[i - <span class="number">1</span>]].y, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    stk[top = <span class="number">1</span>] = cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt - <span class="number">1</span>; i; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">dcmp</span>((p[stk[top]] - p[stk[top - <span class="number">1</span>]]) ^ (p[i] - p[stk[top]])) != <span class="number">1</span>)</span><br><span class="line">            --top;</span><br><span class="line">        stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= top; ++i) &#123;</span><br><span class="line">        ans += std::<span class="built_in">sqrt</span>(std::<span class="built_in">pow</span>(p[stk[i]].x - p[stk[i - <span class="number">1</span>]].x, <span class="number">2</span>)</span><br><span class="line">            + std::<span class="built_in">pow</span>(p[stk[i]].y - p[stk[i - <span class="number">1</span>]].y, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, ans + std::<span class="built_in">acos</span>(<span class="number">-1</span>) * R * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>ShangHai2006 Homework</title>
    <url>/2019/02/08/shanghai2006-homework/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4320">ShangHai2006 Homework</a> 这题有意思啊。。。网上题解都很含糊，自己写一个。。。 题意：插入一个数，或给定y求模y最小值。先不考虑原因，给出以下解法： 题目给定了最大的x y值，记为N，令T = sqrt(N)。对于y &lt;= T，暴力维护，即插入一个数后更新模1~T的值。若y &gt; T，枚举y 2y 3y…，进行查询。查询时，对于ky，如可以快速求出一个存在的值z，使得z &gt;= ky，并且最接近ky。枚举ky后，min{z % ky}即为答案。 考虑使用并查集维护z。并查集fa[x]表示&gt;=x且最接近的数。离线操作，预处理出全部插入后的fa[x]。倒序将题目中的插入改为删除，删除值w时，只需要fa[find(w)] = fa[find(w + 1)]，即可将原来指向w的数指向下一个位置。 下面证明复杂度，推导分成sqrt(N)块的原因： 易知暴力操作复杂度为O(sqrt(N))。由于T * T = N，每次y &gt; T的查询ky次数为O(sqrt(N))。修改使用了路径压缩的并查集，复杂度O(log(N))。综上，若有M次操作，总复杂度为O(Msqrt(N))，十分优秀。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300000</span> + <span class="number">23333</span>, T = <span class="number">600</span>;</span><br><span class="line"><span class="keyword">int</span> n, ans[N], bf[N], fa[N];</span><br><span class="line">pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; p[i].first &gt;&gt; p[i].second;</span><br><span class="line">        <span class="keyword">if</span> (p[i].first == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">            fa[p[i].second] = p[i].second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是暴力</span></span><br><span class="line">    <span class="built_in">memset</span>(bf, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(bf));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i].first == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= T; ++j)</span><br><span class="line">                bf[j] = <span class="built_in">min</span>(bf[j], p[i].second % j);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p[i].second &lt;= T)</span><br><span class="line">            ans[i] = bf[p[i].second];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>, lst = <span class="number">0</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[i] == i) lst = i;</span><br><span class="line">        <span class="keyword">else</span> fa[i] = lst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i].first == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">            fa[<span class="built_in">find</span>(p[i].second)] = fa[<span class="built_in">find</span>(p[i].second + <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p[i].second &gt; T) &#123;</span><br><span class="line">            ans[i] = <span class="built_in">find</span>(<span class="number">1</span>) % p[i].second;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = p[i].second; j &lt; N; j += p[i].second)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">find</span>(j))</span><br><span class="line">                    ans[i] = <span class="built_in">min</span>(ans[i], <span class="built_in">find</span>(j) % j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (p[i].first == <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">            cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SHOI2012随机树 期望DP</title>
    <url>/2019/09/04/shoi2012%E9%9A%8F%E6%9C%BA%E6%A0%91-%E6%9C%9F%E6%9C%9Bdp/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P3830">[SHOI2012]随机树</a> 智商不够，题解来凑。。。期望题不会中。。顺便给这个神仙题跪了 第一问，令$f_i$为$i$个叶子的期望。 $$f_i=\frac{(i-1)f_{i-1}-f_{i-1}+2(f_{i-1}+1)}{i}=f_{i-1}+\frac{2}{i}$$ 第二问很神仙。。 考虑期望是怎么算的 $$E(X)=\sum_{i=1}^{\infty}iP(i)=\sum_{i=1}^{\infty}\sum_{j=1}^iP(i)=\sum_{j=1}^{\infty}\sum_{i=j}^{\infty}P(i)$$ 令$f_i=\sum_{j=i}^{\infty}P(j)$，$E(X)=\sum_i f_i$ 用这种方法可以算树高的期望。令$f_{i,j}$为有$i$个叶子节点，树高为$j$的期望。 根据套路，应该枚举左右子树分别有多大来做。 如果左右子树的叶子数量和为$i-1$，硬点左子树有$k$个，现在计算$i-2$次操作后得到这样情况的方案数。 把$0$看作在左子树操作，$1$看作在右子树操作，操作方案数就是$01$的排列。有这么多种 $$\frac{(i-2)!}{(k-1)!(i-k-1)!}$$ 然后，考虑硬点一种序列，得到这个序列的概率 需要做乘法，每次分母都是总可以选择的点数，分子是自己操作的数量 $$\frac{(k-1)!(i-k-1)!}{(i-1)!}$$ 乘起来，发现最终概率是 $$\frac{1}{i-1}$$ 于是最终的式子是这个 $$f_{i,j}=\frac{1}{i-1}\sum_{k=1}^{i-1}f_{k,j-1}+f_{i-k,j-1}-f_{k,j-1}f_{i-k,j-1}$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q, n;</span><br><span class="line"><span class="keyword">double</span> f[<span class="number">233</span>][<span class="number">233</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;q, &amp;n);</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            ans += <span class="number">2.0</span> / i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; i; ++k)</span><br><span class="line">                    f[i][j] += (f[k][j - <span class="number">1</span>] + f[i - k][j - <span class="number">1</span>] - f[k][j - <span class="number">1</span>]</span><br><span class="line">                        * f[i - k][j - <span class="number">1</span>]) / (i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            ans += f[n][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SNOI2017一个简单的询问</title>
    <url>/2019/05/31/snoi2017%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%A2%E9%97%AE/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P5268">[SNOI2017]一个简单的询问</a> 维护一堆数字在区间出现多少次，只能莫队，然而题目询问四个端点没法做，需要推式子。 拆式子。$get(l,r,x)=get(1,r,x)-get(1,l-1,x)$。所以，原询问可以化简为 $$ans = \sum get(1,r1,x)get(1,r2,x) \newline - \sum get(1,r1,x)get(1,l2-1,x) \newline - \sum get(1,l1-1,x)get(1,r2,x) \newline + \sum get(1,l1-1,x)get(1,l2-1,x)$$ 这四个$\sum$都可以用莫队做。具体来说，我们维护的是$[1,l],[1,r]$的值，然后乘起来做答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50000</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, t, id;</span><br><span class="line">    <span class="built_in">Node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _l, <span class="keyword">int</span> _r, <span class="keyword">int</span> <span class="keyword">_t</span>, <span class="keyword">int</span> _id) &#123;</span><br><span class="line">        l = _l; r = _r;</span><br><span class="line">        t = <span class="keyword">_t</span>; id = _id;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">            <span class="built_in">swap</span>(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; q[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, block, pos[N], a[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL sum, ans[N], cntl[N], cntr[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;x, <span class="keyword">const</span> Node &amp;y) &#123;</span><br><span class="line">    <span class="keyword">return</span> pos[x.l] == pos[y.l]</span><br><span class="line">        ? pos[x.l] &amp; <span class="number">1</span></span><br><span class="line">            ? x.r &lt; y.r</span><br><span class="line">            : x.r &gt; y.r</span><br><span class="line">        : pos[x.l] &lt; pos[y.l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addl</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ++cntl[x];</span><br><span class="line">    sum += cntr[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addr</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ++cntr[x];</span><br><span class="line">    sum += cntl[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dell</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    --cntl[x];</span><br><span class="line">    sum -= cntr[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delr</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    --cntr[x];</span><br><span class="line">    sum -= cntl[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(); block = <span class="built_in">sqrt</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        pos[i] = (i - <span class="number">1</span>) / block + <span class="number">1</span>;</span><br><span class="line">        a[i] = <span class="built_in">rd</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = <span class="built_in">rd</span>(), r1 = <span class="built_in">rd</span>(), l2 = <span class="built_in">rd</span>(), r2 = <span class="built_in">rd</span>();</span><br><span class="line">        q[++tot] = <span class="built_in">Node</span>(r1, r2, <span class="number">1</span>, i);</span><br><span class="line">        q[++tot] = <span class="built_in">Node</span>(r1, l2 - <span class="number">1</span>, <span class="number">-1</span>, i);</span><br><span class="line">        q[++tot] = <span class="built_in">Node</span>(l1 - <span class="number">1</span>, r2, <span class="number">-1</span>, i);</span><br><span class="line">        q[++tot] = <span class="built_in">Node</span>(l1 - <span class="number">1</span>, l2 - <span class="number">1</span>, <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + tot + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l = <span class="number">0</span>, r = <span class="number">0</span>; i &lt;= tot; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) <span class="built_in">addl</span>(a[++l]);</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) <span class="built_in">dell</span>(a[l--]);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) <span class="built_in">addr</span>(a[++r]);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) <span class="built_in">delr</span>(a[r--]);</span><br><span class="line">        ans[q[i].id] += q[i].t * sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> kai586123::<span class="built_in">main</span>(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SPOJ348 EXPEDI - Expedition</title>
    <url>/2019/01/30/spoj348-expedi-expedition/</url>
    <content><![CDATA[<p><a href="https://www.spoj.com/problems/EXPEDI/">EXPEDI - Expedition</a> 堆的脑洞题，挑战程序设计竞赛上有。 把走过去的加油站放进一个堆里，当没油的时候从堆里拿出来一个最大的值加上就行了。 orzorzorz</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">233</span>, INF = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Gas_Station</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> dis, gas;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Gas_Station &amp;station) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dis &lt; station.dis;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="built_in">rd</span>();</span><br><span class="line">            priority_queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">            Gas_Station station[MAXN];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">                station[i].dis = <span class="built_in">rd</span>(), station[i].gas = <span class="built_in">rd</span>();</span><br><span class="line">            <span class="keyword">int</span> l = <span class="built_in">rd</span>(), p = <span class="built_in">rd</span>(), cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">                station[i].dis = l - station[i].dis;</span><br><span class="line">            <span class="built_in">sort</span>(station + <span class="number">1</span>, station + n + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt; l; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt;= station[j].dis)</span><br><span class="line">                        que.<span class="built_in">push</span>(station[j++].gas);</span><br><span class="line">                    <span class="keyword">if</span> (--p == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (que.<span class="built_in">empty</span>())</span><br><span class="line">                            <span class="keyword">throw</span> <span class="number">-1</span>;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            ++cnt;</span><br><span class="line">                            p += que.<span class="built_in">top</span>();</span><br><span class="line">                            que.<span class="built_in">pop</span>();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">                cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SHOI2014概率充电器 期望DP树形DP</title>
    <url>/2019/09/03/shoi2014%E6%A6%82%E7%8E%87%E5%85%85%E7%94%B5%E5%99%A8-%E6%9C%9F%E6%9C%9B%E6%A0%91%E5%BD%A2dp/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P4284">[SHOI2014]概率充电器</a> $$E=\sum_{x \in tree}E(x)=\sum_{x \in tree}P(x)$$ 于是要求的就是每个点通电的概率和。 令$a,b$为两个事件的概率，那么它们至少发生一件的概率为 $$a+b-ab$$ 令$f_x$为$x$的概率。初值为这个点的概率。 首先钦定一个点做根，求出它的概率。 $$a=f_x,b=f_yp(x,y)$$ $$f_x=a+b-ab$$ 然后，换根DP求出每个点的概率。分析可以发现，求儿子的概率需要父亲不考虑儿子这个子树的概率。 于是，尝试解出来原来的$a$。 $$a=\frac{f_x-b}{1-b}$$ 再搞个$c,d$ $$c=f_y,d=ap(x,y)$$ $$f_y=c+d-cd$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500000</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> f[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">    <span class="keyword">double</span> per;</span><br><span class="line">&#125; g[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">double</span> p)</span> </span>&#123;</span><br><span class="line">    g[++tot].to = y, g[tot].nxt = head[x],</span><br><span class="line">    g[tot].per = p, head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="keyword">if</span> (y == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y, x);</span><br><span class="line">        <span class="keyword">double</span> a = f[x], b = f[y] * g[i].per;</span><br><span class="line">        f[x] = a + b - a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    ans += f[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="keyword">if</span> (y == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (f[y] != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> b = f[y] * g[i].per, a = (f[x] - b) / (<span class="number">1</span> - b),</span><br><span class="line">                c = f[y], d = a * g[i].per;</span><br><span class="line">            f[y] = c + d - c * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs2</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>(), p = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">addedge</span>(x, y, p / <span class="number">100.0</span>);</span><br><span class="line">        <span class="built_in">addedge</span>(y, x, p / <span class="number">100.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        f[i] = <span class="built_in">rd</span>() / <span class="number">100.0</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SUBLEX - Lexicographical Substring Search</title>
    <url>/2019/06/17/sublex-lexicographical-substring-search/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/SP7258">SUBLEX - Lexicographical Substring Search</a> 求k大子串。SAM上DP求出每个点可以到达的子串个数。$f[x]=\sum f[y] + size[x]$。除了root之外的点，$size$都是1。 然后用类似平衡树的方法找就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">90000</span> * <span class="number">2</span> + <span class="number">2333</span>;</span><br><span class="line"><span class="keyword">int</span> last = <span class="number">1</span>, tot = <span class="number">1</span>, fa[N], len[N], ch[N][<span class="number">26</span>], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = last, np = ++tot;</span><br><span class="line">    last = np; len[np] = len[p] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; !ch[p][c])</span><br><span class="line">        ch[p][c] = np, p = fa[p];</span><br><span class="line">    <span class="keyword">if</span> (!p) fa[np] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> q = ch[p][c];</span><br><span class="line">        <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)</span><br><span class="line">            fa[np] = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> nq = ++tot;</span><br><span class="line">            len[nq] = len[p] + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="built_in"><span class="keyword">sizeof</span></span>(ch[q]));</span><br><span class="line">            fa[nq] = fa[q];</span><br><span class="line">            fa[q] = fa[np] = nq;</span><br><span class="line">            <span class="keyword">while</span> (p &amp;&amp; ch[p][c] == q)</span><br><span class="line">                ch[p][c] = nq, p = fa[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch[now][i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[ch[now][i]] &lt; k)</span><br><span class="line">                    k -= f[ch[now][i]];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">putchar</span>(i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (--k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">                    now = ch[now][i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> a[N], c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>); <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">insert</span>(s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) ++c[len[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tot; i &gt;= <span class="number">1</span>; --i) a[c[len[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tot; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        f[a[i]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)</span><br><span class="line">            <span class="keyword">if</span> (ch[a[i]][j])</span><br><span class="line">                f[a[i]] += f[ch[a[i]][j]];</span><br><span class="line">    &#125;</span><br><span class="line">    --f[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> k; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">        <span class="built_in">solve</span>(k); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SubString</title>
    <url>/2019/06/19/substring/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P5212">SubString</a> CLJ课件里钦定的题，做法很简单：出现次数就是SAM上parent树的子树和。动态维护parent树，使用LCT。每次插入新点的时候，把这个点到根全+1。 然后代码调好久… 一些奇怪的代码注意点： 本题维护的是有根，有向的树，而且link和cut操作保证合法，所以不需要makeroot。 因为是区间+1，要打LazyTag。 回答询问之前，先preview一下，从根pushdown到这个点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6e5</span> * <span class="number">2</span> + <span class="number">23333</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> LCT &#123;</span><br><span class="line">    <span class="keyword">int</span> fa[N], ch[N][<span class="number">2</span>], val[N], add[N], st[N], top;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>] != x &amp;&amp; ch[fa[x]][<span class="number">1</span>] != x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushadd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        val[x] += v;</span><br><span class="line">        add[x] += v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (add[x]) &#123;</span><br><span class="line">            <span class="built_in">pushadd</span>(ch[x][<span class="number">0</span>], add[x]);</span><br><span class="line">            <span class="built_in">pushadd</span>(ch[x][<span class="number">1</span>], add[x]);</span><br><span class="line">            add[x] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y = fa[x], z = fa[y], k = ch[y][<span class="number">1</span>] == x;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isroot</span>(y)) ch[z][ch[z][<span class="number">1</span>] == y] = x;</span><br><span class="line">        fa[x] = z; ch[y][k] = ch[x][k ^ <span class="number">1</span>];</span><br><span class="line">        fa[ch[x][k ^ <span class="number">1</span>]] = y; ch[x][k ^ <span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preview</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        st[top = <span class="number">1</span>] = x;</span><br><span class="line">        <span class="keyword">for</span> ( ; !<span class="built_in">isroot</span>(x); x = fa[x])</span><br><span class="line">            st[++top] = fa[x];</span><br><span class="line">        <span class="keyword">while</span> (top) <span class="built_in">pushdown</span>(st[top--]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">preview</span>(x);</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isroot</span>(x)) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = fa[x], z = fa[y];</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isroot</span>(y))</span><br><span class="line">                <span class="built_in">rotate</span>((ch[z][<span class="number">1</span>] == y) &amp;&amp; (ch[y][<span class="number">1</span>] == x) ? x : y);</span><br><span class="line">            <span class="built_in">rotate</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; x; x = fa[y = x])</span><br><span class="line">            <span class="built_in">splay</span>(x), ch[x][<span class="number">1</span>] = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        fa[x] = y; <span class="built_in">access</span>(y);</span><br><span class="line">        <span class="built_in">splay</span>(y); <span class="built_in">pushadd</span>(y, val[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">access</span>(x); <span class="built_in">splay</span>(x);</span><br><span class="line">        <span class="built_in">pushadd</span>(ch[x][<span class="number">0</span>], -val[x]);</span><br><span class="line">        fa[ch[x][<span class="number">0</span>]] = <span class="number">0</span>; ch[x][<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SAM &#123;</span><br><span class="line">    <span class="keyword">int</span> fa[N], ch[N][<span class="number">26</span>], tot = <span class="number">1</span>, last = <span class="number">1</span>, len[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = last, np = ++tot;</span><br><span class="line">        last = np; len[np] = len[p] + <span class="number">1</span>;</span><br><span class="line">        LCT::val[np] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !ch[p][c])</span><br><span class="line">            ch[p][c] = np, p = fa[p];</span><br><span class="line">        <span class="keyword">if</span> (!p) fa[np] = <span class="number">1</span>, LCT::<span class="built_in">link</span>(np, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> q = ch[p][c];</span><br><span class="line">            <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)</span><br><span class="line">                fa[np] = q, LCT::<span class="built_in">link</span>(np, q);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> nq = ++tot;</span><br><span class="line">                len[nq] = len[p] + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="built_in"><span class="keyword">sizeof</span></span>(ch[q]));</span><br><span class="line">                fa[nq] = fa[q];</span><br><span class="line">                LCT::<span class="built_in">link</span>(nq, fa[q]);</span><br><span class="line">                LCT::<span class="built_in">cut</span>(q);</span><br><span class="line">                LCT::<span class="built_in">link</span>(q, nq);</span><br><span class="line">                LCT::<span class="built_in">link</span>(np, nq);</span><br><span class="line">                fa[q] = fa[np] = nq;</span><br><span class="line">                <span class="keyword">while</span> (p &amp;&amp; ch[p][c] == q)</span><br><span class="line">                    ch[p][c] = nq, p = fa[p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = s[i] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ch[p][c]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> p = ch[p][c];</span><br><span class="line">        &#125;</span><br><span class="line">        LCT::<span class="built_in">preview</span>(p);</span><br><span class="line">        <span class="keyword">return</span> LCT::val[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[N]; <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decode</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        mask = (mask * <span class="number">131</span> + i) % n;</span><br><span class="line">        <span class="built_in">swap</span>(str[i], str[mask]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Q; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Q);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str); n = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    SAM::<span class="built_in">insert</span>(str[i] - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    <span class="keyword">char</span> opt[<span class="number">10</span>]; <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, opt, str);</span><br><span class="line">        n = <span class="built_in">strlen</span>(str); <span class="built_in">decode</span>(mask);</span><br><span class="line">        <span class="keyword">if</span> (*opt == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                SAM::<span class="built_in">insert</span>(str[i] - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = SAM::<span class="built_in">query</span>(str, n);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">            mask ^= ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>Substrings</title>
    <url>/2019/06/13/substrings/</url>
    <content><![CDATA[<p>求出现或反转后出现在每个字符串中的最长子串 <a href="http://poj.org/problem?id=1226">Substrings</a> 把正串反串接在一起，用不同符号隔开，二分，完事。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>, M = N * N * <span class="number">2</span>, S = <span class="number">2333</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, s[M], ap[M], ml; <span class="keyword">char</span> ch[N];</span><br><span class="line"><span class="keyword">int</span> x[M], y[M], c[M], sa[M], ht[M], rk[M];</span><br><span class="line"><span class="keyword">int</span> cnt[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ht[i] &lt; k) &#123;</span><br><span class="line">            tot = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                cnt[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = ap[sa[i]];</span><br><span class="line">        <span class="keyword">if</span> (x &amp;&amp; ++cnt[x] == <span class="number">1</span>) ++tot;</span><br><span class="line">        <span class="keyword">if</span> (tot == m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(s));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    ml = <span class="number">23333333</span>; n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ch + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(ch + <span class="number">1</span>);</span><br><span class="line">        ml = <span class="built_in">min</span>(ml, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len; ++j) &#123;</span><br><span class="line">            s[++n] = ch[j];</span><br><span class="line">            ap[n] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        s[++n] = i + <span class="number">233</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = len; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">            s[++n] = ch[j];</span><br><span class="line">            ap[n] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        s[++n] = i + <span class="number">666</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i] = s[i]];;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>, k = <span class="number">1</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>, p = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; ++i) y[++p] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt; k) y[++p] = sa[i] - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[y[i]]]--] = y[i];</span><br><span class="line">        <span class="built_in">swap</span>(x, y); x[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            x[sa[i]] = y[sa[i]] == y[sa[i - <span class="number">1</span>]]</span><br><span class="line">                &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]</span><br><span class="line">                ? p : ++p;</span><br><span class="line">        <span class="keyword">if</span> (p == n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>, p = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (p) --p;</span><br><span class="line">        <span class="keyword">while</span> (s[i + p] == s[j + p]) ++p;</span><br><span class="line">        ht[rk[i]] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = ml, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid + <span class="number">1</span>, ans = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SHOI2011 双倍回文</title>
    <url>/2019/07/31/shoi2011-%E5%8F%8C%E5%80%8D%E5%9B%9E%E6%96%87/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P4287">[SHOI2011] 双倍回文</a> 一个双倍回文串，由左，中，右三部分组成。当manacher跑到右边对称中心的时候，左和中肯定已经被求出来了。右边会先去继承左边的信息。此时如果存在一个双倍回文串，判断下更新答案就好了。 细节上：因为对称中心都是加进去的字符，所以只计算它们才是对的，每次i+=2。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">char</span> xx[N];</span><br><span class="line"><span class="keyword">int</span> nn, n = <span class="number">1</span>, ans, p[N], str[N] = &#123; <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;#&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;nn, xx);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nn; ++i)</span><br><span class="line">        str[++n] = xx[i], str[++n] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, mid = <span class="number">0</span>, r = <span class="number">0</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        p[i] = i &lt; r ? std::<span class="built_in">min</span>(r - i, p[mid * <span class="number">2</span> - i]) : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; r &amp;&amp; i - p[i] &lt; mid)</span><br><span class="line">            ans = std::<span class="built_in">max</span>(ans, (i - mid) * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">while</span> (str[i - p[i]] == str[i + p[i]])</span><br><span class="line">            ++p[i];</span><br><span class="line">        <span class="keyword">if</span> (p[i] + i &gt; r)</span><br><span class="line">            r = p[i] + i, mid = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="桥头马得！"><a href="#桥头马得！" class="headerlink" title="桥头马得！"></a>桥头马得！</h2><p>然而，用mid来找出对称的另一半在哪，是不是不太科学呢？来看一张图： <img src="https://baka.online/wp-content/uploads/2019/07/w%E6%97%A0%E6%A0%87%E9%A2%98.png"> 会不会出现，我们想要的双回文串是黑色的1，然而有一个回文串2，使得mid被更新了呢？ 答案是：不会。因为如果有了2，就会有3，然后整个4就是个大回文串。那么在跑到1的中点时，跑出来的就是4，也就没了这种情况。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SXOI2019十二省联考摸鱼记</title>
    <url>/2019/04/05/sxoi2019%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%83%E6%91%B8%E9%B1%BC%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="Day-1："><a href="#Day-1：" class="headerlink" title="Day -1："></a>Day -1：</h3><p>听说因为去年noip划水划的分够了，我是正式选手，不过反正省选也是划水的都一样= =…算了下按照总成绩算法，我只需要比学长们高130分就能进队了，吓尿。 然后听说学校要清明假期最后一天上午全校去自习，加上下午周考，三天-&gt;两天，而且怕是以后也得周日去自习了…虽然这次可以不去，但是还是郁闷啊。 学校门口拉了个红色的横幅，个人感觉去年五中那个板子好看不少。然后横幅上“选拔赛”写成了“选拨赛”，估计会改2333333333333333。</p>
<h3 id="Day-0："><a href="#Day-0：" class="headerlink" title="Day 0："></a>Day 0：</h3><p>早晨去的时候已经改成选拔了。上午卓越楼封了，扒门进去上了一波课。下午试机，感觉还行，敲了个测试c++11的程序就跑了。 睡了一觉晚上才开电脑，去洛谷搜板子看板子。然而发现都不会。。。。。。复习了一下主席树左偏树网络流之类的板子。数学的都跳了，SA和SAM也没看，因为太丢人，就算构造出来也不会用。。。Splay就没一次打对过，也不看了。。。感觉说不定会考计算几何，也看了下（&lt;-错觉）。于是放弃之，随缘吧。看了下前几年的题，也没什么会的。DP估计做不上来，数学题放弃，网络流估计建不出图，只能打暴力了，暴力打满应该有几十分。</p>
<h3 id="Day1："><a href="#Day1：" class="headerlink" title="Day1："></a>Day1：</h3><p>先看题，T1不可做，T2太长不看，T3？？？？？？？偷偷扫了一眼周围的大佬们也都问号脸。 然后先肝T3，发现前几个点是19的次方，写了个快速幂，然后发现有爆long long的，又写了个高精度，12分。后面的不知道模数之类的放弃了。然后看任务2，gedit打开直接电脑崩溃重启，用vim打开，发现全是点点看不懂，就溜了。 然后肝T1，不会做，打了个暴力+排序，60分，五分钟跑路。 T2完全是不可做的样子，读题读到崩溃。好不容易看完题，开始手画样例，还是懵逼。不过后来尝试把支配关系和前缀关系都用边表示，发现可以判换+求最长路。 前缀什么的用SAM求会很爽，可是没复习。。。（丢人）只好建个Trie，暴力插进去B，然后在上面跑A求前缀。预期得分二三十这样子。检查检查就摸鱼了。考完听说T1是可持久化01Trie，瞬间脑补出算法。。。然而没写过，考场上也根本想不到，还是too young too simple。 刚吃完饭就测出来了，T2惊喜10分……SXRANK12，要是这题没写出问题就是个位数了（捂脸）…下午去看代码发现写出不少小bug，真的丢人。。。讲题去的晚没听到T1。T2讲了不少算法，其实都是优化版的我的菜鸡算法这样子。T3真的，无力吐槽，不知道这题怎么被选上的OAO。</p>
<h3 id="Day-2："><a href="#Day-2：" class="headerlink" title="Day 2："></a>Day 2：</h3><p>昨天晚上在群里猜题，我猜的一个DP一个网络流一个数学。拿到题，发现并没有网络流和数学题。。。个人数数功力负分，GG。 T1题太复杂不可做，T3明显不可做，先看T2，画图分析了一下，发现贪心是对的，问题是优化复杂度。直接打暴力了。排序之后n方枚举，再树剖和已经选的点求LCA判断是不是在一条链上，O(n^3logn)，用链表优化了一下，把选中的点跳过，就去看别的题了。 T3手画样例都困难，骗分可能性微存，思考了很久还是不会，数据里有L=n，k=1的两个点，就是求一下子树个数，对着下手了。然后优化了一下求法，骗8分。 T1也是思考很久根本不会…第一个点好写，特判了，然后写了个大搜索，过了样例就到点了。 下午敲掉周考去听题解，T1是…背包？？？T2居然是图巨出的，树上合并，TKJ写了个退火居然也有分。T3是个树形DP，然而过于强大没听懂…std900行丧心病狂（虽然去掉里面奇怪的东西只有300）。其实Day2的题质量还行。 出分，Day1的数据出锅了，改好之后多了10分，六道题最后60+20+12+10+60+12=174。T3大约数据弱，写的8分居然有12分。虽然是附中高一最高，但是被五中高一巨佬hzj爆踩OAO。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>第一次来省选，其实也算骗了一些分。但是写挂两道题，D1T2，D2T1。D1T2如果没写挂是40分，D2T1如果没写挂是20分。D1T3也骗少了，不过这题不评价。 总结点小东西：1. 智商不够，暴力来凑 2. 善用Python 3. 熟练度很重要 4. 思考时间太久大概率是想不出来了 日常挂在写代码上，还是太弱了，也没什么好说的，继续努力吧，希望明年还能再来摸一次鱼。</p>
<hr>
<p>附图一张： <img src="https://baka.online/wp-content/uploads/2019/04/TIM%E5%9B%BE%E7%89%8720190407191711.jpg"></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>ThinkPad X1 Carbon使用Linux踩坑记</title>
    <url>/2019/08/22/thinkpad-x1-carbon-linux%E8%B8%A9%E5%9D%91%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="如果你通过搜索引擎搜到了这篇文章："><a href="#如果你通过搜索引擎搜到了这篇文章：" class="headerlink" title="如果你通过搜索引擎搜到了这篇文章："></a>如果你通过搜索引擎搜到了这篇文章：</h3><p>博主是OIer，如果你不知道是什么也不重要。这篇博客是记录自己在笔记本上用Linux遇到的一些问题，不一定正确，也不一定具有普适性。</p>
<hr>
<p>我的笔记本是ThinkPad X1 Carbon Gen 6，安装的是Manjaro。</p>
<h3 id="桌面"><a href="#桌面" class="headerlink" title="桌面"></a>桌面</h3><p>嗯。。。这个电脑的分辨率是2560 x 1440。这导致了在不对内容进行缩放的时候无法使用，字基本只有0.1mm的样子。。 经过大力测试，发现只有Deepin的桌面（DDE）表现良好。 XFCE,KDE,Cinnamon支持上就挂了，gnome在下面有说。其它的DE就不用提了。。 仿mac的风格略丑，但是只要在设置里关掉窗口特效就可以了。 Update 19.12.12：转XFCE很久了，来更新一下，实际上XFCE也很好用的说…具体来讲就是只把字体调大就行了… 有一点小但是不影响使用，体验真的很棒，TIM字体放大也能work</p>
<h3 id="鼠标"><a href="#鼠标" class="headerlink" title="鼠标"></a>鼠标</h3><p>之前的微软蓝牙鼠标并不能工作，现在换了ThinkPad配套的蓝牙鼠标，工作良好。</p>
<h3 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -S wqy-microhei</span><br></pre></td></tr></table></figure>

<h3 id="显卡驱动挂掉"><a href="#显卡驱动挂掉" class="headerlink" title="显卡驱动挂掉"></a>显卡驱动挂掉</h3><p>不要乱装。。装系统的时候有的就够了</p>
<h3 id="梯子"><a href="#梯子" class="headerlink" title="梯子"></a>梯子</h3><p>我用的是v2ray。 archlinuxcn里有，直接装就可以了。配置文件拖进去就好。 位置在这里：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/etc/v2ray</span><br></pre></td></tr></table></figure>

<p>然后记得重启一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable v2ray</span><br><span class="line">sudo systemctl restart v2ray</span><br></pre></td></tr></table></figure>

<p>对于浏览器，使用switchyomega插件。然而第一次打开的时候没有代理，这样跑：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">google-chrome-stable --proxy-server=<span class="string">&quot;socks5://127.0.0.1:1080&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="QQ"><a href="#QQ" class="headerlink" title="QQ"></a>QQ</h3><p>没想到现在已经搞得这么好了。。archlinuxcn里也有。 顺便DDE吊打其他DE的一点就在于，TIM在DDE下面是支持和设置的一起缩放的。Gnome光荣阵亡了。。。 事实上会有一些显示上的问题，不影响使用。 多看archwiki有真相。</p>
<h3 id="网易云"><a href="#网易云" class="headerlink" title="网易云"></a>网易云</h3><p>里面的字并不能变大。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -S electron-netease-cloud-music</span><br></pre></td></tr></table></figure>

<p>不过这个用起来十分棒。</p>
<h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h3><p>糊了一个.vimrc，贴在这里。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">syntax on</span><br><span class="line">set showmode</span><br><span class="line">set showcmd</span><br><span class="line">set mouse=a</span><br><span class="line">set t_Co=<span class="number">256</span></span><br><span class="line">set smartindent</span><br><span class="line">set shiftwidth=<span class="number">2</span></span><br><span class="line">set tabstop=<span class="number">2</span></span><br><span class="line">set expandtab</span><br><span class="line">set softtabstop=<span class="number">2</span></span><br><span class="line">set number</span><br><span class="line">set showmatch</span><br><span class="line">set ignorecase</span><br><span class="line"></span><br><span class="line">map &lt;F5&gt; :call <span class="built_in">ComplieCode</span>()&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">func! <span class="built_in">ComplieCode</span>()</span><br><span class="line">    exec <span class="string">&#x27;w&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> &amp;filetype == <span class="string">&#x27;cpp&#x27;</span></span><br><span class="line">        exec <span class="string">&#x27;!g++ -fsanitize=address -ftrapv -Wall -Wextra -Wshadow -O2 -std=c++11 % -o %&lt; &amp;&amp; ./%&lt;&#x27;</span></span><br><span class="line">    elseif &amp;filetype == <span class="string">&#x27;python&#x27;</span></span><br><span class="line">        exec <span class="string">&#x27;python3 %&#x27;</span></span><br><span class="line">    endif</span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line">map &lt;F9&gt; :call <span class="built_in">OpenInGedit</span>()&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">func! <span class="built_in">OpenInGedit</span>()</span><br><span class="line">    exec <span class="string">&#x27;!gedit %&#x27;</span></span><br><span class="line">endfunc</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>Palindrome</title>
    <url>/2019/06/12/palindrome/</url>
    <content><![CDATA[<p>求一个字符串的最大回文子串。 <a href="https://vjudge.net/problem/URAL-1297">Palindrome</a> 有更强的manacher，不写了。思路就是把串反过来接在正的后面，然后枚举对称轴，问题变成了求两个串的LCP。如果不插字符，要分类讨论，很麻烦。 后缀数组求LCP，就是求min{height[i]}。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>TJOI2007可爱的质数</title>
    <url>/2019/04/18/tjoi2007%E5%8F%AF%E7%88%B1%E7%9A%84%E8%B4%A8%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3846">[TJOI2007]可爱的质数</a> BSGS算法板子题。Baby step giant step，即北上广深大步小步算法。 引理：欧拉定理的推论：若$gcd(a,p)=1$，则有$a^{i\mod \varphi(i) }\equiv a^i \pmod p$。 可以发现模意义下幂有循环节，我们只需要求出$a$的$0$到$\varphi(p)$次方就行了。 然后分块。令$M=\lceil \sqrt p \rceil$，$a^{im-j} \equiv b \pmod p$，得$a^{im} \equiv a^{j}b \pmod p$，用hash存一下$a^jb$，枚举$i$就行了。答案是$im-j$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fpow</span><span class="params">(ll x, ll y, ll p)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = x * x % p)</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = ans * x % p;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll a, b, p, m;</span><br><span class="line">    std::map&lt;ll, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;p, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">if</span> (a % p == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;no solution&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p));</span><br><span class="line">    mp[b % p] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        mp[<span class="function">b * <span class="title">fpow</span><span class="params">(a, i, p)</span> % p] </span>= i;</span><br><span class="line">    ll t = <span class="built_in">fpow</span>(a, m, p) % p, x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        x = x * t % p;</span><br><span class="line">        <span class="keyword">if</span> (mp[x]) &#123;</span><br><span class="line">            ll ans = i * m - mp[x];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (ans % p + p) % p);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;no solution&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>TJOI2019甲苯先生的字符串</title>
    <url>/2019/05/25/tjoi2019%E7%94%B2%E8%8B%AF%E5%85%88%E7%94%9F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p><a href="https://loj.ac/problem/3104">[TJOI2019]甲苯先生的字符串</a> 首先写个式子：$f[i][j]=\sum f[i-1][k]$，如果$kj$可以连在一起。预处理连接关系到$w$，之后改写这个式子：$f[i][j]=\sum f[i-1][k] * w[k][j]$。 这玩意可以矩阵乘法优化。初始$ans$矩阵为第一行全是$1$，快速幂乘$n-1$次$w$矩阵即得到了结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">2333</span>, MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>() &#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a)); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix &amp;x, <span class="keyword">const</span> Matrix &amp;y) &#123;</span><br><span class="line">    Matrix ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">26</span>; ++k)</span><br><span class="line">                ret.a[i][j] = (ret.a[i][j]</span><br><span class="line">                    + x.a[i][k] * y.a[k][j]) % MOD;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Matrix fp, g, ans, xx;</span><br><span class="line"><span class="keyword">int</span> n, len, sum; <span class="keyword">char</span> ch[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%s&quot;</span>, &amp;n, ch + <span class="number">1</span>);</span><br><span class="line">    len = <span class="built_in">strlen</span>(ch + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; ++j)</span><br><span class="line">            g.a[i][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; ++i)</span><br><span class="line">        ans.a[<span class="number">1</span>][i] = fp.a[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">        g.a[ch[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>][ch[i + <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (--n ; n; n &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) fp = fp * g;</span><br><span class="line">        g = g * g;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans = ans * fp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; ++i)</span><br><span class="line">        sum = (sum + ans.a[<span class="number">1</span>][i]) % MOD;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>TJOI2017DNA</title>
    <url>/2019/07/02/tjoi2017dna/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3763">[TJOI2017]DNA</a> 热动分析了一坨解法：</p>
<h4 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h4><p>SA，因为最多能失配三次嘛，就枚举起点，用SA求LCP，跳三次以内匹配完就算可以。 没代码。</p>
<h4 id="解法2："><a href="#解法2：" class="headerlink" title="解法2："></a>解法2：</h4><p>SAM，先算一下每个点的size，然后直接暴力dfs。记录一下失配边数，搜到3结束。 没代码。</p>
<h4 id="解法3："><a href="#解法3：" class="headerlink" title="解法3："></a>解法3：</h4><p>因为只有四个字母，枚举字母，把A串有的地方记为1，B串没有的地方记为1。两个串卷一下，1的个数就是本字母不一样的个数。跑的挺慢，NTT能勉强卡过去。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; = &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> * <span class="number">4</span> + <span class="number">2333</span>, P = <span class="number">998244353</span>, G = <span class="number">3</span>, Gi = <span class="number">332748118</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> sa[N], sb[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lim, L, rev[N];</span><br><span class="line">LL A[N], B[N], inv;</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">fpow</span><span class="params">(LL x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    LL ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = x * x % P)</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = ret * x % P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(LL f[], <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i])</span><br><span class="line">            std::<span class="built_in">swap</span>(f[i], f[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        LL T = <span class="built_in">fpow</span>(o == <span class="number">1</span> ? G : Gi, (P - <span class="number">1</span>) / (i &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += (i &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            LL w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k, w = w * T % P) &#123;</span><br><span class="line">                LL nx = f[j + k], ny = w * f[i + j + k] % P;</span><br><span class="line">                f[j + k] = (nx + ny) % P;</span><br><span class="line">                f[i + j + k] = (nx - ny + P) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lim = <span class="number">1</span>; L = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        A[i] = sa[i] == c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        B[i] = sb[i] != c;</span><br><span class="line">    <span class="built_in">NTT</span>(A, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NTT</span>(B, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        A[i] = A[i] * B[i] % P;</span><br><span class="line">    <span class="built_in">NTT</span>(A, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        A[i] = A[i] * inv % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        cnt[i] += A[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, sa, sb);</span><br><span class="line">    n = <span class="built_in">strlen</span>(sa); m = <span class="built_in">strlen</span>(sb);</span><br><span class="line">    std::<span class="built_in">reverse</span>(sb, sb + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lim &lt; n + m)</span><br><span class="line">        lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; ++i)</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>)  ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>));</span><br><span class="line">    inv = <span class="built_in">fpow</span>(lim, P - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">work</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    <span class="built_in">work</span>(<span class="string">&#x27;G&#x27;</span>);</span><br><span class="line">    <span class="built_in">work</span>(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    <span class="built_in">work</span>(<span class="string">&#x27;T&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        ans += cnt[i] &lt;= <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">init</span>(), <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>Triple FFT生成函数</title>
    <url>/2019/09/11/triple-fft%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3771">Triple</a> 萌新刚学OI，不是很懂数学。 令$A,B,C$分别为每个物品选一个，选两个，选三个的生成函数。 那么答案就是 $$ans=A+A^2+A^3$$ 才不是呢。。这样有一个物品选几次，和一种方案被多次表示的问题。 多次表示除以一个排列数就行了。考虑用容斥去掉一个物品选多次。 $$ans=A+\frac{A^2-B}{2}+\frac{A^3-3AB+2C}{6}$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">40000</span> * <span class="number">10</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = std::<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, max;</span><br><span class="line"><span class="keyword">int</span> lim = <span class="number">1</span>, L, rev[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125; A[N], B[N], C[N];</span><br><span class="line"></span><br><span class="line">complex <span class="keyword">operator</span>+(<span class="keyword">const</span> complex &amp;a, <span class="keyword">const</span> complex &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; a.x + b.x, a.y + b.y &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complex <span class="keyword">operator</span>-(<span class="keyword">const</span> complex &amp;a, <span class="keyword">const</span> complex &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; a.x - b.x, a.y - b.y &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complex <span class="keyword">operator</span>*(<span class="keyword">const</span> complex &amp;a, <span class="keyword">const</span> complex &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complex <span class="keyword">operator</span>*(<span class="keyword">const</span> complex &amp;a, <span class="keyword">double</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; a.x * b, a.y * b &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complex <span class="keyword">operator</span>/(<span class="keyword">const</span> complex &amp;a, <span class="keyword">double</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; a.x / b, a.y / b &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(complex f[], <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i])</span><br><span class="line">            std::<span class="built_in">swap</span>(f[i], f[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        complex T = &#123; std::<span class="built_in">cos</span>(PI / i), o * std::<span class="built_in">sin</span>(PI / i) &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += i &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">            complex w = &#123; <span class="number">1</span>, <span class="number">0</span> &#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k, w = w * T) &#123;</span><br><span class="line">                complex nx = f[j + k], ny = w * f[i + j + k];</span><br><span class="line">                f[j + k] = nx + ny;</span><br><span class="line">                f[i + j + k] = nx - ny;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>();</span><br><span class="line">        A[x].x += <span class="number">1</span>;</span><br><span class="line">        B[x * <span class="number">2</span>].x += <span class="number">1</span>;</span><br><span class="line">        C[x * <span class="number">3</span>].x += <span class="number">1</span>;</span><br><span class="line">        max = std::<span class="built_in">max</span>(max, x * <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lim &lt;= max &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>)  ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FFT</span>(A, <span class="number">1</span>); <span class="built_in">FFT</span>(B, <span class="number">1</span>); <span class="built_in">FFT</span>(C, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        A[i] = A[i] + (A[i] * A[i] - B[i]) / <span class="number">2</span> + (A[i] * A[i] * A[i]</span><br><span class="line">            - A[i] * B[i] * <span class="number">3</span> + C[i] * <span class="number">2</span>) / <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FFT</span>(A, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">int</span>)(A[i].x / lim + <span class="number">0.5</span>) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, (<span class="keyword">int</span>)(A[i].x / lim + <span class="number">0.5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>TJOI2015弦论</title>
    <url>/2019/06/19/tjoi2015%E5%BC%A6%E8%AE%BA/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3975">[TJOI2015]弦论</a> 后缀自动机上的一条路径对应一个子串，所以，对于第一问，每个节点对应串的数量$size[i]$都是$1$。 第二问中，每个节点的权值都是$size[i]=\sum size[j]+size[i]$。其中，构建SAM时复制出的节点为$0$，其它为$1$。$j$为$i$在parent树上的儿子。实际上这个权值，就是right集合的大小。right集合大小，就是出现次数。 然后随便在图上DP，跑一跑就过了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">23333</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[N]; <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> fa[N], ch[N][<span class="number">26</span>], len[N], tot = <span class="number">1</span>, last = <span class="number">1</span>, sz[N], sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = last, np = ++tot;</span><br><span class="line">    last = np, len[np] = len[p] + <span class="number">1</span>;</span><br><span class="line">    sz[np] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; !ch[p][c])</span><br><span class="line">        ch[p][c] = np, p = fa[p];</span><br><span class="line">    <span class="keyword">if</span> (!p) fa[np] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> q = ch[p][c];</span><br><span class="line">        <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)</span><br><span class="line">            fa[np] = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> nq = ++tot;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="built_in"><span class="keyword">sizeof</span></span>(ch[q]));</span><br><span class="line">            len[nq] = len[p] + <span class="number">1</span>;</span><br><span class="line">            fa[nq] = fa[q];</span><br><span class="line">            fa[q] = fa[np] = nq;</span><br><span class="line">            <span class="keyword">while</span> (p &amp;&amp; ch[p][c] == q)</span><br><span class="line">                ch[p][c] = nq, p = fa[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[N], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>); n = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">insert</span>(str[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t, k; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;t, &amp;k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) ++c[len[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tot; i &gt;= <span class="number">1</span>; --i) a[c[len[i]]--] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tot; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>) sz[fa[a[i]]] += sz[a[i]];</span><br><span class="line">        <span class="keyword">else</span> sz[a[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sz[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tot; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        sum[a[i]] = sz[a[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)</span><br><span class="line">            <span class="keyword">if</span> (ch[a[i]][j])</span><br><span class="line">                sum[a[i]] += sum[ch[a[i]][j]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k &gt; sum[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span> (ch[p][i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k &gt; sum[ch[p][i]])</span><br><span class="line">                    k -= sum[ch[p][i]];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span> + i);</span><br><span class="line">                    p = ch[p][i];</span><br><span class="line">                    k -= sz[p];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>USACO06DEC牛奶模式Milk Patterns</title>
    <url>/2019/06/12/usaco06dec%E7%89%9B%E5%A5%B6%E6%A8%A1%E5%BC%8Fmilk-patterns/</url>
    <content><![CDATA[<p>求至少出现k次的最长重复子串。 <a href="https://www.luogu.org/problemnew/show/P2852">[USACO06DEC]牛奶模式Milk Patterns</a> 二分一个长度x，然后检查height数组里有没有连续x个，值都&gt;=k的即可。 实际上不需要二分，单调队列维护height[i-k+1]~height[i]的min，求这些min的max。 不过嘛，二分代码好写…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20000</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> n, nn, m, a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> x[N], y[N], c[N], sa[N], rk[N], ht[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(); m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = b[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">sort</span>(b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">    nn = <span class="built_in">unique</span>(b + <span class="number">1</span>, b + n + <span class="number">1</span>) - b - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = <span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + nn + <span class="number">1</span>, a[i]) - b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i] = a[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, p = <span class="number">0</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>, p = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; ++i) y[++p] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt; k) y[++p] = sa[i] - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[y[i]]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[y[i]]]--] = y[i];</span><br><span class="line">        <span class="built_in">swap</span>(x, y); p = x[sa[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            x[sa[i]] = y[sa[i]] == y[sa[i - <span class="number">1</span>]]</span><br><span class="line">                &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]</span><br><span class="line">                ? p : ++p;</span><br><span class="line">        <span class="keyword">if</span> (p == n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, p = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (p) --p;</span><br><span class="line">        <span class="keyword">int</span> j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (a[i + p] == a[j + p]) ++p;</span><br><span class="line">        ht[rk[i]] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>, cnt = <span class="number">0</span>, ok = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ht[i] &lt; mid) cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (++cnt &gt;= m) &#123; ok = <span class="number">1</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ok) l = mid + <span class="number">1</span>, ans = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>USACO09FEB改造路</title>
    <url>/2019/02/22/usaco09feb%E6%94%B9%E9%80%A0%E8%B7%AF/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2939">[USACO09FEB]改造路</a> 实际上还是套路题…分层图或者dp都可以…这次用dp写了下…放个代码跑路（</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123&#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">0</span>; <span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) a=c==<span class="string">&#x27;-&#x27;</span>?<span class="number">0</span>:<span class="number">1</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) b=b*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> a?b:-b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10233</span>,M=<span class="number">50233</span>,K=<span class="number">25</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">G</span>&#123;</span><span class="keyword">int</span> to,nxt,c;&#125;g[M*<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N],tot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        g[++tot].to=y,g[tot].nxt=head[x],</span><br><span class="line">        g[tot].c=c,head[x]=tot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n,m,k;</span><br><span class="line">    <span class="keyword">int</span> dis[N][K];</span><br><span class="line">    <span class="keyword">bool</span> vis[N][K];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> sum,id,use;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="keyword">int</span> _sum,<span class="keyword">int</span> _id,<span class="keyword">int</span> _use)&#123;</span><br><span class="line">            sum=_sum,id=_id,use=_use;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;node)<span class="keyword">const</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sum&gt;node.sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    priority_queue&lt;Node&gt; que;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>(),k=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=<span class="built_in">rd</span>(),y=<span class="built_in">rd</span>(),c=<span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">addedge</span>(x,y,c),<span class="built_in">addedge</span>(y,x,c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">        dis[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>; que.<span class="built_in">push</span>(<span class="built_in">Node</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> x=que.<span class="built_in">top</span>().id,use=que.<span class="built_in">top</span>().use;</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!vis[x][use])&#123;</span><br><span class="line">                vis[x][use]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x],y=g[i].to;i;i=g[i].nxt,y=g[i].to)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dis[y][use]&gt;dis[x][use]+g[i].c)&#123;</span><br><span class="line">                        dis[y][use]=dis[x][use]+g[i].c;</span><br><span class="line">                        que.<span class="built_in">push</span>(<span class="built_in">Node</span>(dis[y][use],y,use));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(use&lt;k&amp;&amp;dis[y][use+<span class="number">1</span>]&gt;dis[x][use])&#123;</span><br><span class="line">                        dis[y][use+<span class="number">1</span>]=dis[x][use];</span><br><span class="line">                        que.<span class="built_in">push</span>(<span class="built_in">Node</span>(dis[y][use+<span class="number">1</span>],y,use+<span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;++i)</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,dis[n][i]);</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>USACO15JAN草鉴定Grass Cownoisseur</title>
    <url>/2019/03/13/usaco15jan%E8%8D%89%E9%89%B4%E5%AE%9Agrass-cownoisseur/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3119">[USACO15JAN]草鉴定Grass Cownoisseur</a> 可以反向走一条边，从1出发回到1，求能经过多少点。 缩个点先。然后ning干发现这题对边有限制。一般遇到对边有限制的最短/长路，就可以考虑dp或者分层图。这里用了分层图，对于存在的边$(x,y)$，从$y$向$x+n$建边。答案就是$1+n$那个位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">2333</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> from[N * <span class="number">2</span>], to[N * <span class="number">2</span>], nxt[N * <span class="number">2</span>], head[N], tot;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            from[++tot] = x, to[tot] = y,</span><br><span class="line">            nxt[tot] = head[x], head[x] = tot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; g1, g2;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dfn[N], low[N], num, stack[N], top, c[N], cnt, size[N];</span><br><span class="line">    <span class="keyword">bool</span> ins[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        dfn[x] = low[x] = ++num;</span><br><span class="line">        ins[stack[++top] = x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = g1.head[x]; i; i = g1.nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = g1.to[i];</span><br><span class="line">            <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(y);</span><br><span class="line">                low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ins[y])</span><br><span class="line">                low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (low[x] == dfn[x]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y; ++cnt;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                ins[y = stack[top--]] = <span class="literal">false</span>;</span><br><span class="line">                ++size[c[y] = cnt];</span><br><span class="line">            &#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dis[N], que[N * <span class="number">20</span>], l, r;</span><br><span class="line">    <span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">            g1.<span class="built_in">addedge</span>(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">            size[i + n] = size[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = c[g1.from[i]], y = c[g1.to[i]];</span><br><span class="line">            <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">                g2.<span class="built_in">addedge</span>(x, y);</span><br><span class="line">                g2.<span class="built_in">addedge</span>(y, x + n);</span><br><span class="line">                g2.<span class="built_in">addedge</span>(x + n, y + n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        g2.<span class="built_in">addedge</span>(c[<span class="number">1</span>], c[<span class="number">1</span>] + n);</span><br><span class="line">        que[r = <span class="number">1</span>] = c[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (l != r) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = que[++l];</span><br><span class="line">            vis[x] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = g2.head[x]; i; i = g2.nxt[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = g2.to[i];</span><br><span class="line">                <span class="keyword">if</span> (dis[y] &lt; dis[x] + size[y]) &#123;</span><br><span class="line">                    dis[y] = dis[x] + size[y];</span><br><span class="line">                    <span class="keyword">if</span> (!vis[y]) &#123;</span><br><span class="line">                        vis[y] = <span class="literal">true</span>;</span><br><span class="line">                        que[++r] = y;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dis[c[<span class="number">1</span>] + n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>USACO06JAN冗余路径</title>
    <url>/2019/03/13/usaco06jan%E5%86%97%E4%BD%99%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2860">[USACO06JAN]冗余路径</a> 给定一张无向图，让任意点对之间存在至少两条完全不同的路，求需要加多少边。 因为是无向图，一个环内肯定有两条路。无向图找环其实就是边双，缩点ning干就完事，然后得到了一张新图。然后需要把新图变成一个大环，在度数为1的点之间连边。答案就是$(cnt+1)/2$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> from[N], to[N], nxt[N], head[N], tot;</span><br><span class="line">        <span class="built_in">Graph</span>() &#123; tot = <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            from[++tot] = x, to[tot] = y, nxt[tot] = head[x], head[x] = tot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; g;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dfn[N], low[N], num, c[N], cnt, stack[N], top;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">        dfn[x] = low[x] = ++num;</span><br><span class="line">        stack[++top] = x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = g.head[x]; i; i = g.nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = g.to[i];</span><br><span class="line">            <span class="keyword">if</span> (y == father) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(y, x);</span><br><span class="line">                low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y; ++cnt;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                y = stack[top--];</span><br><span class="line">                c[y] = cnt;</span><br><span class="line">            &#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; st[N];</span><br><span class="line">    <span class="keyword">int</span> in[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">            g.<span class="built_in">addedge</span>(x, y);</span><br><span class="line">            g.<span class="built_in">addedge</span>(y, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= g.tot; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = c[g.from[i]], y = c[g.to[i]];</span><br><span class="line">            <span class="keyword">if</span> (x != y &amp;&amp; st[x].<span class="built_in">find</span>(y) == st[x].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                st[x].<span class="built_in">insert</span>(y);</span><br><span class="line">                st[y].<span class="built_in">insert</span>(x);</span><br><span class="line">                ++in[x];</span><br><span class="line">                ++in[y];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) <span class="keyword">if</span> (in[i] == <span class="number">1</span>) ++ans;</span><br><span class="line">        cout &lt;&lt; (ans + <span class="number">1</span>) / <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>USACO15OPENBessie的生日自助餐</title>
    <url>/2019/04/25/usaco15openbessie%E7%9A%84%E7%94%9F%E6%97%A5%E8%87%AA%E5%8A%A9%E9%A4%90/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3125">[USACO15OPEN]Bessie的生日自助餐</a> DP题。首先预处理出任意两点间距离，因为本题边权都一样，bfs即可。 要求吃草顺序单增，考虑每一个点，要么作为终点，要么走向更大的点。把点按点权从大到小排序。DP转移方程：$f(x)=max(val(x),max(val(x)+f(y)-dis(x,y)))$，其中$val(x)&lt;val(y)$，排序后即$y&lt;x$ $ans=max(f(x))$。复杂度$O(nm+n^2)$。 注意本题图不一定联通</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span> + <span class="number">233</span>, M = N * <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, e, val[N], dis[N][N], node[N], f[N], ans;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span> <span class="keyword">int</span> to, nxt; &#125; g[M * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    g[++tot].to = y, g[tot].nxt = head[x],</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> val[x] &gt; val[y]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// read</span></span><br><span class="line">    n = <span class="built_in">rd</span>(), e = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        dis[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        val[i] = <span class="built_in">rd</span>();</span><br><span class="line">        node[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">rd</span>(); j; --j)</span><br><span class="line">            <span class="built_in">addedge</span>(i, <span class="built_in">rd</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bfs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= n; ++s) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">        que.<span class="built_in">push</span>(s);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">                <span class="keyword">if</span> (!vis[y]) &#123;</span><br><span class="line">                    vis[y] = <span class="literal">true</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(y);</span><br><span class="line">                    dis[s][y] = dis[s][x] + e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp</span></span><br><span class="line">    <span class="built_in">sort</span>(node + <span class="number">1</span>, node + n + <span class="number">1</span>, comp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        f[i] = val[node[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">            f[i] = <span class="built_in">max</span>(f[i], val[node[i]] + f[j] - dis[node[i]][node[j]]);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>Usaco2011 Jan道路和航线</title>
    <url>/2019/02/06/usaco2011-jan%E9%81%93%E8%B7%AF%E5%92%8C%E8%88%AA%E7%BA%BF/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2200">[Usaco2011 Jan]道路和航线</a> 本题正解：裸SPFA会TLE，考虑Tarjan缩点，每个强连通分量内跑Dijkstra，然后再加上单向边，从S开始求出每个点的距离。 然而我上了歪解：SLF优化的SPFA。据说这玩意可以被卡到比SPFA还慢…不过能AC这个题。放个代码~</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">233</span>, M = N * <span class="number">2</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> to, nxt, c;</span><br><span class="line">    &#125; g[M * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N], tot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        g[++tot].to = y, g[tot].nxt = head[x],</span><br><span class="line">        g[tot].c = c, head[x] = tot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t, r, p, s, dis[N];;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        t = <span class="built_in">rd</span>(), r = <span class="built_in">rd</span>(), p = <span class="built_in">rd</span>(), s = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>(), c = <span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">addedge</span>(x, y, c), <span class="built_in">addedge</span>(y, x, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>(), c = <span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">addedge</span>(x, y, c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">        que.<span class="built_in">push_back</span>(s), dis[s] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = que.<span class="built_in">front</span>(); que.<span class="built_in">pop_front</span>();</span><br><span class="line">            vis[x] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y = g[i].to; i; i = g[i].nxt, y = g[i].to) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[y] &gt; dis[x] + g[i].c) &#123;</span><br><span class="line">                    dis[y] = dis[x] + g[i].c;</span><br><span class="line">                    <span class="keyword">if</span> (!vis[y]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; dis[y] &lt; dis[que.<span class="built_in">front</span>()])</span><br><span class="line">                            que.<span class="built_in">push_front</span>(y);</span><br><span class="line">                        <span class="keyword">else</span> que.<span class="built_in">push_back</span>(y);</span><br><span class="line">                        vis[y] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[i] == <span class="number">0x3f3f3f3f</span>) <span class="built_in">puts</span>(<span class="string">&quot;NO PATH&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dis[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>USACO5.1乐曲主题Musical Themes</title>
    <url>/2019/06/12/usaco5-1%E4%B9%90%E6%9B%B2%E4%B8%BB%E9%A2%98musical-themes/</url>
    <content><![CDATA[<p>求不重叠的最长重复子串。 <a href="https://www.luogu.org/problemnew/show/P2743">[USACO5.1]乐曲主题Musical Themes</a> 题目中的转调可以用差分解决。差分后求原串中最长重复出现且不相交的。 DP可做。但是是$O(n^2)$。 SA求一下height。二分答案，扫sa。height小于k时新开一组，即可得到一堆lcp&gt;=k的串。如果组内sa的最大最小值差&gt;k，即有两个不相交的串，就可以。 $O(nlogn)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000</span> + <span class="number">233</span>, S = <span class="number">2333</span>, INF = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], s[N];</span><br><span class="line"><span class="keyword">int</span> fir[N], sec[N], buc[N], sa[N], rk[N], ht[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++buc[fir[i] = s[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; ++i) buc[i] += buc[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[buc[fir[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, p = <span class="number">0</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>, p = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; ++i) sec[++p] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt; k) sec[++p] = sa[i] - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) buc[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++buc[fir[sec[i]]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) buc[i] += buc[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[buc[fir[sec[i]]]--] = sec[i];</span><br><span class="line">        <span class="built_in">swap</span>(fir, sec); fir[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            fir[sa[i]] = sec[sa[i]] == sec[sa[i - <span class="number">1</span>]]</span><br><span class="line">                &amp;&amp; sec[sa[i] + k] == sec[sa[i - <span class="number">1</span>] + k]</span><br><span class="line">                ? p : ++p;</span><br><span class="line">        <span class="keyword">if</span> (p == n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, p = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (p) --p;</span><br><span class="line">        <span class="keyword">int</span> j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (s[i + p] == s[j + p]) ++p;</span><br><span class="line">        ht[rk[i]] = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max_len = -INF, min_len = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ht[i] &lt; k) max_len = -INF, min_len = INF;</span><br><span class="line">        max_len = <span class="built_in">max</span>(max_len, sa[i]);</span><br><span class="line">        min_len = <span class="built_in">min</span>(min_len, sa[i]);</span><br><span class="line">        <span class="keyword">if</span> (max_len - min_len &gt; k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) s[i] = a[i] - a[i - <span class="number">1</span>] + <span class="number">233</span>;</span><br><span class="line">    <span class="built_in">SA</span>();</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid + <span class="number">1</span>, ans = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++ans;</span><br><span class="line">    <span class="keyword">if</span> (ans &lt; <span class="number">5</span>) ans = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>WC2014时空穿梭 反演</title>
    <url>/2020/04/02/wc2014%E6%97%B6%E7%A9%BA%E7%A9%BF%E6%A2%AD-%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<p><a href="http://uoj.ac/problem/54">[WC2014]时空穿梭</a> 如果推式子足够熟练的话，可以一路推出来的。但是我推着推着就迷惑了。。 首先要找的是直线。那么确定直线最好的办法是确定两个端点。考虑枚举两个点，坐标分别为$(a_1,a_2…),(b_1,b_2,…)$，那么必须有$\exists i, a_i &lt; b_i$。确定两个点之后，这条线上一共有$gcd_{i=1}^n(b_i-a_i)+1$个点。 那么答案为： $$ans=\sum_{a,b} \binom{gcd(b_i-a_i)-1}{c-2}$$ 对这个式子进行优化。首先我们只关心坐标差，枚举坐标差$\Delta_i = b_i-a_i$。 $$\sum_{1 \leq \Delta_i &lt; m_i} \binom{gcd(\Delta_i )-1}{c - 2} \prod_{i \leq n} (m_i - \Delta_i) $$ 紧接着再枚举GCD为$g$ $$\sum_{g &lt; min_m} \binom{g-1}{c-2} \sum_{ 1 \leq \Delta_i &lt; m_i,gcd(\Delta_i) = g}\prod_{i \leq n} (m_i - \Delta_i)$$ 令后面这一坨为$f(g)$。为了去掉GCD的限制，考虑反演 $$f’(g) = \sum_{g d} f(d) = \sum_{ 1 \leq \Delta_i &lt; m_i, g gcd(\Delta_i) }\prod_{i \leq n} (m_i - \Delta_i)$$ 那么GCD就可以去掉了。 $$\sum_{1 \leq \Delta_i &lt; \lfloor \frac{m_i}{g} \rfloor} \prod(m_i - \Delta_ig)$$ 实际上考虑分配律这个式子可以把两个符号换一下位置。交换后后面是$\sum$，可以用等差数列求和公式。化简之后如下： $$f’(g)=\prod_{i \leq n} (\lfloor \frac{m_i - 1}{g} \rfloor m_i - \frac{d\lfloor \frac{m_i - 1}{g} \rfloor(1+\lfloor \frac{m_i - 1}{g} \rfloor)}{2}) $$ 反演的式子套进去，直接带入答案： $$ans=\sum_{g &lt; min_m} \binom{g-1}{c-2} \sum_{g d} \mu(\frac{d}{g}) \prod_{i \leq n} (\lfloor \frac{m_i - 1}{d} \rfloor m_i - \frac{d\lfloor \frac{m_i - 1}{d} \rfloor(1+\lfloor \frac{m_i - 1}{d} \rfloor)}{2})$$ 有个取整，考虑取整的可能值是$O(n \sqrt m)$的。枚举所有可能的$\lfloor \frac{m_i - 1}{d} \rfloor$，看作常数，后面是一个$n$次多项式。暴力拆开 $$\sum_{0 \leq i \leq n} v_i \sum_{?\leq d \leq ?}d^i \sum_{g d} \mu(\frac{d}{g}) \binom{g-1}{c-2} $$ 对于这两个$?$，它们取决于取整的$d$的范围。那么后面这一堆$\sum$只取决于$c,?,i$，预处理出来就好了。 复杂度：$O(cmlogm+cmn+T\sqrt m n^3)$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">const int N = 12, C = 21, M = 100001;</span><br><span class="line">const int P = 10007, INF = 1e9;</span><br><span class="line"></span><br><span class="line">inline int fpow(int x, int y) &#123;</span><br><span class="line">  int ret = 1;</span><br><span class="line">  for ( ; y; y &gt;&gt;= 1, x = x * x % P)</span><br><span class="line">    if (y &amp; 1) ret = ret * x % P;</span><br><span class="line">  return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fac[M], inv[M];</span><br><span class="line"></span><br><span class="line">inline int binom(int n, int m) &#123;</span><br><span class="line">  if (n &lt; 0  m &lt; 0  n &lt; m)</span><br><span class="line">    return 0;</span><br><span class="line">  if (n &gt;= P  m &gt;= P)</span><br><span class="line">    return binom(n / P, m / P) * binom(n % P, m % P) % P;</span><br><span class="line">  return fac[n] * inv[m] % P * inv[n - m] % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int S[C][M][N];</span><br><span class="line">int mu[M];</span><br><span class="line"></span><br><span class="line">inline void init() &#123;</span><br><span class="line">  fac[0] = 1;</span><br><span class="line">  for (int i = 1; i &lt; P; ++i)</span><br><span class="line">    fac[i] = fac[i - 1] * i % P;</span><br><span class="line">  inv[P - 1] = fpow(fac[P - 1], P - 2);</span><br><span class="line">  for (int i = P - 1; i; --i)</span><br><span class="line">    inv[i - 1] = inv[i] * i % P;</span><br><span class="line"></span><br><span class="line">  mu[1] = 1;</span><br><span class="line">  for (int i = 1; i &lt; M; ++i)</span><br><span class="line">    for (int j = i + i; j &lt; M; j += i)</span><br><span class="line">      mu[j] -= mu[i];</span><br><span class="line"></span><br><span class="line">  static int f[M];</span><br><span class="line"></span><br><span class="line">  for (int c = 2; c &lt; C; ++c) &#123;</span><br><span class="line">    memset(f, 0, sizeof(f));</span><br><span class="line">    for (int g = c - 1; g &lt; M; ++g)</span><br><span class="line">      for (int d = g; d &lt; M; d += g)</span><br><span class="line">        f[d] = (f[d] + mu[d / g] * binom(g - 1, c - 2)) % P;</span><br><span class="line">    for (int d = 1; d &lt; M; ++d)</span><br><span class="line">      for (int i = 0, v = 1; i &lt; N; ++i, v = d % P * v % P)</span><br><span class="line">        S[c][d][i] = (S[c][d - 1][i] + f[d] * v % P + P) % P;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int n, c, m[N];</span><br><span class="line"></span><br><span class="line">inline void solve() &#123;</span><br><span class="line">  int min_m = INF;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">  for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">    std::cin &gt;&gt; m[i];</span><br><span class="line">    min_m = std::min(min_m, m[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (min_m &lt; c) &#123;</span><br><span class="line">    puts(&quot;0&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;int&gt; div;</span><br><span class="line">  div.push_back(1);</span><br><span class="line">  for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">    int tmp = 1;</span><br><span class="line">    while (tmp &lt; m[i] - 1) &#123;</span><br><span class="line">      tmp = (m[i] - 1) / ((m[i] - 1) / tmp) + 1;</span><br><span class="line">      div.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::sort(div.begin(), div.end());</span><br><span class="line">  div.resize(std::unique(div.begin(), div.end()) - div.begin());</span><br><span class="line">  div.push_back(min_m);</span><br><span class="line"></span><br><span class="line">  int ans = 0;</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i + 1 &lt; div.size(); ++i) &#123;</span><br><span class="line">    if (div[i] &gt;= min_m) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    int l = div[i], r = div[i + 1] - 1;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;int&gt; f(n + 1);</span><br><span class="line">    f[0] = 1;</span><br><span class="line">    for (int j = 1; j &lt;= n; ++j) &#123;</span><br><span class="line">      int v = (m[j] - 1) / l % P, b = 1ll * v * m[j] % P,</span><br><span class="line">        a = -1ll * v * (v + 1) % P * inv[2] % P;</span><br><span class="line"></span><br><span class="line">      for (int k = n; k; --k) &#123;</span><br><span class="line">        f[k] = (f[k - 1] * a + f[k] * b) % P;</span><br><span class="line">      &#125;</span><br><span class="line">      f[0] = (f[0] * b) % P;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int j = 0; j &lt;= n; ++j) &#123;</span><br><span class="line">      ans = (ans + f[j] * (S[c][r][j] - S[c][l - 1][j])) % P;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ans = (ans % P + P) % P;</span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  init();</span><br><span class="line">  int T;</span><br><span class="line">  std::cin &gt;&gt; T;</span><br><span class="line">  while (T--) &#123;</span><br><span class="line">    solve();</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>WC2014紫荆花之恋</title>
    <url>/2020/04/07/wc2014%E7%B4%AB%E8%8D%86%E8%8A%B1%E4%B9%8B%E6%81%8B/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3920">[WC2014]紫荆花之恋</a> 题目要求$r_i + r_j \geq dis_{i,j}$的点对有多少，那么考虑枚举路径上一个点把路径分开，就是求$r_i -dis_i \geq r_j + dis_j$的点对数量。那么在这个点上维护平衡树，就可以二分查找了。去重，考虑在儿子节点上挂一个平衡树，维护的信息和父亲的一样，但是只包含儿子的子树中的点。枚举$i$，在分割点的平衡树和分割点包含$i$的子树平衡树中分别查找 考虑点分治优化这一过程。新增一个点后，只需计算它在点分树上每个祖先处形成的贡献之和。就可以快速求出答案了。将原来挂在儿子上有关父亲的信息挂在点分树的儿子上即可。注意到加入点可能会使点分树退化为不优秀的性质，考虑替罪羊树的思想，定期重构即可 一些实现上的细节：需要写三个东西：平衡树，倍增求距，点分树。要采用高效平衡树。注意平衡树回收删掉的节点节省内存。建议模块化代码方便一块一块的调试。。。点分树部分很多迷之细节，想清楚再写，对着rqy的代码调了半天才发现问题。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IO</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> S = <span class="number">3e7</span>;</span><br><span class="line">  <span class="keyword">char</span> buc_in[S], buc_out[S], *p_in = buc_in, *p_out = buc_out;</span><br><span class="line">  <span class="built_in">IO</span>() &#123; <span class="built_in">fread</span>(buc_in, <span class="number">1</span>, S, stdin); &#125;</span><br><span class="line">  ~<span class="built_in">IO</span>() &#123; <span class="built_in">fwrite</span>(buc_out, <span class="number">1</span>, p_out - buc_out, stdout); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(*p_in)) ++p_in;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(*p_in)) ret = ret * <span class="number">10</span> + *p_in++ - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buc[<span class="number">20</span>], *p = buc;</span><br><span class="line">    <span class="keyword">do</span> *p++ = x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (x /= <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span> (p != buc)</span><br><span class="line">      *p_out++ = *--p;</span><br><span class="line">    *p_out++ = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">233</span>, P = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BTree &#123;</span><br><span class="line">  <span class="keyword">int</span> pool[N * <span class="number">100</span>], *top = pool;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init_pool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N * <span class="number">100</span>; ++i)</span><br><span class="line">      *top++ = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *--top; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; *top++ = x; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>], val, size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ch[<span class="number">0</span>] = ch[<span class="number">1</span>] = val = size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; t[N * <span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    t[x].size = t[t[x].ch[<span class="number">0</span>]].size + t[t[x].ch[<span class="number">1</span>]].size + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> stk[N], tmp[N], ver;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[x].ch[<span class="number">0</span>]) <span class="built_in">dfs</span>(t[x].ch[<span class="number">0</span>]);</span><br><span class="line">    stk[++ver] = x, tmp[ver] = t[x].val;</span><br><span class="line">    <span class="keyword">if</span> (t[x].ch[<span class="number">1</span>]) <span class="built_in">dfs</span>(t[x].ch[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    x = stk[ver--]; t[x].<span class="built_in">init</span>();</span><br><span class="line">    t[x].val = tmp[mid];</span><br><span class="line">    <span class="keyword">if</span> (l &lt; mid) <span class="built_in">build</span>(t[x].ch[<span class="number">0</span>], l, mid - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) <span class="built_in">build</span>(t[x].ch[<span class="number">1</span>], mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> re, rfa, dir;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _insert(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">      t[x = <span class="built_in">get</span>()].val = val;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    _insert(t[x].ch[val &gt; t[x].val], val);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (t[t[x].ch[<span class="number">0</span>]].size &gt; <span class="number">0.75</span> * t[x].size  t[t[x].ch[<span class="number">1</span>]].size &gt; <span class="number">0.75</span> * t[x].size)</span><br><span class="line">      re = x, rfa = dir = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t[x].ch[val &gt; t[x].val] == re)</span><br><span class="line">      rfa = x, dir = val &gt; t[x].val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    re = rfa = dir = <span class="number">0</span>;</span><br><span class="line">    _insert(x, val);</span><br><span class="line">    <span class="keyword">if</span> (re) &#123;</span><br><span class="line">      ver = <span class="number">0</span>; <span class="built_in">dfs</span>(re); <span class="built_in">build</span>(re, <span class="number">1</span>, ver);</span><br><span class="line">      <span class="keyword">if</span> (rfa)</span><br><span class="line">        t[rfa].ch[dir] = re;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        x = re;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val &lt; t[x].val)</span><br><span class="line">        x = t[x].ch[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        ret += t[t[x].ch[<span class="number">0</span>]].size + <span class="number">1</span>;</span><br><span class="line">        x = t[x].ch[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[x].ch[<span class="number">0</span>]) <span class="built_in">clear</span>(t[x].ch[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (t[x].ch[<span class="number">1</span>]) <span class="built_in">clear</span>(t[x].ch[<span class="number">1</span>]);</span><br><span class="line">    t[x].<span class="built_in">init</span>(); <span class="built_in">del</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> to, nxt, cost;</span><br><span class="line">&#125; G[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], etot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  G[++etot] = &#123; y, head[x], c &#125;, head[x] = etot;</span><br><span class="line">  G[++etot] = &#123; x, head[y], c &#125;, head[y] = etot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FTree &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> up = <span class="number">17</span>;</span><br><span class="line">  <span class="keyword">int</span> dad[N][up + <span class="number">1</span>], dep[N], dis[N];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">addedge</span>(x, f, c);</span><br><span class="line">    dep[x] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    dis[x] = dis[f] + c;</span><br><span class="line">    dad[x][<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= up; ++i)</span><br><span class="line">      dad[x][i] = dad[dad[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &lt; dep[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = up; ~i; --i)</span><br><span class="line">      <span class="keyword">if</span> (dep[dad[x][i]] &gt;= dep[y])</span><br><span class="line">        x = dad[x][i];</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = up; ~i; --i)</span><br><span class="line">      <span class="keyword">if</span> (dad[x][i] != dad[y][i])</span><br><span class="line">        x = dad[x][i], y = dad[y][i];</span><br><span class="line">    <span class="keyword">return</span> dad[x][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lca = <span class="built_in">get_lca</span>(x, y);</span><br><span class="line">    <span class="keyword">return</span> dis[x] + dis[y] - dis[lca] * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DTree &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> root1[N], root2[N], fa[N], vis1[N], vis2[N], tag;</span><br><span class="line">  std::set&lt;<span class="keyword">int</span>&gt; son[N];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    vis1[x] = tag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y : son[x]) &#123;</span><br><span class="line">      BTree::<span class="built_in">clear</span>(root2[y]);</span><br><span class="line">      root2[y] = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">clear</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    BTree::<span class="built_in">clear</span>(root1[x]);</span><br><span class="line">    root1[x] = <span class="number">0</span>;</span><br><span class="line">    son[x].<span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> pos, min_tree, all;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get_size</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dad)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = G[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">int</span> y = G[i].to;</span><br><span class="line">      <span class="keyword">if</span> (vis1[y] == tag &amp;&amp; vis2[y] != tag &amp;&amp; y != dad) &#123;</span><br><span class="line">        ret += <span class="built_in">get_size</span>(y, x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get_pos</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dad)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>, max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = G[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">int</span> y = G[i].to;</span><br><span class="line">      <span class="keyword">if</span> (vis1[y] == tag &amp;&amp; vis2[y] != tag &amp;&amp; y != dad) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="built_in">get_pos</span>(y, x);</span><br><span class="line">        ret += tmp;</span><br><span class="line">        max = std::<span class="built_in">max</span>(max, tmp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    max = std::<span class="built_in">max</span>(max, all - ret);</span><br><span class="line">    <span class="keyword">if</span> (max &lt; min_tree) &#123;</span><br><span class="line">      min_tree = max;</span><br><span class="line">      pos = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dad, <span class="keyword">int</span> dep, <span class="keyword">int</span> &amp;r)</span> </span>&#123;</span><br><span class="line">    BTree::<span class="built_in">insert</span>(r, dep - R[x]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = G[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">int</span> y = G[i].to;</span><br><span class="line">      <span class="keyword">if</span> (vis1[y] == tag &amp;&amp; vis2[y] != tag &amp;&amp; y != dad) &#123;</span><br><span class="line">        <span class="built_in">insert</span>(y, x, dep + G[i].cost, r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">find_center</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    all = <span class="built_in">get_size</span>(x, <span class="number">0</span>);</span><br><span class="line">    min_tree = P;</span><br><span class="line">    <span class="built_in">get_pos</span>(x, <span class="number">0</span>);</span><br><span class="line">    x = pos;</span><br><span class="line">    vis2[x] = tag;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">insert</span>(x, <span class="number">0</span>, <span class="number">0</span>, root1[x]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = G[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">int</span> y = G[i].to;</span><br><span class="line">      <span class="keyword">if</span> (vis1[y] == tag &amp;&amp; vis2[y] != tag) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>; <span class="built_in">insert</span>(y, x, G[i].cost, r);</span><br><span class="line">        <span class="keyword">int</span> z = <span class="built_in">find_center</span>(y);</span><br><span class="line">        fa[z] = x; son[x].<span class="built_in">insert</span>(z);</span><br><span class="line">        root2[z] = r;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rebuild</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ++tag;</span><br><span class="line">    <span class="built_in">clear</span>(x);</span><br><span class="line">    <span class="keyword">int</span> dad = fa[x], r = root2[x];</span><br><span class="line">    root2[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (dad)</span><br><span class="line">      son[dad].<span class="built_in">erase</span>(x);</span><br><span class="line">    x = <span class="built_in">find_center</span>(x);</span><br><span class="line">    fa[x] = dad;</span><br><span class="line">    root2[x] = r;</span><br><span class="line">    <span class="keyword">if</span> (dad)</span><br><span class="line">      son[dad].<span class="built_in">insert</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    fa[x] = f;</span><br><span class="line">    son[f].<span class="built_in">insert</span>(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i = fa[i]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (fa[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = FTree::<span class="built_in">get_dis</span>(x, fa[i]);</span><br><span class="line">        ret += BTree::<span class="built_in">query</span>(root1[fa[i]], R[x] - tmp);</span><br><span class="line">        ret -= BTree::<span class="built_in">query</span>(root2[i], R[x] - tmp);</span><br><span class="line">        BTree::<span class="built_in">insert</span>(root2[i], tmp - R[x]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> tmp = FTree::<span class="built_in">get_dis</span>(x, i);</span><br><span class="line">      BTree::<span class="built_in">insert</span>(root1[i], tmp - R[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; fa[i]; i = fa[i])</span><br><span class="line">      <span class="keyword">if</span> (BTree::t[root1[i]].size &gt; <span class="number">0.75</span> * BTree::t[root1[fa[i]]].size)</span><br><span class="line">        y = fa[i];</span><br><span class="line">    <span class="keyword">if</span> (y) <span class="built_in">rebuild</span>(y);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  BTree::<span class="built_in">init_pool</span>();</span><br><span class="line">  io.<span class="built_in">rd</span>(); <span class="keyword">int</span> n = io.<span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> last_ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> f = io.<span class="built_in">rd</span>() ^ (last_ans % P), c = io.<span class="built_in">rd</span>();</span><br><span class="line">    R[i] = io.<span class="built_in">rd</span>();</span><br><span class="line">    FTree::<span class="built_in">link</span>(i, f, c);</span><br><span class="line">    last_ans += DTree::<span class="built_in">insert</span>(i, f);</span><br><span class="line">    io.<span class="built_in">out</span>(last_ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>WC2020游记</title>
    <url>/2020/08/01/wc2020%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>OI生涯没有WC没有APIO没有CTSC，有点伤心</p>
<h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>路由器，DP推不出来，冬眠。下午没听懂，冬眠</p>
<h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>没听懂，冬眠</p>
<h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><p>没听懂，冬眠</p>
<h2 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h2><p>没听懂，冬眠</p>
<h2 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h2><p>考试，打铁了</p>
<h2 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h2><p>咕咕咕</p>
<hr>
<p>题解：</p>
<h2 id="「WC2020」有根树"><a href="#「WC2020」有根树" class="headerlink" title="「WC2020」有根树"></a>「WC2020」有根树</h2><p>考场思路：考虑父亲肯定比儿子大，考虑维护集合，就在若干链上有分界线。每次修改时维护分界线即可。但是没仔细想怎么维护 实际上存在更简单的log^2做法：不需维护具体分界线，直接维护两个集合即可。具体来说，使用线段树维护集合。我们关心根集合的min，与非根集合的max。那么在修改时，考虑更新答案，即平衡max与cnt两者。这一操作可以通过线段树上二分找极值点实现</p>
<h2 id="「WC2020」猜数游戏"><a href="#「WC2020」猜数游戏" class="headerlink" title="「WC2020」猜数游戏"></a>「WC2020」猜数游戏</h2><p>考场思路：看错题了…之后发现是用若干操作覆盖点集，打了个状压跑路 首先容易用阶的那套理论求出若干关系：即用A可以删掉B。特别的，如果数与模数互质，则换另一套理论：这些数在log次幂内就会变成0 注意到这个关系有传递性，那么考虑一个点什么时候选：只有当不存在可以删它的点的时候 考虑题目要求的东西：每个集合里选多少点。这个可以转化为每个点对多少集合贡献。那么求出有多少点不能选后做一下就好了</p>
<h2 id="「WC2020」选课"><a href="#「WC2020」选课" class="headerlink" title="「WC2020」选课"></a>「WC2020」选课</h2><p>考场思路：只写了p=0的分。凸包卷积一下，考场不知道为什么没调出来。 还没补，咕咕咕咕咕咕。听说卷完之后加个爬山就能过。做法上面的基础上是自然的：即对特殊的状压即可。具体细节还没研究。。</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>YY的GCD</title>
    <url>/2019/04/26/yy%E7%9A%84gcd/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2257">YY的GCD</a> 懵逼钨丝反演第二题。 题意：求 $$\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j) \in prime]$$ 枚举一下$prime$ $$\sum_{p \in prime}\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=p]$$ 反演一波，得到（众：你这反演怎么没过程的） $$ans=\sum_{p \in prime}\sum_{T=1}^{min(\lfloor \frac{n}{p} \rfloor,\lfloor \frac{m}{p} \rfloor)} \mu(T) \lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor$$ 前面这个$p \in prime$看着不爽，复杂度也不对，放到后面去 $$ans=\sum_{T=1}^{min(n, m)} \lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor \sum_{p \mid T, p \in prime} \mu(\frac{T}{p})$$ 开个数组$g$枚举质数$p$，对于$p \mid T$，$g(T)$加上$\mu(\frac{T}{p})$，这个显然可以预处理，然后再对$g$求前缀和，就能做了，很爽。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000000</span> + <span class="number">2333</span>;</span><br><span class="line">ll mu[N], prime[N], cnt, flag[N], sum[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) &#123;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; ++j) &#123;</span><br><span class="line">            flag[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * prime[i] &lt; N; ++j)</span><br><span class="line">            f[j * prime[i]] += mu[j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + f[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll l = <span class="number">1</span>, r = <span class="number">0</span>; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = <span class="built_in">min</span>(n / (n / l), m / (m / l));</span><br><span class="line">        ans += (sum[r] - sum[l - <span class="number">1</span>]) * (n / l) * (m / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> n, m, T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">if</span> (n &gt; m) <span class="built_in">swap</span>(n, m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">solve</span>(n, m));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>ZJOI2005午餐</title>
    <url>/2019/01/06/zjoi2005%E5%8D%88%E9%A4%90/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2577">[ZJOI2005]午餐</a> DP题，首先可以贪心的想到，吃饭时间最长的先吃，于是排序。 用数组f[i][j][k]前i个人，在1号窗口排队j分钟，2号窗口排队k分钟总最短吃完的时间，然而发现会炸空间（（（可以发现，j + k = 前缀和sum[i]，故可以省掉k，f[i][j]前i人，在1号窗口排队j分钟总最短时间。 分析一下，转移方程如下： f[i][j] = min(f[i][j], max(f[i - 1][j - 第i个人排队], j + 第i个人吃饭)); f[i][j] = min(f[i][j], max(f[i - 1][j], sum[i] - j + 第i个人吃饭));</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>ZJOI2006物流运输</title>
    <url>/2019/02/10/zjoi2006%E7%89%A9%E6%B5%81%E8%BF%90%E8%BE%93/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1772">[ZJOI2006]物流运输</a> 一边最短路一边dp…（从题解里）学到了新操作… 本题的最优策略是无后效性的。于是DP，可以用f[i]表示第i天最优策略，转移方程为f[i] = min{f[j - 1] + dis(j) * (i - j + 1) + k}，其中1 &lt;= j &lt;= i，dis(j)表示第j天最短路径。 因为一开始不需要+k，边界为f[0] = -k。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>ZJOI2007棋盘制作</title>
    <url>/2019/01/06/zjoi2007%E6%A3%8B%E7%9B%98%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1169">[ZJOI2007]棋盘制作</a> 悬线法DP，一般用于求矩形上最大字矩形 定义三个数组left，right，up，分别表示向左向右可以扩展到<strong>哪个格子</strong>，向上可以扩展<strong>多少格</strong>。 考虑这样的情况，DP进行到了黑色位置，蓝色满足要求，绿色却不满足，不操作直接用三个数组计算会导致答案错误 <img src="https://baka.online/wp-content/uploads/2019/01/%E6%97%A0%E6%A0%87%E9%A2%98.png"> 解决方案是，如果上方的格子满足要求，我们需要用上方格子的left和right更新此时的，取较靠近中间的值。因为上方DP时已经被绿色限制了，这里也会被改成受限制后的值。 这里的棋盘制作一题要求求出01矩阵中最大的矩形和正方形，用悬线法可以一次求解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// l和r表示最远能扩展到哪里，u表示向上能扩展的长度</span></span><br><span class="line"><span class="keyword">int</span> N, M, ans1, ans2, mp[MAXN][MAXN], l[MAXN][MAXN], r[MAXN][MAXN], u[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; mp[i][j];</span><br><span class="line">            l[i][j] = r[i][j] = j;</span><br><span class="line">            u[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理l</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= M; ++j)</span><br><span class="line">            <span class="keyword">if</span> (mp[i][j] != mp[i][j - <span class="number">1</span>])</span><br><span class="line">                l[i][j] = l[i][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理r</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = M - <span class="number">1</span>; j &gt;= <span class="number">1</span>; --j)</span><br><span class="line">            <span class="keyword">if</span> (mp[i][j] != mp[i][j + <span class="number">1</span>])</span><br><span class="line">                r[i][j] = r[i][j + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= M; ++j) &#123;</span><br><span class="line">            <span class="comment">// 确保不会出现l或r区域上方有不满足的情况</span></span><br><span class="line">            <span class="comment">// 即用上一行更新这一行</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">2</span> &amp;&amp; mp[i][j] != mp[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                l[i][j] = <span class="built_in">max</span>(l[i][j], l[i - <span class="number">1</span>][j]);</span><br><span class="line">                r[i][j] = <span class="built_in">min</span>(r[i][j], r[i - <span class="number">1</span>][j]);</span><br><span class="line">                u[i][j] = u[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> x = r[i][j] - l[i][j] + <span class="number">1</span>, y = <span class="built_in">min</span>(x, u[i][j]);</span><br><span class="line">            ans1 = <span class="built_in">max</span>(ans1, y * y);</span><br><span class="line">            ans2 = <span class="built_in">max</span>(ans2, x * u[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans1 &lt;&lt; endl &lt;&lt; ans2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>ZJOI2007最大半连通子图</title>
    <url>/2019/03/10/zjoi2007%E6%9C%80%E5%A4%A7%E5%8D%8A%E8%BF%9E%E9%80%9A%E5%AD%90%E5%9B%BE/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2272">[ZJOI2007]最大半连通子图</a> 水题。首先强连通分量肯定是半联通的，然后缩点，发现一条链上的都是半联通。所以缩下点，然后拓扑DP就好了。顺便这题要去重边，我直接开了100000个set存，速度不怎么样但是过这题绰绰有余。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">2333</span>, M = <span class="number">1000000</span> + <span class="number">2333</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> from[M * <span class="number">2</span>], to[M * <span class="number">2</span>], nxt[M * <span class="number">2</span>], head[N], tot;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            from[++tot] = x, to[tot] = y,</span><br><span class="line">            nxt[tot] = head[x], head[x] = tot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; g1, g2;</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; st[N];</span><br><span class="line">    <span class="keyword">int</span> n, m, mod, dfn[N], low[N], num, stack[N], top,</span><br><span class="line">        c[N], cnt, size[N], f[N], g[N];</span><br><span class="line">    <span class="keyword">bool</span> ins[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        dfn[x] = low[x] = ++num;</span><br><span class="line">        ins[stack[++top] = x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = g1.head[x]; i; i = g1.nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = g1.to[i];</span><br><span class="line">            <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(y);</span><br><span class="line">                low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ins[y])</span><br><span class="line">                low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (low[x] == dfn[x]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y; ++cnt;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                ins[y = stack[top--]] = <span class="literal">false</span>;</span><br><span class="line">                ++size[c[y] = cnt];</span><br><span class="line">            &#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>(), mod = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">            g1.<span class="built_in">addedge</span>(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = c[g1.from[i]], y = c[g1.to[i]];</span><br><span class="line">            <span class="keyword">if</span> (x != y &amp;&amp; st[x].<span class="built_in">find</span>(y) == st[x].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                st[x].<span class="built_in">insert</span>(y);</span><br><span class="line">                g2.<span class="built_in">addedge</span>(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = cnt; x; --x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!f[x]) f[x] = size[x], g[x] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = g2.head[x]; i; i = g2.nxt[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = g2.to[i];</span><br><span class="line">                <span class="keyword">if</span> (f[y] == f[x] + size[y]) (g[y] += g[x]) %= mod;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (f[y] &lt; f[x] + size[y])</span><br><span class="line">                    f[y] = f[x] + size[y], (g[y] = g[x]) %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i] &gt; mx) mx = f[i], sum = g[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (f[i] == mx)</span><br><span class="line">                (sum += g[i]) %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; mx &lt;&lt; endl &lt;&lt; sum % mod &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>ZJOI2007矩阵游戏</title>
    <url>/2019/02/01/zjoi2007%E7%9F%A9%E9%98%B5%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1129">[ZJOI2007]矩阵游戏</a> 二分图匹配。根据套路，以横纵坐标为点，点为边，点为黑建边。在题目要求的最终状态中，所有的点对(x, x)都是黑的，即每一对点都匹配了。所以判断最大匹配数==n即可。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>ZJOI2010排列计数</title>
    <url>/2019/05/29/zjoi2010%E6%8E%92%E5%88%97%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2606">[ZJOI2010]排列计数</a> 又双叒叕是一道不会做的题…..第一步模型转化就不会…..转化到的还是普及组模型…去打普及组了…………. 想一想有没有什么东西天生满足$p_i&gt;p_{i/2}$。没错，就是小根堆。所以这题就是求$[1,n]$的排列中满足小根堆性质的数量。 DP。$f[i]$表示大小为$i$的小根堆数量。 复习一下堆的性质：堆是满二叉树。所以给定堆的大小时，堆的形状已经确定了。堆的根一定是最小的值，左右子树虽然确定了节点数，但是不知道具体放了什么。设左边有$l$个，得到DP方程：$f[i]=C(i,l)*f[l]*f[i-l-1]$。 组合数用lucas定理可以求出来。重点考虑$l$怎么求。 我们在堆中插入新节点的顺序是先填满左子树的最后一层，再填右子树。一棵$k$层完美二叉树的节点数量是$2^k-1$，最后一层节点数量是$2^{k-1}$，除去最后一层的总节点数是$2^{k-1}-1$。 一棵节点数量为$n$的二叉树，最后一层节点数量为$n-(2^{\lfloor log_2n \rfloor}-1)$。如果最后一层左边全部填满，需要填$2^{\lfloor log_2n \rfloor-1}$个。比较它们的大小，选择新节点放在哪边即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fac[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>; x %= p;</span><br><span class="line">    <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = x * x % p)</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * x % p;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * <span class="built_in">fpow</span>(fac[m], p - <span class="number">2</span>, p) % p * <span class="built_in">fpow</span>(fac[n - m], p - <span class="number">2</span>, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lucas</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">C</span>(n % p, m % p, p) * <span class="built_in">lucas</span>(n / p, m / p, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, p;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line"></span><br><span class="line">    fac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % p;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">1</span>] = f[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>, l = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i - (<span class="number">1</span> &lt;&lt; (<span class="keyword">int</span>)<span class="built_in">log2</span>(i)) + <span class="number">1</span> &lt;= <span class="number">1</span> &lt;&lt; ((<span class="keyword">int</span>)<span class="built_in">log2</span>(i) - <span class="number">1</span>))</span><br><span class="line">            ++l;</span><br><span class="line">        f[i] = <span class="built_in">lucas</span>(i - <span class="number">1</span>, l, p) * f[l] % p * f[i - l - <span class="number">1</span>] % p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>ZJOI2010网络扩容</title>
    <url>/2019/03/28/zjoi2010%E7%BD%91%E7%BB%9C%E6%89%A9%E5%AE%B9/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2604">[ZJOI2010]网络扩容</a> 第一问好说跑个裸dinic。 第二问，可以用费用流解决。我们需要扩容一些边，于是在残量网络的基础上加边，边权INF，费用是扩容费用，然后建个新原点，流量是扩容流量限制一下，跑费用流。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">0</span>;<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))a=c==<span class="string">&#x27;-&#x27;</span>?<span class="number">0</span>:<span class="number">1</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))b=b*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a?b:-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2000</span>+<span class="number">233</span>,M=<span class="number">5000</span>*<span class="number">10</span>+<span class="number">233</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,dep[N],s,t,ans;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Input</span>&#123;</span><span class="keyword">int</span> x,y,c,w;&#125;in[M*<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>&#123;</span><span class="keyword">int</span> to,nxt,cost,flow;&#125;g[M*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N],tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> f,<span class="keyword">int</span> c=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    g[++tot].to=y,g[tot].nxt=head[x],</span><br><span class="line">    g[tot].flow=f,g[tot].cost=c,</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dep));</span><br><span class="line">    dep[s]=<span class="number">1</span>;</span><br><span class="line">    que.<span class="built_in">push_back</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=g[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!g[i].flowdep[g[i].to])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            dep[g[i].to]=dep[x]+<span class="number">1</span>;</span><br><span class="line">            que.<span class="built_in">push_front</span>(g[i].to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> mf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==t)<span class="keyword">return</span> mf;</span><br><span class="line">    <span class="keyword">int</span> tmp,used=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=g[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!g[i].flowdep[x]+<span class="number">1</span>!=dep[g[i].to])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        tmp=<span class="built_in">dfs</span>(g[i].to,<span class="built_in">min</span>(mf-used,g[i].flow));</span><br><span class="line">        <span class="keyword">if</span>(!tmp)dep[g[i].to]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> used+=tmp,g[i].flow-=tmp,g[i^<span class="number">1</span>].flow+=tmp;</span><br><span class="line">        <span class="keyword">if</span>(used==mf)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!used)dep[x]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())ret+=<span class="built_in">dfs</span>(s,INF);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dep));</span><br><span class="line">    dep[t]=<span class="number">0</span>;</span><br><span class="line">    vis[t]=<span class="literal">true</span>;</span><br><span class="line">    que.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop_front</span>();</span><br><span class="line">        vis[x]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=g[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!g[i^<span class="number">1</span>].flowdep[g[i].to]&lt;=dep[x]-g[i].cost)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            dep[g[i].to]=dep[x]-g[i].cost;</span><br><span class="line">            <span class="keyword">if</span>(vis[g[i].to])<span class="keyword">continue</span>;</span><br><span class="line">            vis[g[i].to]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(!que.<span class="built_in">empty</span>()&amp;&amp;dep[g[i].to]&gt;dep[que.<span class="built_in">front</span>()])</span><br><span class="line">                que.<span class="built_in">push_front</span>(g[i].to);</span><br><span class="line">            <span class="keyword">else</span> que.<span class="built_in">push_back</span>(g[i].to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[s]!=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> mf)</span></span>&#123;</span><br><span class="line">    vis[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==t) <span class="keyword">return</span> mf;</span><br><span class="line">    <span class="keyword">int</span> used=<span class="number">0</span>,tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=g[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[g[i].to]!g[i].flowdep[g[i].to]!=dep[x]-g[i].cost)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        tmp=<span class="built_in">dfs2</span>(g[i].to,<span class="built_in">min</span>(g[i].flow,mf-used));</span><br><span class="line">        <span class="keyword">if</span>(tmp)&#123;</span><br><span class="line">            ans+=tmp*g[i].cost;</span><br><span class="line">            g[i].flow-=tmp;</span><br><span class="line">            g[i^<span class="number">1</span>].flow+=tmp;</span><br><span class="line">            used+=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(used==mf)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">costflow</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        vis[t]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(vis[t])&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">            <span class="built_in">dfs2</span>(s,INF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>(),k=<span class="built_in">rd</span>();</span><br><span class="line">    s=<span class="number">1</span>,t=n;</span><br><span class="line">    tot=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        in[i].x=<span class="built_in">rd</span>(),in[i].y=<span class="built_in">rd</span>(),</span><br><span class="line">        in[i].c=<span class="built_in">rd</span>(),in[i].w=<span class="built_in">rd</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="built_in">addedge</span>(in[i].x,in[i].y,in[i].c);</span><br><span class="line">        <span class="built_in">addedge</span>(in[i].y,in[i].x,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">dinic</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="built_in">addedge</span>(in[i].x,in[i].y,INF,in[i].w);</span><br><span class="line">        <span class="built_in">addedge</span>(in[i].y,in[i].x,<span class="number">0</span>,-in[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">addedge</span>(n+<span class="number">1</span>,s,k,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">addedge</span>(s,n+<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    s=n+<span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">costflow</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>ZJOI2012灾难</title>
    <url>/2019/03/09/zjoi2012%E7%81%BE%E9%9A%BE/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2597">P2597 [ZJOI2012]灾难</a> 定义一个叫支配树的东西。大概可以理解为，给定一张有向图和一个起点$S$，一个点在支配树上的父节点，即是原图中从$S$到达这个点的必经点。很明显，要解决这个题，只需要求出原图的支配树。 求支配树有专门的算法，由Tarjan（没错又是他…）发明，时间复杂度瓶颈在并查集，所以是$O(n\alpha (n))$…然而这个算法是用来解决任意有向图的，对于DAG，我们有更简单的办法。 如果已经构建出了$x1,x2,…$在支配树上的位置，且原图中存在边$(x1,y),(x2,y),…$，那么在支配树上的$lca(x1,x2,…)$就是$y$的支配点。原因显然，这个点可以支配所有连向$y$的点，自然可以支配$y$。 所以我们可以一边拓扑排序，一边更新每个点的相关信息。使用倍增LCA即可。最后在支配树上DFS统计答案。注意这题有坑，需要建一个超级源点，因为有些动物同时吃多个生产者。复杂度$O(nlogn)$。 （Ps：挖个坑，改天写个支配树的Blog）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> to[N], nxt[N], head[N], tot;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            to[++tot] = y, nxt[tot] = head[x], head[x] = tot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; g1, g2, g3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, in[N];</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f[N / <span class="number">10</span>][<span class="number">22</span>], dep[N / <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[x] &lt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            <span class="keyword">if</span> (dep[f[x][i]] &gt;= dep[y])</span><br><span class="line">                x = f[x][i];</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            <span class="keyword">if</span> (f[x][i] != f[y][i])</span><br><span class="line">                x = f[x][i], y = f[y][i];</span><br><span class="line">        <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (in[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                ++in[i];</span><br><span class="line">                g1.<span class="built_in">addedge</span>(<span class="number">0</span>, i);</span><br><span class="line">                g2.<span class="built_in">addedge</span>(i, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        que.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = g1.head[x]; i; i = g1.nxt[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = g1.to[i];</span><br><span class="line">                <span class="keyword">if</span> (--in[y] == <span class="number">0</span>) que.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> lca = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = g2.head[x]; i; i = g2.nxt[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = g2.to[i];</span><br><span class="line">                <span class="keyword">if</span> (lca == <span class="number">-1</span>) lca = y;</span><br><span class="line">                <span class="keyword">else</span> lca = <span class="built_in">query</span>(lca, y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            g3.<span class="built_in">addedge</span>(lca, x);</span><br><span class="line">            f[x][<span class="number">0</span>] = lca;</span><br><span class="line">            dep[x] = dep[lca] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; ++i)</span><br><span class="line">                f[x][i] = f[f[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size[N / <span class="number">10</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        size[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = g3.head[x]; i; i = g3.nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = g3.to[i];</span><br><span class="line">            <span class="built_in">dfs</span>(y);</span><br><span class="line">            size[x] += size[y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, tmp; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">while</span> ((tmp = <span class="built_in">rd</span>()) != <span class="number">0</span>) &#123;</span><br><span class="line">                g1.<span class="built_in">addedge</span>(tmp, i);</span><br><span class="line">                g2.<span class="built_in">addedge</span>(i, tmp);</span><br><span class="line">                ++in[i];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">toposort</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, size[i] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>ZJOI2013K大数查询 整体二分</title>
    <url>/2019/08/08/zjoi2013k%E5%A4%A7%E6%95%B0%E6%9F%A5%E8%AF%A2-%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P3332">[ZJOI2013]K大数查询</a> 我！！！！！！自！！！！！！！！！！！闭！！！！！！！！！！了！！！！！！！！！！！ 调了一下午代码！！！！！！！！！！！！！！！！！！！！！！ 首先这题题意不清。一个位置可以有多个数叠加，然后数是不能相加的。 这题可以树套树，也可以整体二分。 整体二分的时候，用线段树维护区间比$mid$小的数的个数。每次如果$C \leq mid$，加上$1$。把操作序列分为左右两部分递归处理。 至于为什么卡了一下午嘛。。。。。。。。。 因为偷懒，开了个新数组$tmp$直接把原序列复制过来。用了两个指针在$ql,qr$，每次$ql++,qr–$。这就导致右边的序列被反转了。。。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50000</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> type, id, l, r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> k;</span><br><span class="line">&#125; op[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum, tag;</span><br><span class="line">&#125; t[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(p) p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(p) p &lt;&lt; 1  1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    t[p].sum = t[<span class="built_in">ls</span>(p)].sum + t[<span class="built_in">rs</span>(p)].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[p].tag) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        t[<span class="built_in">ls</span>(p)].sum += (<span class="keyword">long</span> <span class="keyword">long</span>)(mid - l + <span class="number">1</span>) * t[p].tag;</span><br><span class="line">        t[<span class="built_in">rs</span>(p)].sum += (<span class="keyword">long</span> <span class="keyword">long</span>)(r - mid) * t[p].tag;</span><br><span class="line">        t[<span class="built_in">ls</span>(p)].tag += t[p].tag;</span><br><span class="line">        t[<span class="built_in">rs</span>(p)].tag += t[p].tag;</span><br><span class="line">        t[p].tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R) &#123;</span><br><span class="line">        t[p].sum += (<span class="keyword">long</span> <span class="keyword">long</span>)(R - L + <span class="number">1</span>) * v;</span><br><span class="line">        t[p].tag += v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p, L, R);</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">add</span>(<span class="built_in">ls</span>(p), l, r, v, L, mid);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) <span class="built_in">add</span>(<span class="built_in">rs</span>(p), l, r, v, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R) <span class="keyword">return</span> t[p].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(p, L, R);</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) ret += <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r, L, mid);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) ret += <span class="built_in">query</span>(<span class="built_in">rs</span>(p), l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql &gt; qr) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ql; i &lt;= qr; ++i)</span><br><span class="line">            ans[op[i].id] = l;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, x = ql, y = qr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ql; i &lt;= qr; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (op[i].type == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (op[i].k &gt; mid) tmp[y--] = op[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">add</span>(<span class="number">1</span>, op[i].l, op[i].r, <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">                tmp[x++] = op[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="built_in">query</span>(<span class="number">1</span>, op[i].l, op[i].r, <span class="number">1</span>, n);</span><br><span class="line">            <span class="keyword">if</span> (op[i].k &lt;= cnt) tmp[x++] = op[i];</span><br><span class="line">            <span class="keyword">else</span> tmp[y] = op[i], tmp[y--].k -= cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ql; i &lt; x; ++i)</span><br><span class="line">        <span class="keyword">if</span> (tmp[i].type == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">1</span>, tmp[i].l, tmp[i].r, <span class="number">-1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ql; i &lt; x; ++i) op[i] = tmp[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x, j = qr; i &lt;= qr; ++i, --j) op[i] = tmp[j];</span><br><span class="line">    <span class="built_in">solve</span>(ql, x - <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">solve</span>(x, qr, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %lld&quot;</span>, &amp;op[i].type, &amp;op[i].l, &amp;op[i].r, &amp;op[i].k);</span><br><span class="line">        <span class="keyword">if</span> (op[i].type == <span class="number">1</span>) op[i].k *= <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> op[i].id = ++tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>, m, -n, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, -ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>ZJOI2014力</title>
    <url>/2019/07/01/zjoi2014%E5%8A%9B/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3338">[ZJOI2014]力</a> $$E_j = \sum_{i&lt;j}\frac{q_j}{(i-j)^2} - \sum_{i&gt;j}\frac{q_j}{(i-j)^2}$$ $$E_j = \sum_{i=1}^{j-1}\frac{q_j}{(i-j)^2} - \sum_{i=j+1}^{n}\frac{q_j}{(i-j)^2}$$ $$f(x)=q_x,f’(x)=f(n-x+1),g(x)=\frac{1}{x^2}$$ $$E_j = \sum_{i=1}^{j-1}f(i)g(j-i) - \sum_{i=1}^{j-1}f’(i)g(j-i)$$ 看着像卷积，然而是$j-1$不是$j$，然后题解们在这里都一笔带过了（其实是我菜）。 实际上，下标从$1$不从$0$开始的原因就是这个：对于多出来的$j$，空成$0$就可以。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> * <span class="number">4</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = std::<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; <span class="keyword">double</span> a[N];</span><br><span class="line"><span class="keyword">int</span> rev[N], lim = <span class="number">1</span>, L;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> _x = <span class="number">0</span>, <span class="keyword">double</span> _y = <span class="number">0</span>) &#123;</span><br><span class="line">        x = _x; y = _y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">complex <span class="keyword">operator</span>+(<span class="keyword">const</span> complex &amp;a, <span class="keyword">const</span> complex &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(a.x + b.x, a.y + b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complex <span class="keyword">operator</span>-(<span class="keyword">const</span> complex &amp;a, <span class="keyword">const</span> complex &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(a.x - b.x, a.y - b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complex <span class="keyword">operator</span>*(<span class="keyword">const</span> complex &amp;a, <span class="keyword">const</span> complex &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fast_Fast_TLE</span><span class="params">(complex f[], <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i])</span><br><span class="line">            std::<span class="built_in">swap</span>(f[i], f[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">complex <span class="title">T</span><span class="params">(std::cos(PI / i), o * std::sin(PI / i))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += (i &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="function">complex <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k, w = w * T) &#123;</span><br><span class="line">                complex nx = f[j + k], ny = w * f[i + j + k];</span><br><span class="line">                f[j + k] = nx + ny;</span><br><span class="line">                f[i + j + k] = nx - ny;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complex A[N], B[N], C[N];</span><br><span class="line"><span class="keyword">double</span> x[N], y[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lim &lt;= n &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; ++i)</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>)  ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, a + i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        B[i].x = <span class="number">1.0</span> / i / i; <span class="comment">// 写成(i * i) -&gt; WA</span></span><br><span class="line">    <span class="built_in">Fast_Fast_TLE</span>(B, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        A[i].x = a[i];</span><br><span class="line">    <span class="built_in">Fast_Fast_TLE</span>(A, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        C[i] = A[i] * B[i];</span><br><span class="line">    <span class="built_in">Fast_Fast_TLE</span>(C, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        x[i] = C[i].x / lim;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        A[i] = C[i] = <span class="built_in">complex</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        A[i].x = a[n - i + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">Fast_Fast_TLE</span>(A, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        C[i] = A[i] * B[i];</span><br><span class="line">    <span class="built_in">Fast_Fast_TLE</span>(C, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        y[i] = C[i].x / lim;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, x[i] - y[n - i + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>ZJOI2015 幻想乡战略游戏</title>
    <url>/2019/07/29/zjoi2015-%E5%B9%BB%E6%83%B3%E4%B9%A1%E6%88%98%E7%95%A5%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P3345">[ZJOI2015] 幻想乡战略游戏</a> 由于蒟蒻不会（调不出来）动态点分治，写了树剖线段树，然后跑的特别快，先来看看效果= =</p>
<span id="more"></span>
<p><img src="https://baka.online/wp-content/uploads/2019/07/www.luogu_.org_record_list_pidP3345orderBy1statuspage1.png"> 这篇题解是发Luogu题解的，所以写的详细= =</p>
<hr>
<h4 id="一个结论：-本题中，重心位置和点权，边权无关"><a href="#一个结论：-本题中，重心位置和点权，边权无关" class="headerlink" title="一个结论： 本题中，重心位置和点权，边权无关"></a>一个结论： 本题中，重心位置和点权，边权无关</h4><p>看起来不可思议吧。</p>
<h5 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h5><p>我们可以换一种方式计算答案。枚举边$edge_i$，这条边把树分为两部分。它的两端点是$x_i,y_i$，两子树的大小为$size_x,size_y$，那么有： $$ans=\sum edge_i * size_x * size_y$$ 通过直接构造出重心位置，并证明其它位置不比它更优证明结论： 在树上选一个点，使得它最大的子树大小（子树内军队数量）最小。这个点就是重心。 可以任选一个其它点，计算出以这个点为补给站的答案。考虑把选择的点向重心移动一条边对答案的影响。这条边是$edge$，两边为$x,y$，大小分别为$size_x,size_y$。从$x$走到$y$。 由推导出的新计算式，只有移动经过的这条边对答案产生的贡献发生了变化，是： $$-edge * size_y + edge * size_x$$ 显然，因为这个点不在我们选出的重心，$size_y$不可能小于$size_x$，即，让答案更优了。 <strong>实际上，这个点和普通不带权树的重心位置一样。</strong></p>
<h4 id="快速找到重心"><a href="#快速找到重心" class="headerlink" title="快速找到重心"></a>快速找到重心</h4><p>在树上找到一个点$x$，满足$size_{root} \leq size_x * 2$，且$x$最深。 这个结合普通树重心性质很容易得出，不证了。 线段树叶子维护子树大小，其他节点维护线段树上子节点大小最大值。查询的时候在线段树上二分。</p>
<h4 id="求答案"><a href="#求答案" class="headerlink" title="求答案"></a>求答案</h4><p>$$ans=\sum dis(x,y) * e(y)$$ $$=\sum (dis(x,root)+dis(y,root)-2* dis(lca,root)) * e(y)$$ $$=\sum dis(x,root)* e(y) + \sum dis(y,root) * e(y) -2\sum dis(lca,root) * e(y)$$ 前两个随便维护，重点是第三个。 令点权为$w_x=edge(x,fa(x))$，每次修改一个点的时候，就把它到根的大小$size$全部加上修改的值。查询重心到根，每个点$size_x * w_x$。 这是因为两个点到lca到根的路径，是两个点到根的共同路径。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span> <span class="keyword">int</span> to, nxt, cost; &#125; g[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    g[++tot].to = y, g[tot].nxt = head[x],</span><br><span class="line">    g[tot].cost = c, head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N], son[N], size[N], dep[N], dis[N];</span><br><span class="line"><span class="keyword">int</span> top[N], id[N], wh[N], wt[N], num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="keyword">if</span> (y != fa[x]) &#123;</span><br><span class="line">            fa[y] = x; dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">            dis[y] = dis[x] + g[i].cost;</span><br><span class="line">            size[y] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs1</span>(y);</span><br><span class="line">            <span class="keyword">if</span> (size[son[x]] &lt; size[y])</span><br><span class="line">                son[x] = y;</span><br><span class="line">            size[x] += size[y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line">    top[x] = topf; id[x] = ++num; wh[num] = x;</span><br><span class="line">    wt[num] = dis[x] - dis[fa[x]];</span><br><span class="line">    <span class="keyword">if</span> (son[x]) &#123;</span><br><span class="line">        <span class="built_in">dfs2</span>(son[x], topf);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">            <span class="keyword">if</span> (y != fa[x] &amp;&amp; y != son[x])</span><br><span class="line">                <span class="built_in">dfs2</span>(y, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(p) p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(p) p &lt;&lt; 1  1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sz[N * <span class="number">4</span>], tag[N * <span class="number">4</span>];</span><br><span class="line">LL edge[N * <span class="number">4</span>], sum[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        edge[p] = wt[L];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(p), L, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, R);</span><br><span class="line">    edge[p] = edge[<span class="built_in">ls</span>(p)] + edge[<span class="built_in">rs</span>(p)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    sz[p] = std::<span class="built_in">max</span>(sz[<span class="built_in">ls</span>(p)], sz[<span class="built_in">rs</span>(p)]);</span><br><span class="line">    sum[p] = sum[<span class="built_in">ls</span>(p)] + sum[<span class="built_in">rs</span>(p)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag[p]) &#123;</span><br><span class="line">        sz[<span class="built_in">ls</span>(p)] += tag[p];</span><br><span class="line">        sz[<span class="built_in">rs</span>(p)] += tag[p];</span><br><span class="line">        tag[<span class="built_in">ls</span>(p)] += tag[p];</span><br><span class="line">        tag[<span class="built_in">rs</span>(p)] += tag[p];</span><br><span class="line">        sum[<span class="built_in">ls</span>(p)] += (LL)tag[p] * edge[<span class="built_in">ls</span>(p)];</span><br><span class="line">        sum[<span class="built_in">rs</span>(p)] += (LL)tag[p] * edge[<span class="built_in">rs</span>(p)];</span><br><span class="line">        tag[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R) &#123;</span><br><span class="line">        sz[p] += v; tag[p] += v;</span><br><span class="line">        sum[p] += (LL)v * edge[p];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">        <span class="built_in">add</span>(<span class="built_in">ls</span>(p), l, r, v, L, mid);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">        <span class="built_in">add</span>(<span class="built_in">rs</span>(p), l, r, v, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R)</span><br><span class="line">        <span class="keyword">return</span> sum[p];</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">        ret += <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r, L, mid);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">        ret += <span class="built_in">query</span>(<span class="built_in">rs</span>(p), l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>, L = <span class="number">1</span>, R = n;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(p);</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (sz[<span class="built_in">rs</span>(p)] * <span class="number">2</span> &gt;= sz[<span class="number">1</span>])</span><br><span class="line">            L = mid + <span class="number">1</span>, p = <span class="built_in">rs</span>(p);</span><br><span class="line">        <span class="keyword">else</span> R = mid, p = <span class="built_in">ls</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wh[L];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">range_add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">1</span>, id[top[x]], id[x], y, <span class="number">1</span>, n);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">1</span>, id[x], y, <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">range_query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != <span class="number">1</span>) &#123;</span><br><span class="line">        ret += <span class="built_in">query</span>(<span class="number">1</span>, id[top[x]], id[x], <span class="number">1</span>, n);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret + <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, id[x], <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL sum_dis_e, sum_e;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">getans</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum_dis_e + dis[x] * sum_e - <span class="number">2</span> * <span class="built_in">range_query</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(); m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>(), c = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">addedge</span>(x, y, c);</span><br><span class="line">        <span class="built_in">addedge</span>(y, x, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>); <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">        sum_e += y;</span><br><span class="line">        sum_dis_e += (LL)dis[x] * y;</span><br><span class="line">        <span class="built_in">range_add</span>(x, y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">getans</span>(<span class="built_in">weight</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>THUWC/SC 乱做</title>
    <url>/2019/12/16/thuwc-sc-%E4%B9%B1%E5%81%9A/</url>
    <content><![CDATA[<h2 id="在美妙的数学王国中畅游"><a href="#在美妙的数学王国中畅游" class="headerlink" title="在美妙的数学王国中畅游"></a>在美妙的数学王国中畅游</h2><p>这题给了泰勒展开确不给求导，emmmm…这两个应该是一起学的吧… 考虑泰勒展开，然后用LCT维护链上的系数和。 选择合适的位置展开是很重要的。我们可以无视$ax+b$，直接按$x$展开，然后带入$ax+b$应用二项式定理。 发现展开很多次之后精度就满足了要求，于是我们只需要维护一个前一些项（15次左右）的多项式即可。</p>
<h2 id="随机二分图"><a href="#随机二分图" class="headerlink" title="随机二分图"></a>随机二分图</h2><p>考虑一个状压DP。$f_{s_1,s_2}$表示左右分别为$s_1,s_2$的方案数。 如果只有$t=0$，可枚举加入哪条边计算。每条边的边权是$\frac{1}{2}$。 当$t=1$，把两条边分别加入。发现如果只有一条边对答案产生了贡献，是正确的。然而一起选的时候会边少，可以考虑加入一条“边”，强制一次把两条边都选上，边权为$\frac{1}{4}$。 对于$t=3$，是$-\frac{1}{4}$。 发现状态存不下。冷静分析一下， 有用的状态不多，记搜就行了。</p>
<h2 id="大葱的神力"><a href="#大葱的神力" class="headerlink" title="大葱的神力"></a>大葱的神力</h2><p>神仙乱搞题，告辞。</p>
<hr>
<h2 id="补退选"><a href="#补退选" class="headerlink" title="补退选"></a>补退选</h2><p>Trie树，每个点开个vector存一下第一次达到某状态的时间。</p>
<h2 id="成绩单"><a href="#成绩单" class="headerlink" title="成绩单"></a>成绩单</h2><p>一开始yy了一个DP：定义$f_{l,r,k}$表示$[l,r]$，选了$k$次。$O(n^5)$转移。 然后发现是假的，两次选的区间不一定交。 热动分析发现转移代价只和$\min , \max$有关。那么定义$f_{l,r,a,b}$表示$[l,r]$，删了一些，现在$\min, \max$分别为$a,b$的答案。 再定义$g_{l,r}$为$[l,r]$的答案。 $$f_{l,r, \min \lbrace a, w_r \rbrace, \max \lbrace b, w_r \rbrace} \leftarrow f_{l,r - 1,a,b} $$ $$f_{l,r,a,b} \leftarrow f_{l,k,a,b} + g_{k+1,r} $$ $$g_{l,r} \leftarrow f_{l,r,a,b} + A + B(b-a)^2$$</p>
<h2 id="星露谷物语"><a href="#星露谷物语" class="headerlink" title="星露谷物语"></a>星露谷物语</h2><p>神仙题，溜了溜了qaq</p>
<hr>
<h2 id="巧克力"><a href="#巧克力" class="headerlink" title="巧克力"></a>巧克力</h2><p>二分一下中位数，给大于小于的分别赋一个略大一点，略小一点的值，求最小方案即可判断。 考虑如果颜色很少怎么做。要会斯坦纳树。然后就可以暴力状压了。 如果颜色很多，把颜色随机映射到$[1,k]$，随机很多次的正确率是很高的。</p>
<h2 id="杜老师"><a href="#杜老师" class="headerlink" title="杜老师"></a>杜老师</h2><p>遇到完全平方考虑出现次数是奇数的因子。线性基直接做，如果线性基里有$x$个元素，答案就是$2^{r-l+1-x}$。 但是线性基直接做会TLE。那么根据套路应该考虑根号，大于根号的因子只会出现一次，维护有没有在线性基里出现过。小的做暴力线性基。</p>
<h2 id="换桌"><a href="#换桌" class="headerlink" title="换桌"></a>换桌</h2><p>明显是网络流，可以把可以到达的点都暴力连边。 题目是区间操作，自然想到线段树优化。 具体来说，每个位置的座位建两棵线段树，分别表示向左向右走。</p>
<h2 id="大魔法师"><a href="#大魔法师" class="headerlink" title="大魔法师"></a>大魔法师</h2><p>既然是区间操作，线段树维护。线段树标记的特性之一就是可以合并。题目中的操作都很简单，可以用矩阵维护，而矩阵有结合率。</p>
<h2 id="如果奇迹有颜色"><a href="#如果奇迹有颜色" class="headerlink" title="如果奇迹有颜色"></a>如果奇迹有颜色</h2><p>是橙色！！！ 不会BM也不会Polya，告辞</p>
<h2 id="宇宙广播"><a href="#宇宙广播" class="headerlink" title="宇宙广播"></a>宇宙广播</h2><p>不会计算几何，告辞</p>
<hr>
<h3 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h3><p>发了个洛谷题解233 异或$k$大问题当然是一位一位算啦～枚举每一位，算可能的答案中这一位有多少$0$有多少$1$就好。 发现结果和行，列都有关，且$n$很小，可以考虑枚举行，计算这一行有多少满足要求的。 对$Y$建一棵可持久化Trie，询问的时候每一行维护一下走到了Trie的哪里，根据$01$数量决定走哪边就好了。</p>
<h3 id="平方运算"><a href="#平方运算" class="headerlink" title="平方运算"></a>平方运算</h3><p>模数给了这么多很有意思，乱搞平方会进入循环（$\rho$形），循环节都不长。打表（看题解）可知，循环节的$\rm{lcm} \leq 60$，于是可以考虑维护区间的整个循环节。对于进入循环节与没进入循环节分类讨论，乱搞就行了。</p>
<h3 id="解密运算"><a href="#解密运算" class="headerlink" title="解密运算"></a>解密运算</h3><p>可以把原串变成环，然后对于一个字符，确定它前面的字符是什么。 题目给出的信息可以让我们知道两件事，一是这个数是什么，二是这个数的下一个数的排名是多少。 假装所有字符都不一样，那么每个字符的排名确认，就很好做了。我们对输入排序，从$0$按排名跳。 如果存在相同字符，考虑如何区分排名。当首字母相同的时候，我们比较下一个字母。考虑两个相同字符，一个在另一个前面，那么在排序的时候它的串一定比另一个串小。于是按第二关键字是输入顺序排序就做完了。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>ZJOI2015诸神眷顾的幻想乡</title>
    <url>/2019/06/18/zjoi2015%E8%AF%B8%E7%A5%9E%E7%9C%B7%E9%A1%BE%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3346">[ZJOI2015]诸神眷顾的幻想乡</a> 15年某集训队论文里钦定的题。 树上一端路径，一定可以看作一个点为根向下走到某个叶子，这条路径上的其中一段。题目有个非常强的条件：叶子不超过20个，即线性的。 枚举叶子为根，dfs整个树，把树当作trie，插进SAM，就是个广义SAM。其实貌似这样点比较多，不一定线性，bfs才行，不过貌似没人卡= = 不同子串数量，就是len[x]-len[fa[x]]。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span>, M = N * <span class="number">20</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, s[N], in[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt; </span><br><span class="line">&#125; g[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    g[++cnt].to = y, g[cnt].nxt = head[x],</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[M], ch[M][<span class="number">11</span>], len[M], tot = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> np = ++tot; len[np] = len[p] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; !ch[p][c])</span><br><span class="line">        ch[p][c] = np, p = fa[p];</span><br><span class="line">    <span class="keyword">if</span> (!p) fa[np] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> q = ch[p][c];</span><br><span class="line">        <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)</span><br><span class="line">            fa[np] = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> nq = ++tot;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="built_in"><span class="keyword">sizeof</span></span>(ch[q]));</span><br><span class="line">            len[nq] = len[p] + <span class="number">1</span>;</span><br><span class="line">            fa[nq] = fa[q];</span><br><span class="line">            fa[q] = fa[np] = nq;</span><br><span class="line">            <span class="keyword">while</span> (p &amp;&amp; ch[p][c] == q)</span><br><span class="line">                ch[p][c] = nq, p = fa[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> np;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pp = <span class="built_in">insert</span>(s[x], p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (g[i].to != f)</span><br><span class="line">            <span class="built_in">dfs</span>(g[i].to, x, pp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(); m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) s[i] = <span class="built_in">rd</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">        ++in[x]; ++in[y];</span><br><span class="line">        <span class="built_in">addedge</span>(x, y);</span><br><span class="line">        <span class="built_in">addedge</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (in[i] == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">dfs</span>(i, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">        ans += len[i] - len[fa[i]];</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(); <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>【UER</title>
    <url>/2020/03/01/%E3%80%90uer-8%E3%80%91%E9%9B%AA%E7%81%BE%E4%B8%8E%E5%A4%96%E5%8D%96-%E6%A8%A1%E6%8B%9F%E8%B4%B9%E7%94%A8%E6%B5%81/</url>
    <content><![CDATA[<p><a href="http://uoj.ac/contest/47/problem/455">【UER #8】雪灾与外卖</a> 模拟费用流板子题。 首先可以建立一个简单费用流模型。把点按坐标排序后，不难发现，最终匹配方案不交叉。 那么可以考虑将两类点排序，对费用流的过程进行模拟。模拟的难点在于退流。 考虑一个$x$点。先把它向左边没用匹配的$y$中最优秀的匹配。它的贡献是$x_i+v_j$，其中$v_j$是$y_j$的贡献。 如果在之后将$x_i$现在的匹配退流，那么代价是$-2x_i-v_j$。 考虑一个$y$点。先不管$c$，把一个点拆成$c$个点考虑。让$y$尝试匹配之前的一个$x$。那么贡献是$y_i+w_i+v_j$，其中$v$是之前的代价。 在$y$点退流之后，有一些$x$的匹配改变了。但是明显这些$x$还可以继续改变。此次改变的代价变成了$-y_i-w_i$。 实际上这一过程就是维护两个堆，分别表示两类点，然后做贪心的匹配。时间复杂度$O((n+\sum c)log(n+\sum c))$。 这个是不太过得去的，考虑优化，去掉拆点。可以发现，瓶颈在于每次$y$退流后push的新$x$。发现$c$次push的代价都一样。合并起来，退完后一次性push进去就行了。 复杂度愉快的变成了$O((n+m)log(n+m))$</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>【UR</title>
    <url>/2019/10/03/%E3%80%90ur-5%E3%80%91%E6%80%8E%E6%A0%B7%E6%8F%90%E9%AB%98%E6%99%BA%E5%95%86-%E6%99%BA%E5%95%86/</url>
    <content><![CDATA[<p><a href="http://uoj.ac/contest/7/problem/60">【UR #5】怎样提高智商</a> <strong>一天，kai586123又在模拟赛爆零了，她很伤心</strong> <strong>她去寻找提高智商的方法</strong> <strong>kai586123发现了一枚大师，她问：</strong> <strong>“如何提高智商？”</strong> <strong>大师微微一笑：“去A掉这个题”</strong> <strong>于是她就去看了这个题，然而还是不会</strong> <strong>她因为智商太低，终于退役了</strong> 解法：答案是$4 \times 3^{n-1}$，每一道题都是问$A$，四个选项都是$0$，这样前$n-1$道题都可以选$BCD$，最后一道题可以选$ABCD$。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>一个反演题 反演</title>
    <url>/2019/10/03/%E4%B8%80%E4%B8%AA%E5%8F%8D%E6%BC%94%E9%A2%98-%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>$$\sum_{a=1}^n \sum_{b=1}^n [lcm(a,b) &gt; n]$$ $n \leq 10^{10}$</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>$$\sum_{a=1}^n \sum_{b=1}^n [lcm(a,b) &gt; n]$$ $$=n^2 - \sum_{a=1}^n \sum_{b=1}^n [lcm(a,b) \leq n]$$ $$\sum_{a=1}^n \sum_{b=1}^n [lcm(a,b) \leq n]$$ $$=\sum_{a=1}^n \sum_{b=1}^n [\frac{ab}{gcd(a,b)} \leq n]$$ 令$d=gcd(a,b)$ $$=\sum_{a=1}^n \sum_{b=1}^n [\frac{ab}{d} \leq n]$$ $$=\sum_{d=1}^n \sum_{a=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{b=1}^{\lfloor \frac{n}{d} \rfloor} [abd \leq n] [gcd(a,b)=1]$$ $$=\sum_{d=1}^n \sum_{a=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{b=1}^{\lfloor \frac{n}{d} \rfloor} [d \leq \frac{n}{ab}] [gcd(a,b)=1]$$ 发现后面的$gcd$和$d$没有关系，可以直接求有多少个 $$=\sum_{a=1}^n \sum_{b=1}^n [gcd(a,b) = 1] \lfloor \frac{n}{ab} \rfloor$$ 进行一个反演 $$=\sum_{a=1}^n \sum_{b=1}^n \sum_{d \mid a,b} \mu(d) \lfloor \frac{n}{ab} \rfloor$$ $$=\sum_{d = 1}^n \mu(d) \sum_{a=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{b=1}^{\lfloor \frac{n}{d} \rfloor} \lfloor \frac{n}{adbd} \rfloor$$ $$=\sum_{d = 1}^n \mu(d) \sum_{a=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{b=1}^{\lfloor \frac{n}{d} \rfloor} \lfloor \frac{\lfloor \frac{n}{d^2} \rfloor }{ab} \rfloor$$ 可以发现，$a,b$枚举范围过大是没有用的。更改$a,b$后，$d$也可以随之更改范围 $$=\sum_{d = 1}^{\sqrt n} \mu(d) \sum_{a=1}^{\lfloor \frac{n}{d^2} \rfloor} \sum_{b=1}^{\lfloor \frac{n}{d^2} \rfloor} \lfloor \frac{\lfloor \frac{n}{d^2} \rfloor }{ab} \rfloor$$ 设一个$f(x)$ $$f(x) = \sum_{a=1}^x \sum_{b=1}^x \lfloor \frac{x }{ab} \rfloor$$ 推一下$f(x)$的式子： $$f(x) = \sum_{a=1}^x \sum_{b=1}^x \lfloor \frac{ \lfloor \frac{x}{a} \rfloor }{b} \rfloor$$ 再设一个$g(x)$： $$g(x) = \sum_{i=1}^x \lfloor \frac{x}{i} \rfloor$$ 有一个这样的式子可以用： $$ \sum_{i=1}^x \lfloor \frac{x}{i} \rfloor = \sum_{i=1}^x d(i)$$ 其中$d(i)$表示$i$有多少约数。 证明： $$\sum_{a=1}^n d(a) = \sum_{a=1}^n \sum_{b \mid a} 1 = $$ $$=\sum_{b=1}^n \sum_{a=1}^{\lfloor \frac{n}{b} \rfloor} 1 = \sum_{b=1}^n \lfloor \frac{n}{b} \rfloor $$ 然后$d$是积性函数，可以线性筛的。我们预处理$[1,n^{\frac{2}{3&#125;&#125;]$的$d$。对于计算$x &gt; n^{\frac{2}{3&#125;&#125;$的$g(x)$的时候，多余的部分直接整除分块就可以了。 积分不熟，以下部分参考了<a href="https://blog.csdn.net/a_crazy_czy/article/details/53106627">这里</a> 复杂度计算： $$\int_1^{n^\frac{1}{3&#125;&#125; \sqrt \frac{n}{x} dx$$ $$= \sqrt n \int_1^{n^\frac{1}{3&#125;&#125; x^{-\frac{1}{2&#125;&#125; dx$$ $$= \sqrt n (2(n^{\frac{1}{3&#125;&#125;)^{\frac{1}{2&#125;&#125; - 2)$$ $$= O(n^{\frac{2}{3&#125;&#125;)$$ 这样，计算一次$f(n)$的复杂度是$O(n^{\frac{2}{3&#125;&#125;)$ 然而我们发现，$f(x)$算了$\sqrt n$次。计算总复杂度如下： $$\int_{1}^{\sqrt n} (\frac{n}{x^2})^{\frac{2}{3&#125;&#125; dx$$ $$= n^{\frac{2}{3&#125;&#125; \int_1^{\sqrt n} x^{-\frac{3}{4&#125;&#125; dx $$ $$= n^{\frac{2}{3&#125;&#125; (-3n^{-\frac{1}{6&#125;&#125; + 3)$$ $$= O(n^{\frac{2}{3&#125;&#125;)$$ 于是就做完了。（迫真noip模拟题</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>一般图最大匹配</title>
    <url>/2020/03/14/%E4%B8%80%E8%88%AC%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p><a href="http://uoj.ac/problem/79">一般图最大匹配</a> 比较摸，不是很有学带花树的动力，网上冲浪冲到了随机算法： 首先如果给定的图没有环，直接做类似二分图匹配的匈牙利肯定是对的。如果图中的环都是偶数，增广一下也不会有问题。（二分图就是偶环） 但是如果图中有奇环，可以发现绕环增广会挂掉。。 举个例子，一个大小为$3$的环，选了其中一条边。把环上所有边取反，就冲突了。 那么怎么做呢？可以发现如果可以钦定增广边的时候的顺序，那么其实直接每次把匹配边找出来就行了。 这个顺序不是很清楚，但是我们可以进行多个轮，每次随机一下出边再匹配，随机次数足够多的话有很大的概率是对的。 <a href="http://bzoj.blog.uoj.ac/blog/2427">这里是Hack方法</a> 对随机法进行一些优化：不采用开始前随机，而采用在DFS内部每次随机。每一轮不清空匹配数组。用时间戳优化复杂度。事实证明这样甚至可以过掉UOJ上的Hack数据..</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans[N], vis[N], link[N], cnt, now;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  vis[x] = id;</span><br><span class="line">  std::<span class="built_in">random_shuffle</span>(G[x].<span class="built_in">begin</span>(), G[x].<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y : G[x]) &#123;</span><br><span class="line">    <span class="keyword">int</span> z = link[y];</span><br><span class="line">    <span class="keyword">if</span> (vis[z] == id)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    link[x] = y; link[y] = x;</span><br><span class="line">    link[z] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!z  <span class="built_in">dfs</span>(z, id))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    link[y] = z; link[z] = y;</span><br><span class="line">    link[x] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">    G[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    G[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x)</span><br><span class="line">      <span class="keyword">if</span> (!link[x])</span><br><span class="line">        <span class="built_in">dfs</span>(x, x);</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">      now += (<span class="keyword">bool</span>)(link[j]);</span><br><span class="line">    <span class="keyword">if</span> (now &gt; cnt) &#123;</span><br><span class="line">      cnt = now;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        ans[j] = link[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>Update：带花树（真香 随机匹配其实挺好的，就是跑的慢。所以还是需要稳定优秀的Blossom Algorithm。 首先想一下二分图最大匹配是怎么玩的：</p>
<ol>
<li>定义增广路。即未匹配边和匹配边交替出现的一条路径。增广路取反后答案+1。</li>
<li>增广路定理。找不到增广路的时候就是最大匹配。</li>
</ol>
<p>这两个并不是定义在二分图上的。所以一般图匹配的步骤也是这样的：</p>
<ol>
<li>枚举每个点</li>
<li>找这个点出发的增广路并更新</li>
<li>枚举下一个点</li>
</ol>
<p>所以问题就变成了找一个点出发的增广路。考虑对图染色。从一个黑点出发，把路径染成一黑一白的样子。那么图就有三种点：黑，白，未染色。</p>
<ol>
<li>考虑搜索路径。如果当前在黑点，并且搜到了一个白点，那么可以直接忽略这个点。</li>
<li>如果搜到了一个未染色点，考虑这个点是不是匹配点。如果不是匹配点，说明找到了增广路。</li>
<li>如果是匹配点，那么钦定它是白色，并移动到它匹配的另一个点上，染黑色，继续。</li>
<li>如果图中存在奇环，会遇到两个黑点相邻的情况。考虑环上有一条到外面的路，发现无论起点是什么颜色，都可以走出去。也就是说环上每个点都应该是黑点。</li>
</ol>
<p>定义一个$2k+1$大小，$k$条匹配边的奇环为<strong>花</strong>。花中的未匹配点为<strong>花托</strong>。因为整个花都是黑点，定义<strong>缩花</strong>操作为把花缩成一个点。因为每次至少缩两个点，操作次数是线性的。 思路就是这样的，下面说一下算法细节：</p>
<ol>
<li>BFS遍历图，染色</li>
<li>找到奇环时，找到两点的LCA，并缩花</li>
<li>因为有一个遍历的过程，维护pre[]，表示返回时要返回到哪里</li>
<li>不执行实际的缩花操作，用并查集维护</li>
</ol>
<p>之后看代码吧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, match[N], pre[N], ans;</span><br><span class="line"><span class="keyword">int</span> col[N], fa[N];</span><br><span class="line"><span class="keyword">int</span> que[N], head, tail;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴力找LCA，交替爬升</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> hash[N], hash_cnt;</span><br><span class="line">  ++hash_cnt;</span><br><span class="line">  <span class="keyword">while</span> (hash[x] != hash_cnt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x) hash[x] = hash_cnt, x = <span class="built_in">find</span>(pre[match[x]]);</span><br><span class="line">    std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码照搬了网上的，1表示白2表示黑</span></span><br><span class="line"><span class="comment">// fa维护的是在哪个花</span></span><br><span class="line"><span class="comment">// 把白点变成黑点并入队</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">blossom</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">find</span>(x) != p) &#123;</span><br><span class="line">    pre[x] = y;</span><br><span class="line">    fa[y = match[x]] = fa[x] = p;</span><br><span class="line">    <span class="keyword">if</span> (col[y] == <span class="number">1</span>)</span><br><span class="line">      col[que[tail++] = y] = <span class="number">2</span>;</span><br><span class="line">    x = pre[y];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> st)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    col[i] = <span class="number">0</span>, fa[i] = i;</span><br><span class="line">  col[que[tail = <span class="number">1</span>, head = <span class="number">0</span>] = st] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span> (head != tail) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = que[head++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y : G[x]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!col[y]) &#123;</span><br><span class="line">        col[y] = <span class="number">1</span>, pre[y] = x;</span><br><span class="line">        <span class="keyword">if</span> (!match[y]) &#123;</span><br><span class="line">          <span class="comment">// 增广</span></span><br><span class="line">          <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            x = match[pre[y]];</span><br><span class="line">            match[match[y] = pre[y]] = y;</span><br><span class="line">            y = x;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          col[que[tail++] = match[y]] = <span class="number">2</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (col[y] == <span class="number">2</span> &amp;&amp; <span class="built_in">find</span>(x) != <span class="built_in">find</span>(y)) &#123;</span><br><span class="line">        <span class="comment">// 奇环，缩花</span></span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">get_lca</span>(x, y);</span><br><span class="line">        <span class="built_in">blossom</span>(x, y, p);</span><br><span class="line">        <span class="built_in">blossom</span>(y, x, p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    G[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    G[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (!match[x] &amp;&amp; !match[y])</span><br><span class="line">      match[x] = y, match[y] = x, ++ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (!match[i] &amp;&amp; <span class="built_in">bfs</span>(i))</span><br><span class="line">      ++ans;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, match[i]);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>万径人踪灭</title>
    <url>/2019/07/03/%E4%B8%87%E5%BE%84%E4%BA%BA%E8%B8%AA%E7%81%AD/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4199">万径人踪灭</a> 搜了下千山鸟飞绝这题也有，挺整齐的= = 求不相邻的回文串个数，就是总回文串数减去相邻数。相邻的manacher随便做。 对于一个对称重心$i$，存在$x$对字母关于它对称，如果$i$在一个字母位，可以形成的回文串数就是$2^{x+1}-1$。如果$i$在两个字母中间，就是$2^x-1$。 因为这题只有两个字母，分开考虑各有多少对。，把考虑的字母设为$1$，其它设为$0$，卷一下就好了。我 卷 我 自 己</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot; &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> * <span class="number">4</span> + <span class="number">2333</span>, MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>, G = <span class="number">3</span>, Gi = <span class="number">332748118</span>;</span><br><span class="line"><span class="keyword">int</span> lim = <span class="number">1</span>, L, rev[N];</span><br><span class="line">LL INV, A[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">fpow</span><span class="params">(LL x, <span class="keyword">int</span> y, LL mod)</span> </span>&#123;</span><br><span class="line">    LL ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = x * x % mod)</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = ret * x % mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(LL f[], <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i]) std::<span class="built_in">swap</span>(f[i], f[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        LL T = <span class="built_in">fpow</span>(o == <span class="number">1</span> ? G : Gi, (P - <span class="number">1</span>) / (i &lt;&lt; <span class="number">1</span>), P);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += (i &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            LL w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k, w = w * T % P) &#123;</span><br><span class="line">                LL nx = f[j + k], ny = f[i + j + k] * w % P;</span><br><span class="line">                f[j + k] = (nx + ny) % P;</span><br><span class="line">                f[i + j + k] = (nx - ny + P) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> man[N] = &#123; <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;#&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>, p[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">manacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        man[++tot] = str[i], man[++tot] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, mid = <span class="number">0</span>, r = <span class="number">0</span>; i &lt;= tot; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; r) p[i] = std::<span class="built_in">min</span>(p[mid * <span class="number">2</span> - i], r - i);</span><br><span class="line">        <span class="keyword">else</span> p[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (man[i - p[i]] == man[i + p[i]]) ++p[i];</span><br><span class="line">        <span class="keyword">if</span> (p[i] + i &gt; r) r = p[i] + i, mid = i;</span><br><span class="line">    &#125;</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">        sum = (sum + (p[i] &gt;&gt; <span class="number">1</span>)) % MOD;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">calc_all</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (lim &lt; len &lt;&lt; <span class="number">1</span>) lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; ++i)</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>)  ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>));</span><br><span class="line">    INV = <span class="built_in">fpow</span>(lim, P - <span class="number">2</span>, P);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        A[i] = str[i] == <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">NTT</span>(A, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        f[i] = A[i] * A[i] % P;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        A[i] = str[i] == <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    <span class="built_in">NTT</span>(A, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        f[i] = (f[i] + A[i] * A[i]) % P;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NTT</span>(f, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (len &lt;&lt; <span class="number">1</span>) - <span class="number">2</span>; ++i)</span><br><span class="line">        sum = (sum + <span class="built_in">fpow</span>(<span class="number">2</span>, ((f[i] * INV % P) &gt;&gt; <span class="number">1</span>) + ((i &amp; <span class="number">1</span>) ^ <span class="number">1</span>), MOD) - <span class="number">1</span>) % MOD;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str); len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (<span class="built_in">calc_all</span>() - <span class="built_in">manacher</span>() + MOD) % MOD);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>三元环 学习笔记</title>
    <url>/2019/09/20/%E4%B8%89%E5%85%83%E7%8E%AF-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>今天考试考了一个找三元环的题。考场上回忆了一会三元环计数，发现忘了，再看数据范围发现很小，bitset随便氵过去了。不过还是很有必要学一下。 这种三元环计数算法的复杂度是$O(m \sqrt m)$，用bitset计数的复杂度是$O(\frac{nm}{32})$。</p>
<h3 id="无向图三元环计数"><a href="#无向图三元环计数" class="headerlink" title="无向图三元环计数"></a>无向图三元环计数</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>枚举一条边，枚举其中一个点的出点，打上标记，再枚举另一个点出点。$O(m^3)$</p>
<h4 id="暴力优化"><a href="#暴力优化" class="headerlink" title="暴力优化"></a>暴力优化</h4><p>把无向图变成有向图，规则如下：如果两个点度数不一样，从小的连向大的。如果两个点度数$deg$相同，从编号小的连向大的。 这样的图中没有环，是DAG。现在，枚举一个点，把这个点出边指向的点都打上标记。再枚举出点，枚举出点的出点，找出三元环。 DAG证明：如果有环，环上点$deg$不同显然不行。如果相同，不可能产生一圈，每个点指向的点都比自身编号大。 复杂度证明：复杂度的瓶颈显然在枚举出点的出点。对于一条边$x \to y$，对复杂度的贡献就是$deg_y$。对$deg$分块，分类讨论点数边数即可。 不会重复计数证明：没有环，所以三元环内一定有一个点向其它两个点连了边，三元环只会在这个点被计算一次。</p>
<h3 id="有向图三元环计数"><a href="#有向图三元环计数" class="headerlink" title="有向图三元环计数"></a>有向图三元环计数</h3><p>实际上，三元环的数量就是$O(m \sqrt m)$的，直接全找出来判断就行了。。</p>
<h3 id="竞赛图三元环计数"><a href="#竞赛图三元环计数" class="headerlink" title="竞赛图三元环计数"></a>竞赛图三元环计数</h3><p>竞赛图上如果有环，那么一定是三元环。用容斥直接求答案，随便选三个点，再去掉一个点出度为$2$的情况。 $$\binom{n}{3} - \sum_{i=1}^n \binom{out_i}{2}$$</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>「伪模板」主席树（最大流）</title>
    <url>/2019/01/29/%E3%80%8C%E4%BC%AA%E6%A8%A1%E6%9D%BF%E3%80%8D%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%88%E6%9C%80%E5%A4%A7%E6%B5%81%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3701">「伪模板」主席树</a> 真主席树23333333，这么暴力的题都活着，洛谷迟早药丸 题里说：箭头指向输的人。至于为什么，留给同学们自己思考。看题的时候还以为是膜的一部分，冷静分析发现这简直明示网络流啊。。。 于是源点向byx建流量为寿命的边，手气君向汇点建边。特别的，统计膜法师数量，给长者加边的时候加上数量（续命自己不-1s！！！）。注意比试m次，取min(m, 最大流)。暴力dinic即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50000</span>, INF = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">G</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> to, nxt, f;</span><br><span class="line">    &#125; g[MAXN * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], tot = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">        g[++tot].to = y, g[tot].nxt = head[x],</span><br><span class="line">        g[tot].f = f, head[x] = tot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">addedge</span>(x, y, f);</span><br><span class="line">        <span class="built_in">addedge</span>(y, x, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, s = MAXN - <span class="number">233</span>, t = MAXN - <span class="number">666</span>;</span><br><span class="line">    string player[<span class="number">2</span>][<span class="number">150</span>];</span><br><span class="line">    <span class="keyword">int</span> id[<span class="number">2</span>][<span class="number">150</span>], num, life[<span class="number">2</span>][<span class="number">150</span>], yyy[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_elder</span><span class="params">(string x, string y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="string">&quot;W&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y == <span class="string">&quot;YYY&quot;</span>  y == <span class="string">&quot;E&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="string">&quot;HK&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y == <span class="string">&quot;W&quot;</span>  y == <span class="string">&quot;E&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="string">&quot;YYY&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y == <span class="string">&quot;HK&quot;</span>  y == <span class="string">&quot;J&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="string">&quot;E&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y == <span class="string">&quot;YYY&quot;</span>  y == <span class="string">&quot;J&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="string">&quot;J&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y == <span class="string">&quot;W&quot;</span>  y == <span class="string">&quot;HK&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">int</span> cur[MAXN], dep[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dep));</span><br><span class="line">        dep[s] = <span class="number">1</span>;</span><br><span class="line">        que.<span class="built_in">push</span>(s);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = g[i].to, f = g[i].f;</span><br><span class="line">                <span class="keyword">if</span> (!dep[y] &amp;&amp; f) &#123;</span><br><span class="line">                    dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dep[t];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> mf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == t) &#123;</span><br><span class="line">            <span class="keyword">return</span> mf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp, used = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[g[i].to] == dep[x] + <span class="number">1</span> &amp;&amp; g[i].f) &#123;</span><br><span class="line">                tmp = <span class="built_in">dfs</span>(g[i].to, <span class="built_in">min</span>(mf - used, g[i].f));</span><br><span class="line">                used += tmp;</span><br><span class="line">                g[i].f -= tmp;</span><br><span class="line">                g[i ^ <span class="number">1</span>].f += tmp;</span><br><span class="line">                <span class="keyword">if</span> (used == mf) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mf;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (g[i].f) &#123;</span><br><span class="line">                    cur[x] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!used) &#123;</span><br><span class="line">            dep[x] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> used;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(cur, head, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">            ans += <span class="built_in">dfs</span>(s, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; player[<span class="number">0</span>][i];</span><br><span class="line">            id[<span class="number">0</span>][i] = ++num;</span><br><span class="line">            <span class="keyword">if</span> (player[<span class="number">0</span>][i] == <span class="string">&quot;YYY&quot;</span>) &#123;</span><br><span class="line">                ++yyy[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; player[<span class="number">1</span>][i];</span><br><span class="line">            id[<span class="number">1</span>][i] = ++num;</span><br><span class="line">            <span class="keyword">if</span> (player[<span class="number">1</span>][i] == <span class="string">&quot;YYY&quot;</span>) &#123;</span><br><span class="line">                ++yyy[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; life[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">if</span> (player[<span class="number">0</span>][i] == <span class="string">&quot;J&quot;</span>) &#123;</span><br><span class="line">                <span class="built_in">add</span>(s, id[<span class="number">0</span>][i], life[<span class="number">0</span>][i] + yyy[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">add</span>(s, id[<span class="number">0</span>][i], life[<span class="number">0</span>][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">is_elder</span>(player[<span class="number">0</span>][i], player[<span class="number">1</span>][j])) &#123;</span><br><span class="line">                    <span class="built_in">add</span>(id[<span class="number">0</span>][i], id[<span class="number">1</span>][j], <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; life[<span class="number">1</span>][i];</span><br><span class="line">            <span class="keyword">if</span> (player[<span class="number">1</span>][i] == <span class="string">&quot;J&quot;</span>) &#123;</span><br><span class="line">                <span class="built_in">add</span>(id[<span class="number">1</span>][i], t, life[<span class="number">1</span>][i] + yyy[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">add</span>(id[<span class="number">1</span>][i], t, life[<span class="number">1</span>][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">build_graph</span>();</span><br><span class="line">        cout &lt;&lt; <span class="built_in">min</span>(m, <span class="built_in">dinic</span>()) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>退役操作集锦</title>
    <url>/2333/04/12/%E4%B8%A2%E4%BA%BA%E6%93%8D%E4%BD%9C%E9%9B%86%E9%94%A6/</url>
    <content><![CDATA[<ol>
<li>打错freopen，不删freopen，OJ交题不删调试什么的。</li>
<li>INF = 1 &lt;&lt; 30，memset了0x3f，最短路，导致奇怪的bug。</li>
<li>网络流板子打错，因为网络流的玄学性，错板子过了题结果一直错着。</li>
<li>莫队忘记给每个位置标记在哪个块就去排序…TLE。</li>
<li>node.x 和 x 分不清。变量名字不重复最好。</li>
<li>n和m范围不一样挂掉（这个太多了…）</li>
<li>答案int范围，过程中爆了int，不开long long见祖宗 还有不取膜爆long long的！！！！</li>
<li>位运算不加括号。</li>
<li>任何图论题没有特殊说明一定考虑不连通的情况！！！</li>
<li>压行，把循环里那玩意写成了注释掉的东西，成功挂掉。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">    a[i] = y - d[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a[i] = -(d[rd()] - rd());</span></span><br></pre></td></tr></table></figure>

<ol start="11">
<li>求阶乘逆元的时候不求0!的</li>
<li>对于每次操作都需要用新空间的题，数组按照操作数开大小，没给初始序列开。<a href="https://www.luogu.org/problemnew/show/P5338">[TJOI2019]甲苯先生的滚榜</a>。</li>
<li>两段差不多的代码，直接粘贴过去用，没改全炸了。</li>
<li>splay中如果存在多个值一样的点，随便找一个转到根之后，剩下的不全在左子树！！！！！！！</li>
<li>都知道无向图数组要开二倍，然而，和无向图边有关的数组都要开二倍！！！！！！！！！！！求割边，挂了，有什么好说的…</li>
<li>函数有个参数是bool，表示类型，传了个int进去，1/-1，GG。</li>
<li>Splay板子打错两行泪T_T</li>
<li>这两句不一样！！！FFT的泪水</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ans += A[i].x / lim + <span class="number">0.5</span>;</span><br><span class="line">ans += (<span class="keyword">int</span>)(A[i].x / lim + <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>

<ol start="19">
<li>线段树不pushdown</li>
<li>分类讨论不完全。。。直接变最低档暴力分，太丢人了</li>
<li>不算内存见祖宗，这个已经114514次了…MDZZ</li>
<li>diff a.out b.out -wZB ！！！！！</li>
<li>高斯小圆卡顺序：随机化</li>
<li>算空间算错(指算大感觉MLE不写了)</li>
<li>欧拉回路 和边有关开二倍</li>
<li>SAM p,np,q,nq分不清 小数据经常能过</li>
<li>写FFT，DFT共轭复数，要求j = i ? lim - i : 0。写了j = (L - i) &amp; (L - 1)而不是j = (lim - i) &amp; (lim - 1)调半小时</li>
<li>FFT，求exp，注意别求Lim求的炸掉边界。。。</li>
<li>看题不仔细。。。输入是整数yy小数做法 必须选数字yy了不选的做法，etc……….</li>
<li>[0,n-1]标号的图做dfs，初始fa不能是0。。。。。</li>
<li>把x,y用一个数存，x * 10 + y，然后x应该是0-9不能是1-10。。。</li>
<li>结构体里的构造函数，直接调用并没有什么用，会生成新数组，不能用来初始化现在的数组</li>
<li>极角排序，能用叉积就不要用atan2，被卡爆</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;x, <span class="keyword">const</span> Node &amp;y) &#123;</span><br><span class="line">  <span class="keyword">int</span> a = x.dx &lt; <span class="number">0</span>  x.dx == <span class="number">0</span> &amp;&amp; x.dy &lt; <span class="number">0</span>,</span><br><span class="line">    b = y.dx &lt; <span class="number">0</span>  y.dx == <span class="number">0</span> &amp;&amp; y.dy &lt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (a != b) <span class="keyword">return</span> a &lt; b;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">cross</span>(x, y) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="34">
<li>双指针扫可以绕圈的环形的时候，注意有没有绕圈次数过多（比如第二个指针在第一个指针前面，结果每次判断如果第二个小于第一个就等于第一个这种睿智操作。。。</li>
<li>使用A[i] != A[i + 1]计数的时候，如果多测，记得单独设置A[n + 1]</li>
<li>某仙人掌板子题，环上DP，需要两种方向绕环，写的是1-&gt;n与1-&gt;n-&gt;2，第二种算两点距离挂了</li>
<li>某FFT题，FFT过程中要用到fac[n]，统计答案的时候只用到fac[m]，于是阶乘就没算更大的。。。这个故事告诉我，阶乘这种东西，数组开多大算多大。。。。。。。。</li>
<li>记一个小Trick：优化两数相加取模的速度：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x -= P, x += x &gt;&gt; <span class="number">31</span> &amp; P;</span><br></pre></td></tr></table></figure>

<ol start="39">
<li>当需要维护一条链，要求不在链上的子树的内容，一个优秀的做法是在x维护x父亲去掉x的答案。一个愚蠢的做法是树剖+处理链。。。。后者特别难写。。。</li>
<li>设计一个单调性类的DP，当点j的意义是f[j-1]+S(j)的时候，别忘了i可以从f[i-1]转移来，也就是要额外用自己算一下自己</li>
<li>分治FFT，从序列开始选一段，从l开始选一段。注意是要求的那个从l开始选，一开始就有的从0开始选！！</li>
<li>2SAT直接用线段树式的开点法（2x，2x+1），并封装addedge()一次性加正反边是很优秀的做法。</li>
<li>关于std::swap的复杂度：</li>
</ol>
<blockquote>
<p>swap 数组是O(数组长度的) swap std::set是O(1)的 在c++11后，所有常用的STL里的都是O(1)</p>
</blockquote>
<ol start="44">
<li>启发式合并维护链并：注意合并的时候，一条一条加入，并且直接计算新的贡献（旧的它死了）</li>
<li>注意二维前缀和的正确写法……</li>
<li> 论如何卡启发式合并常数：二叉树</li>
</ol>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>严格次小生成树BJWC2010</title>
    <url>/2019/03/08/%E4%B8%A5%E6%A0%BC%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91bjwc2010/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1977">严格次小生成树[BJWC2010]</a> 求次小生成树的算法很简单：求出最小生成树后，枚举添加每一条边，在形成的环上删掉最长边，求出最小答案即可。 这道题要求的是<strong>严格</strong>次小生成树。考虑Kruskal过程和最小生成树定义，加进图中一条边形成的环里，一定没有一条边边权&gt;新加入的边，但是可能有相等的边。本题需要在求解的时候不使用环上相等的边：具体来说，就是冲突时用次长边。 其实这题倍增LCA特别好写……不知道哪根筋抽了用树剖，线段树debug到手抽筋。。线段树维护的时候把边权下放到点权，并且不使用LCA的点权即可。 ↓丑丑的代码OAO↓</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">0</span>; <span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) a=c==<span class="string">&#x27;-&#x27;</span>?<span class="number">0</span>:<span class="number">1</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) b=b*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> a?b:-b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">2333</span>, M = <span class="number">3e5</span> + <span class="number">2333</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span> <span class="keyword">int</span> from, to, nxt, c; &#125; g[M * <span class="number">2</span>], kru[M * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N], tot;</span><br><span class="line">    <span class="keyword">bool</span> used[N];</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Graph &amp;x, <span class="keyword">const</span> Graph &amp;y) &#123; <span class="keyword">return</span> x.c &lt; y.c; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        g[++tot].to = y, g[tot].nxt = head[x],</span><br><span class="line">        g[tot].c = c, head[x] = tot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ufs[N];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == ufs[x] ? x : ufs[x] = <span class="built_in">find</span>(ufs[x]); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> w[N], wt[N], id[N], num, top[N], size[N], son[N], fa[N], dep[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">        fa[x] = f, dep[x] = dep[f] + <span class="number">1</span>, size[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">            <span class="keyword">if</span> (y != f) &#123;</span><br><span class="line">                w[y] = g[i].c;</span><br><span class="line">                <span class="built_in">dfs1</span>(y, x);</span><br><span class="line">                size[x] += size[y];</span><br><span class="line">                <span class="keyword">if</span> (size[y] &gt; size[son[x]]) son[x] = y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line">        id[x] = ++num, wt[num] = w[x], top[x] = topf;</span><br><span class="line">        <span class="keyword">if</span> (son[x]) &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(son[x], topf);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">                <span class="keyword">if</span> (y != fa[x] &amp;&amp; y != son[x])</span><br><span class="line">                    <span class="built_in">dfs2</span>(y, y);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> l, r, m1, m2;</span><br><span class="line">    &#125; t[N * <span class="number">4</span>];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls(p) p &lt;&lt; 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs(p) p &lt;&lt; 1  1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        t[p].l = l, t[p].r = r;</span><br><span class="line">        <span class="keyword">if</span> (l == r) t[p].m1 = wt[l];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">build</span>(<span class="built_in">ls</span>(p), l, mid);</span><br><span class="line">            <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">            <span class="keyword">if</span> (t[<span class="built_in">ls</span>(p)].m1 == t[<span class="built_in">rs</span>(p)].m1) &#123;</span><br><span class="line">                t[p].m1 = t[<span class="built_in">ls</span>(p)].m1;</span><br><span class="line">                t[p].m2 = <span class="built_in">max</span>(t[<span class="built_in">ls</span>(p)].m2, t[<span class="built_in">rs</span>(p)].m2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t[<span class="built_in">ls</span>(p)].m1 &lt; t[<span class="built_in">rs</span>(p)].m1) &#123;</span><br><span class="line">                t[p].m1 = t[<span class="built_in">rs</span>(p)].m1;</span><br><span class="line">                t[p].m2 = <span class="built_in">max</span>(t[<span class="built_in">ls</span>(p)].m1, t[<span class="built_in">rs</span>(p)].m2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                t[p].m1 = t[<span class="built_in">ls</span>(p)].m1;</span><br><span class="line">                t[p].m2 = <span class="built_in">max</span>(t[<span class="built_in">rs</span>(p)].m1, t[<span class="built_in">ls</span>(p)].m2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) <span class="keyword">return</span> <span class="built_in">make_pair</span>(t[p].m1, t[p].m2);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ans1, ans2;</span><br><span class="line">            <span class="keyword">bool</span> ul = <span class="literal">false</span>, ur = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= mid) ans1 = <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r), ul = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (r &gt; mid) ans2 = <span class="built_in">query</span>(<span class="built_in">rs</span>(p), l, r), ur = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (ul &amp;&amp; ur) &#123;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ans;</span><br><span class="line">                <span class="keyword">if</span> (ans1.first == ans2.first) &#123;</span><br><span class="line">                    ans.first = ans1.first;</span><br><span class="line">                    ans.second = <span class="built_in">max</span>(ans1.second, ans2.second);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ans1.first &lt; ans2.first) &#123;</span><br><span class="line">                    ans.first = ans2.first;</span><br><span class="line">                    ans.second = <span class="built_in">max</span>(ans1.first, ans2.second);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.first = ans1.first;</span><br><span class="line">                    ans.second = <span class="built_in">max</span>(ans1.second, ans2.first);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ul) <span class="keyword">return</span> ans1;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> ans2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">range_query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; que = <span class="built_in">query</span>(<span class="number">1</span>, id[top[x]], id[x]);</span><br><span class="line">            <span class="keyword">if</span> (que.first != lim) ans = <span class="built_in">max</span>(ans, que.first);</span><br><span class="line">            <span class="keyword">else</span> ans = <span class="built_in">max</span>(ans, que.second);</span><br><span class="line">            x = fa[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; que = <span class="built_in">query</span>(<span class="number">1</span>, id[x] + <span class="number">1</span>, id[y]);</span><br><span class="line">        <span class="keyword">if</span> (que.first != lim) ans = <span class="built_in">max</span>(ans, que.first);</span><br><span class="line">        <span class="keyword">else</span> ans = <span class="built_in">max</span>(ans, que.second);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            kru[i].from = <span class="built_in">rd</span>(), kru[i].to = <span class="built_in">rd</span>(), kru[i].c = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">sort</span>(kru + <span class="number">1</span>, kru + m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ufs[i] = i;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mst = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = kru[i].from, y = kru[i].to, c = kru[i].c,</span><br><span class="line">                xx = <span class="built_in">find</span>(x), yy = <span class="built_in">find</span>(y);</span><br><span class="line">            <span class="keyword">if</span> (xx != yy) &#123;</span><br><span class="line">                ufs[xx] = yy;</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                mst += (<span class="keyword">long</span> <span class="keyword">long</span>)c;</span><br><span class="line">                <span class="built_in">addedge</span>(x, y, c);</span><br><span class="line">                <span class="built_in">addedge</span>(y, x, c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1LL</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = kru[i].from, y = kru[i].to, c = kru[i].c;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, mst + c - <span class="built_in">range_query</span>(x, y, c));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>上帝与集合的正确用法</title>
    <url>/2019/05/20/%E4%B8%8A%E5%B8%9D%E4%B8%8E%E9%9B%86%E5%90%88%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4139">上帝与集合的正确用法</a> 这题里的是$2^{2^{2^{2…&#125;&#125;}$，显然比$\varphi (p)$大。令$f(p)$表示$2^{2^{2^{2…&#125;&#125;} \mod p$，由扩展欧拉定理，$f(p)=2^{f(\varphi (p)) + \varphi (p)} \mod p$。递归搞一下，边界是$f(p)=1$，就行了。显然因为数据组数少，每次现算欧拉函数更快。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; ++i)</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ret -= ret / i;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>)</span><br><span class="line">                x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>)</span><br><span class="line">        ret -= ret / x;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % p)</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = (LL)ret * x % p;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ph = <span class="built_in">phi</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fpow</span>(<span class="number">2</span>, <span class="built_in">solve</span>(ph) + ph, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> p; cin &gt;&gt; p;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">solve</span>(p) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>九省联考2018一双木棋 Min-Max搜索</title>
    <url>/2019/09/09/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%832018%E4%B8%80%E5%8F%8C%E6%9C%A8%E6%A3%8B-min-max%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P4363">[九省联考2018]一双木棋</a> 可以发现，有效状态一定是一个不递增的三角。这道题的有效状态数很少。（Orz _rqy） 令每个位置的值为$a_1,a_2,…$，特别的，$a_0=m,a_{n+1}=0$。构造新数列$b_i=a_i-a_{i+1}$。对于任意$b_i$，一定$\geq 0$，且$\sum b_i = m$。方案数显然是$\binom{n+m}{m}$。 最大是$O(10^5)$的。 Min-Max对抗搜索，简而言之，就是给每种最终状态设置一个值，要让双方都取到最优结果，一方要取最大值，一方要取最小值。先搜出所有状态，然后一步步推出最开始的值，也求出了最优方案。 这题就很裸了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> uLL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">13</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, A[N][N], B[N][N], cond[N];</span><br><span class="line">std::map&lt;uLL, <span class="keyword">int</span>&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="function">uLL <span class="title">get_hash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    uLL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ret = ret * N + cond[i];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_cond</span><span class="params">(uLL x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i)</span><br><span class="line">        cond[i] = x % N, x /= N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_type</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        sum += cond[i];</span><br><span class="line">    <span class="keyword">return</span> sum &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(uLL x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.<span class="built_in">find</span>(x) != map.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">return</span> map[x];</span><br><span class="line">    <span class="built_in">get_cond</span>(x);</span><br><span class="line">    <span class="keyword">int</span> type = <span class="built_in">get_type</span>(), ret = type ? INF : -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (cond[i - <span class="number">1</span>] &gt; cond[i]) &#123;</span><br><span class="line">            ++cond[i];</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="built_in">dfs</span>(<span class="built_in">get_hash</span>());</span><br><span class="line">            <span class="keyword">if</span> (type)</span><br><span class="line">                ret = std::<span class="built_in">min</span>(ret, tmp - B[i][cond[i]]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ret = std::<span class="built_in">max</span>(ret, tmp + A[i][cond[i]]);</span><br><span class="line">            --cond[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> map[x] = ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, A[i] + j);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, B[i] + j);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cond[i] = m;</span><br><span class="line">    map[<span class="built_in">get_hash</span>()] = <span class="number">0</span>;</span><br><span class="line">    cond[<span class="number">0</span>] = m;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, map[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>二次剩余 学习笔记</title>
    <url>/2020/06/15/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99-cipolla%E7%AE%97%E6%B3%95-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>退役前挣扎一下 说起来高一寒假就学过一次这玩意，学一次忘一次 其实就是求$x^2 \equiv a \pmod p$。 有不少算法的样子，比较常用的应该是Cipolla算法，可以求解模奇素数的二次剩余。 首先冷静一下：考虑原根，那么就是要求$2x’ \equiv a’ \pmod \varphi$。因为$\varphi$是偶数，所以一半的$a$有解，且有两组解。 欧拉判别准则： 考虑$a^{\frac{p-1}{2&#125;&#125;$，如果等于$1$，说明$a$存在二次剩余，否则不存在。 证明：用$x^2$替换$a$带入，发现等于$-1$的时候$x$不存在 于是可以得到这样的算法： 求解$x^2 \equiv n \pmod p$ 找到一个数$a$，使得$a^2 - n$非二次剩余，定义$i^2 \equiv a^2 - n$（类似虚数）。 那么有$(a+i)^{\frac{p+1}{2&#125;&#125;$及其相反数是$n$的二次剩余。 证明： 考虑使用二项式定理展开。由Lucas定理，可以发现大部分项的组合数都是$0$。化简得： $$\binom10 \binom10 \sqrt{a^2 - n}^{p+1} + \binom10 \binom11 a \sqrt{a^2 - n}^p + \binom11 \binom10 a^p \sqrt{a^2-n} + \binom11 \binom11 a^{p+1}$$ 大力化简一下，得到这个式子就是$n$。 于是直接模拟以上算法即可。复杂度期望$O(logn)$。 例题：SCOI2018 Numazu 的蜜柑 好像没啥好写的啊。。推推式子，发现可以在祖先处解一个方程，并查询子树里有多少符合条件的。启发式合并即可。 这个代码是板子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cerr;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, P;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = x * x % P)</span><br><span class="line">    <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = ret * x % P;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span> &#123;</span> <span class="keyword">long</span> <span class="keyword">long</span> x, y; &#125;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mul_I;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> comp <span class="keyword">operator</span>*(<span class="keyword">const</span> comp &amp;a, <span class="keyword">const</span> comp &amp;b) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; (a.x * b.x + a.y * b.y % P * mul_I) % P, (a.x * b.y + a.y * b.x) % P &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> comp <span class="title">fpow</span><span class="params">(comp x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  comp ret = &#123; <span class="number">1</span>, <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = x * x)</span><br><span class="line">    <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = ret * x;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>)); <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;P);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fpow</span>(n, (P - <span class="number">1</span>) / <span class="number">2</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Hola!&quot;</span>); <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> a = <span class="built_in">rand</span>() % P; ; a = <span class="built_in">rand</span>() % P) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!a  <span class="built_in">fpow</span>((a * a - n + P) % P, (P - <span class="number">1</span>) / <span class="number">2</span>) == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      mul_I = (a * a - n + P) % P;</span><br><span class="line">      comp qwq = &#123; a, <span class="number">1</span> &#125;;</span><br><span class="line">      qwq = <span class="built_in">fpow</span>(qwq, (P + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">long</span> <span class="keyword">long</span> x = qwq.x, y = P - qwq.x;</span><br><span class="line">      <span class="keyword">if</span> (x &gt; y) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, x, y);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>二维前缀和的正确姿势</title>
    <url>/2020/06/12/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/</url>
    <content><![CDATA[<p>来自一个前缀和写错选手的良心馈赠</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum[x2][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum[x2][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum[x2][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum[x2][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum[x2][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum[x2][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum[x2][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum[x2][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum[x2][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum[x2][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum[x2][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum[x2][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum[x2][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum[x2][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum[x2][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum[x2][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum[x2][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum[x2][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum[x2][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum[x2][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>于神之怒加强版</title>
    <url>/2019/06/28/%E4%BA%8E%E7%A5%9E%E4%B9%8B%E6%80%92%E5%8A%A0%E5%BC%BA%E7%89%88/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4449">于神之怒加强版</a> $$n &lt;= m$$ $$\sum_{i=1}^n \sum_{j=1}^m gcd(i,j)^k$$ $$\sum_{i=1}^n \sum_{j=1}^m (\sum_{d \mid gcd(i,j)} \varphi(d))^k$$ ？？？？？？？？？？ 显然不可做，换思路。 $$\sum_{i=1}^n \sum_{j=1}^m gcd(i,j)^k$$ 改成枚举$d$ $$\sum_{d=1}^n d^k \sum_{i=1}^n \sum_{j=1}^m [gcd(i,j) =d]$$ $$\sum_{d=1}^n d^k \sum_{p=1}^{\lfloor \frac{n}{d} \rfloor} \lfloor \frac{n}{dp} \rfloor \lfloor \frac{m}{dp} \rfloor $$ 枚举$T=dp$ $$\sum_{T=1}^n \lfloor \frac{n}{T} \rfloor \lfloor \frac{n}{T} \rfloor \sum_{d \mid T} d^k \mu(\frac{T}{d})$$ 后面这玩意可以$O(nlog^2n)$预处理，TLE。 先预处理幂，再预处理，$O(nlogn)$，还是TLE。 考虑线性筛 搞一个$f(x)$ $$f(T)=\sum_{d \mid T} d^k \mu(\frac{T}{d})$$ 这玩意是积性函数。 $p$是质数 $$f(p)=p^k-1$$ $$f(p^x)=p^{kx}-p^{k(x-1)}=p^{k(x-1)}(p^k-1)$$ 发现当$x+1$，$f(p^x)*p^k$ 就可以线性筛了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000000</span> + <span class="number">2333</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[N], p[N];</span><br><span class="line"><span class="keyword">int</span> pri[N], tot;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = ans * x % MOD;</span><br><span class="line">        x = x * x % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> k)</span> </span>&#123;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            pri[++tot] = i, f[i] = <span class="built_in">fpow</span>(i, k) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; pri[j] * i &lt; N; ++j) &#123;</span><br><span class="line">            vis[i * pri[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                f[i * pri[j]] = f[i] * (f[pri[j]] + <span class="number">1</span>) % MOD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i * pri[j]] = f[i] * f[pri[j]] % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">        f[i] = (f[i] + f[i - <span class="number">1</span>]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = <span class="built_in">min</span>(n / (n / l), m / (m / l));</span><br><span class="line">        ans = (ans + <span class="number">1LL</span> * (n / l) * (m / l) % MOD * (f[r] - f[l - <span class="number">1</span>] + MOD) % MOD) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (ans + MOD) % MOD &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="keyword">int</span> t; <span class="keyword">long</span> <span class="keyword">long</span> k; cin &gt;&gt; t &gt;&gt; k;</span><br><span class="line">    <span class="comment">// clock_t s = clock();</span></span><br><span class="line">    <span class="built_in">init</span>(k);</span><br><span class="line">    <span class="comment">// clock_t e = clock();</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; (double)(e - s) / CLOCKS_PER_SEC &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; m) <span class="built_in">swap</span>(n, m);</span><br><span class="line">        <span class="built_in">solve</span>(n, m, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>任务安排斜率优化DP</title>
    <url>/2019/05/07/%E4%BB%BB%E5%8A%A1%E5%AE%89%E6%8E%92%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2365">任务安排</a> 斜率优化DP第一题。这题网上讲解很多，这里随便说两句好了，反正给自己看的，没有图(T^T)。 这题前面做的任务会给后面加时间，所以在计算的时候直接把给后面加的时间全算上。首先求个前缀和，写个裸DP转移方程$f[i]=min(f[j]+t[i]*(c[i]-c[j])+s*(c[n]-c[j]))$。 把min去掉，把不带$j$的全看作常数，移项，得到这样的式子一枚$f[j]=(s+t[i])*c[j]+f[i]-t[i]*c[i]-s*c[n]$。 把点对$(c[j],f[j])$放在坐标系内。当算到$i$的时候，式子的斜率是$s+t[i]$。我们可以用这条直线作为扫描线扫过坐标系，要令$f[i]$最小，即$f[i]-t[i]*c[i]-s*c[n]$最小，第一个扫到的点明显满足。 在可能成为答案的点间连线，斜率单调递增，即一个凸包的下凸壳。令当前扫描线的斜率为$k$，凸包上相邻三个点$x1,x2,x3$连线斜率为$k1,k2$，如果$x2$是答案，那么有$k1 &lt; k &lt; k2$。维护一个队列，队尾删除无用旧点，队头维护凸包即可。复杂度显然$O(n)$。 实际上$t[i]$不单增的话，斜率不单增，队头不一定是最优决策，可以在队列里二分查找，$O(nlogn)$。 最后总结下斜率优化题的特点：$f[i]=min/max(f[j]+v)$，$v$与$i*j$有关。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>;</span><br><span class="line"><span class="keyword">int</span> n, s, t[N], c[N], f[N], q[N], l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; t[i] &gt;&gt; c[i];</span><br><span class="line">        t[i] += t[i - <span class="number">1</span>];</span><br><span class="line">        c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; f[q[l + <span class="number">1</span>]] - f[q[l]]</span><br><span class="line">            &lt;= (s + t[i]) * (c[q[l + <span class="number">1</span>]] - c[q[l]])) ++l;</span><br><span class="line">        f[i] = f[q[l]] - (s + t[i]) * c[q[l]] + t[i] * c[i] + s * c[n];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; (f[q[r]] - f[q[r - <span class="number">1</span>]]) * (c[i] - c[q[r]])</span><br><span class="line">            &gt;= (f[i] - f[q[r]]) * (c[q[r]] - c[q[r - <span class="number">1</span>]])) --r;</span><br><span class="line">        q[++r] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>今 日 C S P 模 拟 题 FFT生成函数</title>
    <url>/2019/10/21/%E4%BB%8A-%E6%97%A5-c-s-p-%E6%A8%A1-%E6%8B%9F-%E9%A2%98-fft%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>进行石头剪刀布游戏，给出$n$个长度为$m$的串，内容为$P,R,S$。$P$赢$R$，$R$赢$S$，$S$赢$P$。定义一次战斗，为两个串每个位置比较，分别计算胜利数。两个串可以放在一个集合内，当且仅当任意循环移位一个串并战斗，两个人胜场数都不变。求有多少子集是合法的。$n \leq 200000, m \leq 18$。</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>真实的联赛模拟题就是这么朴实无华 考虑三次单位根。比较$A,B$两串，令$R,S,P$的权分别为$w_3^0,w_3^1,w_3^1$，$w_3^{-0},w_3^{-1},w_3^{-2}$，那么两个字母的值乘起来，就可以判断输赢。 分别记为$f(x),g(x)$，那么对于第$k$次输赢，可以得到这个式子： $$\sum_{i-j=k}f(i)g(j)$$ 反转$g$，考虑生成函数。 $$f(x) = \sum_{i=0}^{m-1} v_a(i) x^i$$ $$g(x) = \sum_{i=0}^{m-1} v_b(m-i-1) x^i$$ 做一个循环卷积，就可以得到关于输赢的多项式了。显然如果是可行的，每一项都相等。 循环卷积定理：求循环卷积DFT乘起来就可以。其实很简单，单位根$w_n$就是模$n$的。 考虑IDFT的过程其实也是在求点值，如果IDFT后各项相等，那么点值式的每一项都必须是$0$，即$f,g$的点值表达式每一项都有$a_ib_i=0$ $g$是$f$翻转并求复共轭得到的，显然，如果两式满足要求，$f_1,f_2$的点值表达式每一项都有$a_ib_i=0$。 观察$m$的范围，发现很小，暴力做DFT就可以。 然后做一个DP。记录每条字符串DFT后，哪些位不是$0$。如果一堆串可以放在一起，那么它们必无交集。令$f_s$表示选中集合或和为$s$，$O(3^m)$枚举子集DP。显然本题点值表示的第$0$个数可以不考虑，$m$降至$17$，轻松通过。 <a href="https://www.luogu.org/paste/9py9315b">不乱码的代码点这里</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">233</span>, M = <span class="number">20</span>, S = <span class="number">17</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = std::<span class="built_in">acos</span>(<span class="number">-1</span>), eps = <span class="number">1e-9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt[(<span class="number">1</span> &lt;&lt; S) + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[(<span class="number">1</span> &lt;&lt; S) + <span class="number">5</span>], ans;</span><br><span class="line"><span class="keyword">char</span> str[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">fabs</span>(x) &lt; eps ? <span class="number">0</span> : x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span> &#123;</span></span><br><span class="line">  <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">complex <span class="keyword">operator</span>+(<span class="keyword">const</span> complex &amp;a, <span class="keyword">const</span> complex &amp;b) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; a.x + b.x, a.y + b.y &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complex <span class="keyword">operator</span>*(<span class="keyword">const</span> complex &amp;a, <span class="keyword">const</span> complex &amp;b) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complex f[M], g[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = x * x % P)</span><br><span class="line">    <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">      ret = ret * x % P;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">      f[i] = g[i] = &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (str[i] == <span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">        f[i] = &#123; std::<span class="built_in">cos</span>(<span class="number">-2</span> * <span class="number">0</span> * PI / <span class="number">3</span>), std::<span class="built_in">sin</span>(<span class="number">-2</span> * <span class="number">0</span> * PI / <span class="number">3</span>) &#125;;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">        f[i] = &#123; std::<span class="built_in">cos</span>(<span class="number">-2</span> * <span class="number">1</span> * PI / <span class="number">3</span>), std::<span class="built_in">sin</span>(<span class="number">-2</span> * <span class="number">1</span> * PI / <span class="number">3</span>) &#125;;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        f[i] = &#123; std::<span class="built_in">cos</span>(<span class="number">-2</span> * <span class="number">2</span> * PI / <span class="number">3</span>), std::<span class="built_in">sin</span>(<span class="number">-2</span> * <span class="number">2</span> * PI / <span class="number">3</span>) &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">      complex T = &#123; std::<span class="built_in">cos</span>(<span class="number">-2</span> * i * PI / m), std::<span class="built_in">sin</span>(<span class="number">-2</span> * i * PI / m) &#125;,</span><br><span class="line">        w = &#123; <span class="number">1</span>, <span class="number">0</span> &#125;;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j, w = w * T)</span><br><span class="line">        g[i] = g[i] + w * f[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">dcmp</span>(g[i].x) != <span class="number">0</span>  <span class="built_in">dcmp</span>(g[i].y) != <span class="number">0</span>)</span><br><span class="line">        s = <span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>);</span><br><span class="line">    ++cnt[s];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> s1 = <span class="number">1</span>; s1 &lt; <span class="number">1</span> &lt;&lt; (m - <span class="number">1</span>); ++s1)</span><br><span class="line">    <span class="keyword">if</span> (cnt[s1] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> s = ((<span class="number">1</span> &lt;&lt; (m - <span class="number">1</span>)) - <span class="number">1</span>) ^ s1, s2 = s; s2; s2 = (s2 - <span class="number">1</span>) &amp; s)</span><br><span class="line">        dp[s1  s2] = (dp[s1  s2] + dp[s2] * cnt[s1]) % P;</span><br><span class="line">      dp[s1] = (dp[s1] + dp[<span class="number">0</span>] * cnt[s1]) % P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">1</span> &lt;&lt; (m - <span class="number">1</span>); ++s)</span><br><span class="line">    ans = (ans + dp[s]) % P;</span><br><span class="line"></span><br><span class="line">  ans = ans * <span class="built_in">fpow</span>(<span class="number">2</span>, cnt[<span class="number">0</span>]) % P;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>便宜的回文Cheapest Palindrome</title>
    <url>/2019/02/28/%E4%BE%BF%E5%AE%9C%E7%9A%84%E5%9B%9E%E6%96%87cheapest-palindrome/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2890">便宜的回文Cheapest Palindrome</a> 求把一个串变成回文串最小代价。区间DP裸题。 把一个串变成回文串，删掉和添加一个字符其实是一样的。所以对于每个字母的操作，取最小花费即可。 设计DP数组$f[i][j]$，表示$i$到$j$变成回文串最小代价，则有转移方程如下（$ch[]$表示原字符）： $f[i][j] = f[i + 1][j - 1]$ 如果 $ch[i] == ch[j]$ $f[i][j] = min(f[i + 1][j] + cost[i], f[i][j - 1] + cost[j])$ 其他情况 回文串代价显然有最优子结构性质，所以DP正确性显然。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, f[<span class="number">2100</span>][<span class="number">2100</span>], cost[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">2100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cin &gt;&gt; (ch + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> c; <span class="keyword">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        cost[c] = <span class="built_in">min</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= m; ++len) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = len; j &lt;= m; ++i, ++j) &#123;</span><br><span class="line">            f[i][j] = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">            <span class="keyword">if</span> (ch[i] == ch[j]) f[i][j] = f[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> f[i][j] = <span class="built_in">min</span>(f[i + <span class="number">1</span>][j] + cost[ch[i]],</span><br><span class="line">                f[i][j - <span class="number">1</span>] + cost[ch[j]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[<span class="number">1</span>][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>六省联考2017分手是祝愿 贪心期望DP</title>
    <url>/2019/09/30/%E5%85%AD%E7%9C%81%E8%81%94%E8%80%832017%E5%88%86%E6%89%8B%E6%98%AF%E7%A5%9D%E6%84%BF-%E8%B4%AA%E5%BF%83%E6%9C%9F%E6%9C%9Bdp/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P3750">[六省联考2017]分手是祝愿</a> 先求出最少操作次数$cnt$。 令$y \mid x$，则一定有$y \leq x$（废话。。 于是可以发现一种贪心策略： 从大往小，把每一个需要操作的都操作一下。 如果$cnt = k$，这就是答案。 否则，令$f_{x}$表示需要操作的次数$x \rightarrow x-1$的期望。 $$f_{x}= \frac{i}{n}+ \frac{n-i}{n}(f_{x}+f_{x+1}+1)$$ $$f_x = \frac{1}{i}((n-i)f_{x+1}+n)$$ 由期望的线性性，操作次数变成$k$的期望是 $$\sum_{i=k+1}^{cnt}f_i$$ $O(nlogn)$预处理因数，线性求逆元，跑的很快。 <a href="https://www.luogu.org/paste/pc6ougq8">Code here</a></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>六省联考2017相逢是问候 扩展欧拉定理线段树</title>
    <url>/2019/09/30/%E5%85%AD%E7%9C%81%E8%81%94%E8%80%832017%E7%9B%B8%E9%80%A2%E6%98%AF%E9%97%AE%E5%80%99-%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P3747">[六省联考2017]相逢是问候</a> 首先我们有扩展欧拉定理： $$a^b = \begin{cases} a^{b \mod \varphi(p) + \varphi(p)} &amp;\text{if } b \ge \varphi(p) \ a^b &amp; \text{else} \end{cases} \pmod p$$ 当我们进行操作时，$a_i \rightarrow c^{a_i} \rightarrow c^{c^{a_i&#125;&#125; \rightarrow …$。只要层数足够多，值就不会变化了。 于是可以维护每个位置被操作了多少次。每次修改的时候，每个值递归$O(logn)$层，加上快速幂的$O(logn)$，总复杂度$O(nlog^3n)$，不是很好看。 快速幂的底一定是$\varphi$，那么数量很少。把幂分块，就可以$O(1)$算了。 顺便一提，$\varphi$的深度是$O(logn)$，是因为一个这样的结论：$n&gt;2$时，$\varphi(n)$是偶数。 大约是因为我太菜，感觉细节很多很难写，蒟蒻WA了一晚上。 <a href="https://www.luogu.org/paste/8ogu1acm">Click here to view the code</a></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>作诗</title>
    <url>/2019/03/16/%E4%BD%9C%E8%AF%97/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4135">作诗</a> 本来想写莫队，发现强制在线，就上分块搞它。 定义$pos[i]$为$i$所在块，$L[i]$为第$i$块开头位置。$f[i][j]$表示$[L[i],n]$中$j$出现次数，$g[i][j]$表示$[L[i],L[j+1]-1]$的答案。（实际上$f$数组意义从前向后也可以，但是这样好预处理见下文。） $O(n\sqrt n)$预处理：枚举起点块，扫到结尾，维护$tot$变量动态维护答案，在换块的时候更新$g$。 然后分类讨论就行了。因为$n,m$同量级，总复杂度可视为$O(n\sqrt n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>, SQRTN = <span class="number">320</span>;</span><br><span class="line">    <span class="keyword">int</span> num[N], f[SQRTN][N], g[SQRTN][SQRTN], pos[N],</span><br><span class="line">        L[N], cnt[N], stack[N], top;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">rd</span>(), c = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) num[i] = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">int</span> block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            pos[i] = (i - <span class="number">1</span>) / block + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (pos[i] != pos[i - <span class="number">1</span>]) L[pos[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        L[pos[n + <span class="number">1</span>] = pos[n] + <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pos[n]; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = L[i]; j &lt;= n; ++j) &#123;</span><br><span class="line">                ++f[i][num[j]];</span><br><span class="line">                <span class="keyword">if</span> (!(f[i][num[j]] &amp; <span class="number">1</span>)) ++tot;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (f[i][num[j]] &gt; <span class="number">1</span>) --tot;</span><br><span class="line">                <span class="keyword">if</span> (pos[j] != pos[j + <span class="number">1</span>]) g[i][pos[j]] = tot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = (<span class="built_in">rd</span>() + ans) % n + <span class="number">1</span>, r = (<span class="built_in">rd</span>() + ans) % n + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (l &gt; r) <span class="built_in">swap</span>(l, r);</span><br><span class="line">            <span class="keyword">if</span> (pos[l] + <span class="number">1</span> &gt; pos[r] - <span class="number">1</span>) &#123;</span><br><span class="line">                ans = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">                    ++cnt[stack[++top] = num[i]];</span><br><span class="line">                <span class="keyword">while</span> (top) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cnt[stack[top]])</span><br><span class="line">                        ans += !(cnt[stack[top]] &amp; <span class="number">1</span>);</span><br><span class="line">                    cnt[stack[top--]] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = g[pos[l] + <span class="number">1</span>][pos[r] - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; L[pos[l] + <span class="number">1</span>]; ++i) </span><br><span class="line">                    ++cnt[stack[++top] = num[i]];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = L[pos[r]]; i &lt;= r; ++i)</span><br><span class="line">                    ++cnt[stack[++top] = num[i]];</span><br><span class="line">                <span class="keyword">while</span> (top) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cnt[stack[top]]) &#123;</span><br><span class="line">                        <span class="keyword">int</span> delta = f[pos[l] + <span class="number">1</span>][stack[top]] - f[pos[r]][stack[top]];</span><br><span class="line">                        <span class="keyword">if</span> (delta &amp;&amp; !(delta &amp; <span class="number">1</span>) &amp;&amp; (cnt[stack[top]] &amp; <span class="number">1</span>)) --ans;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (delta &amp;&amp; (delta &amp; <span class="number">1</span>) &amp;&amp; (cnt[stack[top]] &amp; <span class="number">1</span>)) ++ans;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (!delta &amp;&amp; !(cnt[stack[top]] &amp; <span class="number">1</span>)) ++ans;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cnt[stack[top--]] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>倒酒问题</title>
    <url>/2019/01/05/%E5%80%92%E9%85%92%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><a href="http://218.5.5.242:9018/JudgeOnline/problem.php?id=1428">倒酒问题</a> 据说是数学题，当bfs写就行了 分别输入三个杯子容量a，b,c 且第一个为初始杯中的酒量，另外两个为空的。现要求你要精确量出e容量的酒。问最少通过几步能精确量出你所要的容量。例如有三个烧杯容量分别为：80、50、30毫升，现在第一个杯中装满了80毫升水，其余两个是空的。现要精确的40毫升水，不许用其它工具，请找出最少步骤的方法。 若超过50步，则认为这种计量方法太麻烦，直接输出“no answer” 每次枚举所有倒水的情况，我偷懒就直接把把自己全部倒走和把对面倒满枚举了，然后再判断是否可行，一共12个状态 重点是判重和输出，针对步数较小的特点，直接用STLset判重即可 输出是一个不好写的地方，我采用了手写队列的方法，记录每一个状态是从哪里推来的，最后递归输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Water</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z, s, pre, now;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Water &amp;w) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == w.x ? y == w.y ? z &lt; w.z : y &lt; w.y : x &lt; w.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Water <span class="title">init</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> s, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    Water tmp;</span><br><span class="line">    tmp.x = x; tmp.y = y;</span><br><span class="line">    tmp.z = z; tmp.s = s;</span><br><span class="line">    tmp.pre = pre;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Water que[<span class="number">233333</span>];</span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line">set&lt;Water&gt; st;</span><br><span class="line"><span class="keyword">int</span> a, b, c, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (que[p].pre == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="built_in">write</span>(que[p].pre);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;step%d:%d %d %d\n&quot;</span>, step, que[p].x, que[p].y, que[p].z);</span><br><span class="line">    <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(Water w)</span> </span>&#123;</span><br><span class="line">    w.now = ++r;</span><br><span class="line">    que[r] = w;</span><br><span class="line">    <span class="keyword">if</span> (w.x == k  w.y == k  w.z == k) &#123;</span><br><span class="line">        <span class="built_in">write</span>(w.now);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    st.<span class="built_in">insert</span>(w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; ++l; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Water <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> que[l + <span class="number">1</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(<span class="keyword">const</span> Water &amp;w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w.x &lt; <span class="number">0</span>  w.y &lt; <span class="number">0</span>  w.z &lt; <span class="number">0</span></span><br><span class="line">         w.x &gt; a  w.y &gt; b  w.z &gt; c</span><br><span class="line">         st.<span class="built_in">find</span>(w) != st.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_cond</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> s, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    Water wt = <span class="built_in">init</span>(x, y, z, s, pre);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">judge</span>(wt) != <span class="number">-1</span>) <span class="built_in">push</span>(wt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; k;</span><br><span class="line">    <span class="built_in">push</span>(<span class="built_in">init</span>(a, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    st.<span class="built_in">insert</span>(<span class="built_in">front</span>());</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Water w = <span class="built_in">front</span>();</span><br><span class="line">        <span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (w.s &gt; <span class="number">50</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;no answer&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = w.x, y = w.y, z = w.z, s = w.s, n = w.now;</span><br><span class="line">        <span class="built_in">new_cond</span>(x - b + y, b, z, s + <span class="number">1</span>, n);</span><br><span class="line">        <span class="built_in">new_cond</span>(x - c + z, y, c, s + <span class="number">1</span>, n);</span><br><span class="line">        <span class="built_in">new_cond</span>(a, y - a + x, z, s + <span class="number">1</span>, n);</span><br><span class="line">        <span class="built_in">new_cond</span>(x, y - c + z, c, s + <span class="number">1</span>, n);</span><br><span class="line">        <span class="built_in">new_cond</span>(a, y, z - a + x, s + <span class="number">1</span>, n);</span><br><span class="line">        <span class="built_in">new_cond</span>(x, b, z - b + y, s + <span class="number">1</span>, n);</span><br><span class="line">        <span class="built_in">new_cond</span>(<span class="number">0</span>, y + x, z, s + <span class="number">1</span>, n);</span><br><span class="line">        <span class="built_in">new_cond</span>(<span class="number">0</span>, y, z + x, s + <span class="number">1</span>, n);</span><br><span class="line">        <span class="built_in">new_cond</span>(x + y, <span class="number">0</span>, z, s + <span class="number">1</span>, n);</span><br><span class="line">        <span class="built_in">new_cond</span>(x, <span class="number">0</span>, y + z, s + <span class="number">1</span>, n);</span><br><span class="line">        <span class="built_in">new_cond</span>(x + z, y, <span class="number">0</span>, s + <span class="number">1</span>, n);</span><br><span class="line">        <span class="built_in">new_cond</span>(x, y + z, <span class="number">0</span>, s + <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;no answer&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>关于本博客</title>
    <url>/2334/06/17/%E5%85%B3%E4%BA%8E%E6%9C%AC%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>高中打OI时代写的题解都在这里</p>
<p>原本在WordPress上，现在用Hexo制作为静态界面存放</p>
<p>可能有一些公式/图片挂了，但是也没办法修，就不修了</p>
<p>评论区没了，如果对内容有问题，欢迎用以下方式联系：</p>
<p>Luogu私信： <a href="https://www.luogu.com.cn/user/52068">https://www.luogu.com.cn/user/52068</a></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>分治FFT的正确姿势</title>
    <url>/2020/08/12/%E5%88%86%E6%B2%BBfft%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/</url>
    <content><![CDATA[<p>在做<a href="http://uoj.ac/contest/55/problem/551">【UNR #4】校园闲逛</a>的时候，发现可以分治FFT，就试着冲了一下。结果之后很久没写出来。orz了skyh大神的代码之后才搞出来，尝试总结一下 首先这道题怎么整：一种非正解但是能过的做法就是，考虑直接分治FFT，则$f_{x,y,i}$由$f_{x,z,j},f_{z,y,i-j}$拼出来。用分治优化。 问题1：这个函数是自己卷自己，怎么做： <a href="https://prutekoi.github.io/post/wo-juan-wo-zi-ji/">https://prutekoi.github.io/post/wo-juan-wo-zi-ji/</a>。 这道题的分治较特殊先不表。对于一半的形如自己卷自己的分治FFT，可以考虑对左端点分类讨论。如果左端点是$0$，直接左边自己卷一下就可以对右边产生贡献。如果不是$0$，考虑对右边的贡献：$[l,mid]$一段与$[0,r-l+1]$一段卷起来。这里有一个细节：事实上此时一个位置会被算两次。所以要乘一下 问题2：本题一条路径只能被统计一次，怎么做： 先介绍一下大神的做法：当$l=0$时，先递归计算，之后计算一条路径和一条路的拼接。要求拼起来之后贡献到右边。当$l \neq 0$时，计算路径和路径的拼接。要求一条路径比$l$长，一条短。注意到此时右边已经计算完毕，不递归直接返回。 由于一条路径一定可以拆开，使得一段大于等于一半，且大于的一半是极短的（即去掉一条边会小于），所以是不漏的。由于一旦一条路径可以被拆开，立即被计算，所以是不重的。 大神的做法太神了，所以记一下正常做法：实际上不需要用自己卷自己的高妙技巧，我们可以考虑每次都是只加一条边上去。这样就可以直接一般通过分治FFT了。具体来说每次考虑让左边的加一条边，正好落在右边即可。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>十二省联考2019字符串问题</title>
    <url>/2019/06/24/%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P5284">[十二省联考2019]字符串问题</a> 我哭了，你们呢。 首先这是个图论题。A向支配点连边，B向匹配的A连边，求最长路。省选考场上写的暴力，还写炸了，10分… 可以用SAM做，不会。SA大法好！！！！！（虽然长的吓人…） 建个SA，对于每个B，可以二分或者单调栈，找出一堆后缀，使得B是这些后缀的lcp。 然后需要把B向这一堆后缀连边。线段树优化向一堆连边的过程。 最后每个A串在后缀数组上的起点向A连边。这样就有80分了。 最后20分里面，A串可能比B串短。用可持久化线段树优化建图。 具体来说，就是按照串的长度从大到小为版本，为后缀数组建树。旧版本每个点向新版本对应点连边，代表长的可以，短的也可以。到达A时，连向A串一条边。到达B时，B向此版本对应区间连边。 有个坑，排序的时候版本一样，先A后B。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    多测不清空，爆零一行泪</span></span><br><span class="line"><span class="comment">    多测多清空，爆零两行泪（TLE）</span></span><br><span class="line"><span class="comment">    排序顺序错，爆零三行泪</span></span><br><span class="line"><span class="comment">    7K代码细节错，爆零1e9+7行泪</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">2333</span>;</span><br><span class="line"><span class="keyword">int</span> lg[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SA &#123;</span><br><span class="line">    <span class="keyword">int</span> n, x[N], y[N], c[N], sa[N], ht[N], rk[N], st[N][<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(x));</span><br><span class="line">        <span class="built_in">memset</span>(y, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(y));</span><br><span class="line">        <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">char</span> s[], <span class="keyword">int</span> nnn)</span> </span>&#123;</span><br><span class="line">        n = nnn;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i] = s[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;z&#x27;</span>; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sa[c[x[i]]--] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, p = <span class="number">0</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>, p = <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; ++i) y[++p] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">                <span class="keyword">if</span> (sa[i] &gt; k) y[++p] = sa[i] - k;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++c[x[i]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">                sa[c[x[y[i]]]--] = y[i];</span><br><span class="line">            <span class="built_in">swap</span>(x, y); x[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">                x[sa[i]] = y[sa[i]] == y[sa[i - <span class="number">1</span>]]</span><br><span class="line">                    &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]</span><br><span class="line">                    ? p : ++p;</span><br><span class="line">            <span class="keyword">if</span> (p == n) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rk[sa[i]] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, p = <span class="number">0</span>, j = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (p) --p;</span><br><span class="line">            j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (s[i + p] == s[j + p])</span><br><span class="line">                ++p;</span><br><span class="line">            ht[rk[i]] = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) st[i][<span class="number">0</span>] = ht[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i)</span><br><span class="line">                st[i][j] = <span class="built_in">min</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lcp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        ++x; <span class="keyword">int</span> t = lg[y - x + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(st[x][t], st[y - (<span class="number">1</span> &lt;&lt; t) + <span class="number">1</span>][t]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> len, <span class="keyword">int</span> &amp;left, <span class="keyword">int</span> &amp;right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, mid;</span><br><span class="line">        <span class="keyword">if</span> (ht[x + <span class="number">1</span>] &lt; len) right = x;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l = x + <span class="number">1</span>; r = n;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">lcp</span>(x, mid) &gt;= len)</span><br><span class="line">                    l = mid + <span class="number">1</span>, right = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ht[x] &lt; len) left = x;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l = <span class="number">1</span>; r = x - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">lcp</span>(mid, x) &gt;= len)</span><br><span class="line">                    r = mid - <span class="number">1</span>, left = mid;</span><br><span class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph &#123;</span><br><span class="line">    <span class="keyword">int</span> to[N * <span class="number">32</span>], nxt[N * <span class="number">32</span>], head[N * <span class="number">32</span>], cost[N * <span class="number">32</span>], tot;</span><br><span class="line">    <span class="keyword">int</span> in[N * <span class="number">32</span>], a[N * <span class="number">32</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f[N * <span class="number">32</span>];</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(to, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * (tot + <span class="number">233</span>));</span><br><span class="line">        <span class="built_in">memset</span>(nxt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * (tot + <span class="number">233</span>));</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * (tot + <span class="number">233</span>));</span><br><span class="line">        <span class="built_in">memset</span>(cost, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * (tot + <span class="number">233</span>));</span><br><span class="line">        <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * (tot + <span class="number">233</span>));</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">long</span> <span class="keyword">long</span>) * (tot + <span class="number">233</span>));</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * (tot + <span class="number">233</span>));</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x  !y) <span class="keyword">return</span>;</span><br><span class="line">        to[++tot] = y; nxt[tot] = head[x];</span><br><span class="line">        cost[tot] = c; head[x] = tot;</span><br><span class="line">        ++in[y];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; ++i)</span><br><span class="line">            <span class="keyword">if</span> (!in[i]) que.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = to[i];</span><br><span class="line">                f[y] = <span class="built_in">max</span>(f[y], f[x] + a[x]);</span><br><span class="line">                <span class="keyword">if</span> (!--in[y]) que.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; ++i)</span><br><span class="line">            <span class="keyword">if</span> (in[i]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; ++i)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, f[i] + a[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Seg &#123;</span><br><span class="line">    <span class="keyword">int</span> ls[N * <span class="number">32</span>], rs[N * <span class="number">32</span>], root[N], tot = <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;now, <span class="keyword">int</span> pre, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        now = ++tot;</span><br><span class="line">        ls[now] = ls[pre]; rs[now] = rs[pre];</span><br><span class="line">        Graph::<span class="built_in">addedge</span>(now, pre);</span><br><span class="line">        <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">            Graph::<span class="built_in">addedge</span>(now, y);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) &#123;</span><br><span class="line">            <span class="built_in">insert</span>(ls[now], ls[pre], x, y, L, mid);</span><br><span class="line">            Graph::<span class="built_in">addedge</span>(now, ls[now]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">insert</span>(rs[now], rs[pre], x, y, mid + <span class="number">1</span>, R);</span><br><span class="line">            Graph::<span class="built_in">addedge</span>(now, rs[now]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R) &#123;</span><br><span class="line">            Graph::<span class="built_in">addedge</span>(x, p);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">            <span class="built_in">add</span>(ls[p], x, l, r, L, mid);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">            <span class="built_in">add</span>(rs[p], x, l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> na, nb;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SB_Problem</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">&#125; a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubStr</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, len, id;</span><br><span class="line">&#125; str[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> SubStr &amp;x, <span class="keyword">const</span> SubStr &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此处有坑：相等的时候特殊处理！！！！</span></span><br><span class="line">    <span class="keyword">return</span> x.len == y.len ? x.id &lt; y.id : x.len &gt; y.len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(s));</span><br><span class="line">    SA::<span class="built_in">clear</span>();</span><br><span class="line">    Graph::<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SA::<span class="built_in">build</span>(s, n);</span><br><span class="line"></span><br><span class="line">    na = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= na; ++i) &#123;</span><br><span class="line">        a[i].l = <span class="built_in">rd</span>();</span><br><span class="line">        a[i].r = <span class="built_in">rd</span>();</span><br><span class="line">        str[i].l = a[i].l;</span><br><span class="line">        str[i].len = a[i].r - a[i].l + <span class="number">1</span>;</span><br><span class="line">        str[i].id = i;</span><br><span class="line">        Graph::a[i] = a[i].r - a[i].l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nb = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nb; ++i) &#123;</span><br><span class="line">        b[i].l = <span class="built_in">rd</span>();</span><br><span class="line">        b[i].r = <span class="built_in">rd</span>();</span><br><span class="line">        str[i + na].l = b[i].l;</span><br><span class="line">        str[i + na].len = b[i].r - b[i].l + <span class="number">1</span>;</span><br><span class="line">        str[i + na].id = i + na;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(str + <span class="number">1</span>, str + na + nb + <span class="number">1</span>, comp);</span><br><span class="line"></span><br><span class="line">    Seg::tot = na + nb + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, tot = <span class="number">0</span>; i &lt;= na + nb; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i].id &lt;= na) &#123;</span><br><span class="line">            ++tot;</span><br><span class="line">            Seg::<span class="built_in">insert</span>(Seg::root[tot], Seg::root[tot - <span class="number">1</span>], SA::rk[str[i].l], str[i].id, <span class="number">1</span>, n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">2333</span>, r = <span class="number">6666</span>;</span><br><span class="line">            SA::<span class="built_in">match</span>(SA::rk[str[i].l], str[i].len, l, r);</span><br><span class="line">            Seg::<span class="built_in">add</span>(Seg::root[tot], str[i].id, l, r, <span class="number">1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">        Graph::<span class="built_in">addedge</span>(x, y + na);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, Graph::<span class="built_in">calc</span>(Seg::tot));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">love</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i)</span><br><span class="line">        lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> T = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out1.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">love</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>十二省联考2019春节十二响</title>
    <url>/2019/04/08/%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019%E6%98%A5%E8%8A%82%E5%8D%81%E4%BA%8C%E5%93%8D/</url>
    <content><![CDATA[<p><a href="https://loj.ac/problem/3052">[十二省联考2019]春节十二响</a> 这题本来应该是本蒟蒻唯一能A的题来着，结果考场拿了60分…考场上居然没看懂为什么1不一定是链的一端…自然也没发现显然的正解…是真的蠢了…</p>
<h3 id="考场暴力做法："><a href="#考场暴力做法：" class="headerlink" title="考场暴力做法："></a>考场暴力做法：</h3><p>考虑一个显然正确的贪心策略：排序，每次选一个最大的点，然后把所有可以和它放在一组的点全放进去。求两个点是否是祖先关系我用的树剖LCA。用链表小优化了一下，跳过选中的点。复杂度$O(n^3logn)$。</p>
<h3 id="正解："><a href="#正解：" class="headerlink" title="正解："></a>正解：</h3><p>其实如果看懂链的那个就全懂了…链的那个可以把连向1的两条链内点排序，每次选最大的。推广到一般情景，我们也可以递归处理，然后把处理好的子树看做链，合并就行。用启发式合并，$O(nlog^2n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">2333</span>;</span><br><span class="line"><span class="keyword">int</span> n, mem[N], id[N], num;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; son[N];</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; que[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    id[x] = ++num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; son[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = son[x][i];</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (que[id[y]].<span class="built_in">size</span>() &gt; que[id[x]].<span class="built_in">size</span>())</span><br><span class="line">            <span class="built_in">swap</span>(id[x], id[y]);</span><br><span class="line">        <span class="keyword">while</span> (!que[id[y]].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="built_in">max</span>(que[id[x]].<span class="built_in">top</span>(), que[id[y]].<span class="built_in">top</span>()));</span><br><span class="line">            que[id[x]].<span class="built_in">pop</span>();</span><br><span class="line">            que[id[y]].<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            que[id[x]].<span class="built_in">push</span>(st.<span class="built_in">top</span>());</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    que[id[x]].<span class="built_in">push</span>(mem[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        mem[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        son[<span class="built_in">rd</span>()].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (!que[id[<span class="number">1</span>]].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ans += (<span class="keyword">long</span> <span class="keyword">long</span>)que[id[<span class="number">1</span>]].<span class="built_in">top</span>();</span><br><span class="line">        que[id[<span class="number">1</span>]].<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>十二省联考2019异或粽子</title>
    <url>/2019/04/18/%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019%E5%BC%82%E6%88%96%E7%B2%BD%E5%AD%90/</url>
    <content><![CDATA[<p><a href="https://loj.ac/problem/3048">[十二省联考2019]异或粽子</a> 前置知识：可持久化Trie，超级钢琴的贪心。（这几天刚补习完…） 实际上这题和<a href="https://baka.online/noi2010%E8%B6%85%E7%BA%A7%E9%92%A2%E7%90%B4/">超级钢琴</a>长的特别像，贪心的方法都一样。然而xor前缀和不能用st表搞，改用可持久化Trie。枚举右端点插进堆里贪心就行了。$O(nlogn)$，据说这题有点卡常，不过我Trie是非递归的，吸氧之后无压力。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c -<span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">2333</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ch[N * <span class="number">100</span>][<span class="number">2</span>], sum[N * <span class="number">100</span>], root[N], pos[N * <span class="number">100</span>], num;</span><br><span class="line">ll pre[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = ++num, tmp = y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">35</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = (pre[p] &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        ch[y][t ^ <span class="number">1</span>] = ch[x][t ^ <span class="number">1</span>];</span><br><span class="line">        x = ch[x][t];</span><br><span class="line">        y = ch[y][t] = ++num;</span><br><span class="line">        sum[y] = sum[x] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pos[y] = p + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, ll val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">35</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = (val &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch[r][t ^ <span class="number">1</span>] - ch[l][t ^ <span class="number">1</span>])</span><br><span class="line">            l = ch[l][t ^ <span class="number">1</span>], r = ch[r][t ^ <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> l = ch[l][t], r = ch[r][t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos[r];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> o, l, r, t;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _o, <span class="keyword">int</span> _l, <span class="keyword">int</span> _r) &#123;</span><br><span class="line">        o = _o; l = _l; r = _r;</span><br><span class="line">        t = <span class="built_in">query</span>(root[l - <span class="number">1</span>], root[r], pre[o]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> (pre[a.o] ^ pre[a.t - <span class="number">1</span>]) &lt; (pre[b.o] ^ pre[b.t - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        pre[i] = pre[i - <span class="number">1</span>] ^ <span class="built_in">rd</span>();</span><br><span class="line">        root[i] = <span class="built_in">insert</span>(root[i - <span class="number">1</span>], i - <span class="number">1</span>);</span><br><span class="line">        que.<span class="built_in">push</span>(<span class="built_in">Node</span>(i, <span class="number">1</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        Node node = que.<span class="built_in">top</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">        ans += pre[node.t - <span class="number">1</span>] ^ pre[node.o];</span><br><span class="line">        <span class="keyword">if</span> (node.l != node.t)</span><br><span class="line">            que.<span class="built_in">push</span>(<span class="built_in">Node</span>(node.o, node.l, node.t - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (node.r != node.t)</span><br><span class="line">            que.<span class="built_in">push</span>(<span class="built_in">Node</span>(node.o, node.t + <span class="number">1</span>, node.r));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>乘法逆元</title>
    <url>/2019/01/05/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/</url>
    <content><![CDATA[<p>小学奥数都还给老师了… 对于$a$，且$a,p$互质，称$a \times x \equiv 1 \pmod p$中的$x$为$a$的逆元，记为$a^{-1}$ 文中数字默认都是正整数</p>
<h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p>我们都知道，若$p$为素数，有$a^{p} \equiv a \pmod p$ 若$a$不是$p$的倍数，则$a^{p-1} \equiv 1 \pmod p$ 所以$a \times x \equiv a^{p-1}$，$x \equiv a^{p-2}$ 直接上快速幂求$a^{p-2} \pmod p$即可</p>
<h2 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h2><p>要求$a \times x \equiv 1 \pmod p$，即求$a \times x + p \times y = 1$ 扩展欧几里得貌似跑的比快速幂快一些</p>
<h2 id="线性递推"><a href="#线性递推" class="headerlink" title="线性递推"></a>线性递推</h2><p>设$p = k \times i + j$，则有$k \times i + j \equiv 0 \pmod p$ 给左边乘上$i^{-1},j^{-1}$，由于$x \times x^{-1} = 1$，可化为$k \times j^{-1} + i ^{-1} \equiv 0 \pmod p$ $i^{-1} \equiv -k \times j^{-1} \pmod p$ 要把答案限制在范围内，可以通过$(x \% p+p) \% p$，此处不需要外面的取模 开数组储存值，得$a[i] = p-p/i \times a[p \% i] \% p$ 注意$a[1]=1$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    a[i] = p - p / i * a[p % i] % p;</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="阶乘逆元"><a href="#阶乘逆元" class="headerlink" title="阶乘逆元"></a>阶乘逆元</h2><p>$i! \times (i+1) \times a[i+1] \equiv 1 \pmod p$ $a[i] \equiv (i+1) \times a[i+1] \pmod p$ 倒着递推即可 <strong>Update 19.8.23：</strong></p>
<h2 id="离线求逆元"><a href="#离线求逆元" class="headerlink" title="离线求逆元"></a>离线求逆元</h2><p>黑科技。。 给定一组数$a_1,a_2…$，求逆元$b_1,b_2…$ 利用了一个前缀积的逆元是逆元的前缀积的思想。 构造前缀积$s_i$ $$s_n=\prod_{i=1}^na_i$$ $$\frac{1}{s_n}=\prod_{i=1}^n\frac{1}{a_i}$$ $$\frac{1}{s_{i-1&#125;&#125;=\frac{1}{s_i}a_i$$ $$\frac{1}{a_i}=s_{i-1}\frac{1}{s_i}$$</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SXOI2016题解</title>
    <url>/2020/05/12/sxoi2016%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>上古时代的题啊。。都没地方交。。找到题面了，口胡一下：</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>有一支n个人的队伍要过一座限重为W的桥，我们规定这支队伍过桥时只能分组过，即当一组全部过去后，下一组才能接着过。给定每个队员的重量wi和过桥时间ti，一组人的过桥时间为花费时间最多的人的时间。问如何分组使得总的过桥时间最短。 对于100%的数据，n≤16,100≤W≤400,1≤t≤50,10≤w≤100 题解：直接状压枚举子集就好了</p>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><p>定义$g_n$为把$n$拆分为正整数$x_1,x_2,…$的和，每一种方案所有贡献的和，其中贡献为$\prod f_{x_i}$，$f$是斐波那契数列。$n \leq 10^{18}$ 题解：简单DP：$g_n=\sum f_i g_{n-i}$。就可以打个表，发现$g_n=g_{n-1}+2g_{n-2}$。为什么大约可以归纳证明吧。</p>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p>给定n个回文串，s1,s2,…,sn。求有多少有序整数对 (i,j) 使得sisj 仍为回文串。 对于100%的数据，n≤2000000,m≤2000000 题解： 因为输入就是回文，冷静分析一下可以发现就是要求$(a,b)=(b,a)$有多少对。考虑Hash，$h_ab+h_b=h_ba+h_a$，整理可以把$a,b$放到两边，开个map就可以了 或者用Trie，短的在长的上跑，前后匹配打标记</p>
<h2 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h2><p>一个$10^5$的数列，$ans$定义为前缀$\max$和。单点修改并回答新的值。 题解： 如果没有修改，单调栈就好了。有修改就用线段树维护单调栈。节点上不维护单调栈具体的样子，只维护一些必要信息。合并左右的时候，左边的$\max$会影响右边，利用已知信息在右边二分到影响的位置即可。$O(nlog^2n)$</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>十二省联考2019皮配 背包DP</title>
    <url>/2020/04/26/%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019%E7%9A%AE%E9%85%8D-%E8%83%8C%E5%8C%85dp/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5289">[十二省联考2019]皮配</a> 题目描述太长是真的难受… 洛谷题解里有个很有意思的简化版题意：豆子有黄色绿色，圆粒皱粒。豆子有重量，每种性状的豆子有重量和上限。同时有一些豆子钦定不能有某种性状。告诉了有多少豆荚，每个豆荚里每个豆子，豆荚里豆子颜色要一样，求方案。 那么就有一种DP的想法：因为两对相对性状，和的数量都是$n$，令$f_{i,j}$表示有$i$的$C_0$，$j$的$D_0$的答案。可以$O(nm^2)$的做。又因为性状独立，当没有限制的时候可以分开做再乘起来，$O(nm)$。 因为特殊的豆子很少，考虑对没有特殊豆子的豆荚先做一个DP。对有特殊豆子的豆荚做一个高复杂度DP，组合起来。组合的话只需要枚举$i,j$，并且用前缀和优化。 考虑$f_{i,j}$的计算。虽然特殊豆子很少，但是它们所在的豆荚大小并没有给定一个小范围。那么必须考虑想办法把它们分开。那么可以考虑把整个豆荚的颜色放在一起DP，但是是圆是皱只对特殊豆子DP。 把$f$复制两份，分别表示两种颜色的方案。枚举豆荚内的特殊豆子，进行更新即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2505</span>, P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">  x -= P, x += x &lt; <span class="number">0</span> ? P : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, c, C0, C1, D0, D1, b[N], s[N], K, hate[N];</span><br><span class="line"><span class="keyword">int</span> city_s[N], sum_s, city_hate[N];</span><br><span class="line"><span class="keyword">int</span> f[N], g[N], h[N][N], t1[N][N], t2[N][N];</span><br><span class="line"><span class="keyword">int</span> ans, ss, sc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc_f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = std::<span class="built_in">max</span>(<span class="number">0</span>, sum_s - x - C1), r = C0 - x, ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= r) &#123;</span><br><span class="line">    ret = f[r];</span><br><span class="line">    <span class="keyword">if</span> (l != <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">check</span>(ret += P - f[l - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc_g</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = std::<span class="built_in">max</span>(<span class="number">0</span>, sum_s - x - D1), r = D0 - x, ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= r) &#123;</span><br><span class="line">    ret = g[r];</span><br><span class="line">    <span class="keyword">if</span> (l != <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">check</span>(ret += P - g[l - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(b));</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(s));</span><br><span class="line">  <span class="built_in">memset</span>(hate, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(hate));</span><br><span class="line">  <span class="built_in">memset</span>(city_s, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(city_s));</span><br><span class="line">  <span class="built_in">memset</span>(city_hate, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(city_hate));</span><br><span class="line">  sum_s = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">  <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(g));</span><br><span class="line">  <span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">  <span class="built_in">memset</span>(t1, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(t1));</span><br><span class="line">  <span class="built_in">memset</span>(t2, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(t2));</span><br><span class="line">  ans = <span class="number">0</span>;</span><br><span class="line">  ss = sc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  n = <span class="built_in">rd</span>(), c = <span class="built_in">rd</span>(), C0 = <span class="built_in">rd</span>(), C1 = <span class="built_in">rd</span>(), D0 = <span class="built_in">rd</span>(), D1 = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    b[i] = <span class="built_in">rd</span>(), s[i] = <span class="built_in">rd</span>();</span><br><span class="line">    city_s[b[i]] += s[i];</span><br><span class="line">    sum_s += s[i];</span><br><span class="line">  &#125;</span><br><span class="line">  K = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">rd</span>(), p = <span class="built_in">rd</span>();</span><br><span class="line">    hate[x] = p;</span><br><span class="line">    city_hate[b[x]] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (city_hate[i]  !city_s[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = C0; j &gt;= city_s[i]; --j)</span><br><span class="line">      <span class="built_in">check</span>(f[j] += f[j - city_s[i]]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hate[i] != <span class="number">-1</span>  !s[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = D0; j &gt;= s[i]; --j)</span><br><span class="line">      <span class="built_in">check</span>(g[j] += g[j - s[i]]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  h[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> city = <span class="number">1</span>; city &lt;= c; ++city) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!city_hate[city]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    sc = std::<span class="built_in">min</span>(sc + city_s[city], C0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sc; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= ss; ++j)</span><br><span class="line">        t1[i][j] = t2[i][j] = h[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> school = <span class="number">1</span>; school &lt;= n; ++school) &#123;</span><br><span class="line">      <span class="keyword">if</span> (b[school] != city  hate[school] == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      ss = std::<span class="built_in">min</span>(ss + s[school], D0);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = sc; ~i; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = ss; ~j; --j) &#123;</span><br><span class="line">          <span class="built_in">check</span>(t1[i][j] = (j &gt;= s[school] ? t1[i][j - s[school]] * (hate[school] != <span class="number">0</span>): <span class="number">0</span>) + t1[i][j] * (hate[school] != <span class="number">1</span>));</span><br><span class="line">          <span class="built_in">check</span>(t2[i][j] = (j &gt;= s[school] ? t2[i][j - s[school]] * (hate[school] != <span class="number">2</span>): <span class="number">0</span>) + t2[i][j] * (hate[school] != <span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sc; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= ss; ++j) &#123;</span><br><span class="line">        <span class="built_in">check</span>(h[i][j] = (i &gt;= city_s[city] ? t1[i - city_s[city]][j] : <span class="number">0</span>) + t2[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C0; ++i)</span><br><span class="line">    <span class="built_in">check</span>(f[i] += f[i - <span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= D0; ++i)</span><br><span class="line">    <span class="built_in">check</span>(g[i] += g[i - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sc; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= ss; ++j) &#123;</span><br><span class="line">      <span class="built_in">check</span>(ans += <span class="number">1ll</span> * h[i][j] * <span class="built_in">calc_f</span>(i) % P * <span class="built_in">calc_g</span>(j) % P);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">while</span> (T--)</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>反演 | 筛法 学习笔记</title>
    <url>/2019/08/12/%E5%8F%8D%E6%BC%94-%E7%AD%9B%E6%B3%95-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>最近被反演虐了，学习一个。</p>
<h2 id="反演部分"><a href="#反演部分" class="headerlink" title="反演部分"></a>反演部分</h2><h3 id="一种反演证明方法"><a href="#一种反演证明方法" class="headerlink" title="一种反演证明方法"></a>一种反演证明方法</h3><p>有这样的一个式子成立： $$f(n)=\sum_{i=0}^n a_{ni}g_i$$ 如果存在一组$b$ $$g_n=\sum_{i=0}^n b_{ni}f_i$$ 考虑存在的条件，带入得 $$g_n=\sum_{i=0}^nb_{ni}\sum_{j=0}^ia_{ij}g_j \ =\sum_{j=0}^n g_j \sum_{i=j}^n b_{nj}a_{ji} $$ 如果成立，一定有 $$\sum_{i=j}^n b_{nj}a_{ji} = [n=i]$$ 实际上，$a,b$互为逆矩阵。</p>
<hr>
<h3 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h3><p>$$f(n)=\sum_{k=0}^n \binom{n}{k}g(k)$$ $$g(n)=\sum_{k=0}^n (-1)^{n-k}\binom{n}{k}f(k)$$ 当然对于$\binom{k}{n}$也成立</p>
<hr>
<h3 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><p>定义莫比乌斯函数 $$\sum_{d \mid n} \mu(d) = [n=1]$$ $$f(n)=\sum_{d \mid n} g(d)$$ $$g(n) = \sum_{d \mid n} f(d) \mu(\frac{n}{d})$$ 还有一种形式，所有的$d \mid n$改成$n \mid d$，也成立。</p>
<hr>
<h3 id="子集反演"><a href="#子集反演" class="headerlink" title="子集反演"></a>子集反演</h3><p>这个其实才是裸容斥 $$f(S) = \sum_{T \subseteq S} g(T)$$ $$g(S) = \sum_{T \subseteq S} (-1)^{\mid S\mid - \mid T \mid} f(T)$$</p>
<hr>
<h3 id="斯特林反演"><a href="#斯特林反演" class="headerlink" title="斯特林反演"></a>斯特林反演</h3><p>咕咕咕。</p>
<hr>
<h3 id="单位根反演"><a href="#单位根反演" class="headerlink" title="单位根反演"></a>单位根反演</h3><p>$$[n \mid k] = \frac{1}{n} \sum_{i=0}^{n-1} \omega_{n}^{ki}$$ 证明：咕了，大约就是根据整除性分类讨论</p>
<hr>
<h3 id="一些反演会用到的东西"><a href="#一些反演会用到的东西" class="headerlink" title="一些反演会用到的东西"></a>一些反演会用到的东西</h3><p>$$\sum_{d \mid n} \mu(d)=[n=1]$$ $$\sum_{d \mid n} \varphi(d) = n$$ $$\sum_{d \mid n} \frac{\mu(d)}{d} = \frac{\varphi(n)}{n}$$ $$d(nm) = \sum_{i \mid n} \sum_{j \mid m}[gcd(i,j)=1] $$ 这个证明在这里<a href="https://baka.online/sdoi2015%e7%ba%a6%e6%95%b0%e4%b8%aa%e6%95%b0%e5%92%8c/">[SDOI2015]约数个数和</a> $$id= \sigma * \mu$$ 这个证明在这里<a href="https://baka.online/sdoi2014%e6%95%b0%e8%a1%a8/">[SDOI2014]数表</a> $$\mu * 1 = id$$ $$\mu * id = \varphi$$ $$\mu * 1 = \varepsilon$$ $$\varepsilon * 1 = 1$$</p>
<h2 id="筛法部分"><a href="#筛法部分" class="headerlink" title="筛法部分"></a>筛法部分</h2><h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><p>线性筛积性函数： 令$p \in prime$，需要可以快速计算$f(p),f(p^k)$。需要维护一个$low(x)$，表示$x$的最小质因子的指数。 筛$\sigma$： $$\sigma(p^k)=\sum_{i=0}^k p_i$$ 这个可以用等比求和优化。 筛$d$： $$d(i)=\prod_{i=1}^k (a_i+1)$$ $a_i$是质因子。</p>
<hr>
<h3 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h3><p>给定函数$f,g$ $$\sum_{i=1}^n(f * g)(i)=\sum_{i=1}^n\sum_{xy=i}f(x)g(y)=\sum_{y=1}^ng(y)\sum_{xy \leq n} f(x)\ =\sum_{y=1}^n g(y)S(\lfloor \frac{n}{y} \rfloor)$$ $$g(1)S(n)=\sum_{i=1}^n (f * g)(i) - \sum_{y=2}^ng(y)S(\lfloor\frac{n}{y}\rfloor)$$ 这个式子右边部分可以递归做。如果预处理$1$到$n^{\frac{2}{3&#125;&#125;$的答案，复杂度最优，$O(n^{\frac{2}{3&#125;&#125;)$。（不会证） 杜教筛要求可以快速求出$g,f * g$。 Update 2020.1.8：补充一些操作（来自<a href="http://jiruyi910387714.is-programmer.com/posts/195270.html">吉老师博客</a>）： 令$g$为完全积性函数： 求 $$S(n) = \sum_{i=1}^n (f \cdot g) (i)$$ $$((f \cdot g) * g ) (n) = \sum_{i \mid n} f(i) g(i) g( \frac{n}{i} ) = g(n) \sum_{i \mid n} f(i) = (g \cdot (f * 1)) (n)$$ 如果这个东西可以快速算，就可以杜教筛： $$S(n) = \sum_{i=1}^n ((f * 1) g) (i) - \sum_{i=2}^n S( \lfloor \frac{n}{i} \rfloor ) g(i) $$ 求 $$S(n) = \sum_{i=1}^n (f * g)(i)$$ 卷一个$1$ $$\sum_{i=1}^n (f * g * 1)(i) = \sum_{i=1}^n \sum_{d \mid i } g(d) (f * 1) (\frac{i}{d}) = \sum_{d=1}^n g(d) \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} (f * 1)(i) $$ 同样可以杜教筛 $$S(n) = \sum_{d=1}^n g(d) \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} (f * 1)(i) - \sum_{i=2}^n S(\lfloor \frac{n}{i} \rfloor)$$ 然而事实上可以杜教筛的很少，于是更了min25筛。。</p>
<hr>
<h3 id="Min-25筛"><a href="#Min-25筛" class="headerlink" title="Min_25筛"></a>Min_25筛</h3><p>Update 2020.1.8：终于不咕啦！！！ min25筛没有杜教筛那种找出方便计算的卷积的要求，只有两个：是简单多项式，可以快速算$f(p^k)$ 至于复杂度，证明比较麻烦，而且好像有争议，就先不管了。。。 定义$\min (x)$为数字$x$的最小质因子，$P_j$为第$j$个质数。 我们考虑把数分成三类：$1$，质数，合数。$1$显然可以最后加上，不考虑。用函数$S(n,j)$计算答案。 $$S(n,j) = \sum_{i=1}^n f(i) [ \min(p) \geq P_j ]$$ 那么可以枚举合数的最小质因子和最小质因子次数： （取整懒得打了，下同 $$S(n,j) = ans_{prime} + \sum_{k=j}^{P_k^2 \leq n} \sum_{e=1}^{P_k^{e+1} \leq n} S(\frac{n}{P_k^e}, k + 1) f(P_k^e ) + f(P_k^{e+1}) $$ 理解：因为是积性函数，可以去掉一个质数。此外这个质数的幂也被去掉了，需要单独加上。 也就是说计算出质数的答案就行了。 因为是简单多项式，只需求出质数次幂前缀和这种样子的式子就行了。 类似的定义一个$g(n,j)$ $$g(n,j) = \sum_{i=1}^n p^e [i \in prime \ or \ \min(p) &gt; P_j] $$ 这个式子可以看作作埃氏筛，筛掉了$ \leq P_j $后剩下的数，加上质数。 当$P_j^2 &gt; n$，不会筛掉数了。 $$g(n,j) = g(n, j - 1)$$ 否则有 $$g(n,j) = g(n, j - 1) - P_j^e (g(\frac{n}{P_j}, j - 1) - \sum_{ j = 1} ^{i - 1} P_j^e )$$ 理解：显然从$j-1$删一些数转移来。模拟埃氏筛，筛掉$P_j$，然后发现多删了一些，再加上。 可以发现，求出$g$后，问题迎刃而解。 $$S(n,j) = g(n, P) - \sum_{i=1}^{j-1} f(P_i) + \sum_{k=j}^{P_k^2 \leq n} \sum_{e=1}^{P_k^{e+1} \leq n} S(\frac{n}{P_k^e}, k + 1) f(P_k^e ) + f(P_k^{e+1}) $$ 代码实现有很多技巧，具体看例题题解</p>
<h3 id="LOJ-6503-简单的函数"><a href="#LOJ-6503-简单的函数" class="headerlink" title="LOJ 6503 简单的函数"></a>LOJ 6503 简单的函数</h3><p>Min25筛重要部分是求质数前缀和。 $$f(2) = 3, f(p) = p - 1 \ \ \ p &gt; 2$$ 无视$2$的，那么本题前缀和可以转化为求$\sum p$与$\sum [p]$。 令$g,h$分别表示这两个，套板子就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cerr;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sq, vis[N], prime[N], tot;</span><br><span class="line"><span class="keyword">int</span> sum_p[N];</span><br><span class="line"><span class="keyword">int</span> m, h[N], g[N];</span><br><span class="line">ll n, w[N];</span><br><span class="line"><span class="comment">// 用来存大下标的值</span></span><br><span class="line">std::unordered_map&lt;ll, <span class="keyword">int</span>&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">seive</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) prime[++tot] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; ++j) &#123;</span><br><span class="line">      vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (!(i % prime[j]))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// sum_p[] 是 p 的前缀和</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">    sum_p[i] = (sum_p[i - <span class="number">1</span>] + prime[i]) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">S</span><span class="params">(ll x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= <span class="number">1</span>  prime[y] &gt; x)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> k = map[x], ret = ((g[k] - h[k] - sum_p[y - <span class="number">1</span>] + y - <span class="number">1</span>) % P + P) % P;</span><br><span class="line">  <span class="comment">// 当存在 p = 2 的时候，因为它被错误计算，要加上</span></span><br><span class="line">  <span class="keyword">if</span> (y == <span class="number">1</span>) ret += <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = y; i &lt;= tot &amp;&amp; <span class="number">1ll</span> * prime[i] * prime[i] &lt;= x; ++i) &#123;</span><br><span class="line">    ll p1 = prime[i], p2 = <span class="number">1ll</span> * prime[i] * prime[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = <span class="number">1</span>; p2 &lt;= x; ++e, p1 = p2, p2 *= prime[i])</span><br><span class="line">      ret = (ret + <span class="number">1ll</span> * <span class="built_in">S</span>(x / p1, i + <span class="number">1</span>) * (prime[i] ^ e) % P + (prime[i] ^ (e + <span class="number">1</span>))) % P;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  sq = std::<span class="built_in">sqrt</span>(n); <span class="comment">// sqrt</span></span><br><span class="line">  <span class="built_in">seive</span>(sq); <span class="comment">// 初始化</span></span><br><span class="line">  <span class="comment">// 计算 g(n, 0), h(n, 0)</span></span><br><span class="line">  <span class="comment">// 值即 2 &lt;= i &lt;= n 的 i 全部当成质数代入的值</span></span><br><span class="line">  <span class="keyword">for</span> (ll l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 整除分块，只有这些值是需要的</span></span><br><span class="line">    r = n / (n / l);</span><br><span class="line">    w[++m] = n / l;</span><br><span class="line">    map[w[m]] = m;</span><br><span class="line">    h[m] = (w[m] - <span class="number">1</span>) % P;</span><br><span class="line">    g[m] = ((w[m] + <span class="number">2</span>) % P) * ((w[m] - <span class="number">1</span>) % P) % P;</span><br><span class="line">    <span class="keyword">if</span> (g[m] &amp; <span class="number">1</span>)</span><br><span class="line">      g[m] += P;</span><br><span class="line">    g[m] /= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 因为只需要 g(n, P) 这样的值</span></span><br><span class="line">  <span class="comment">// 数组只需要一维</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; ++j)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m &amp;&amp; <span class="number">1ll</span> * prime[j] * prime[j] &lt;= w[i]; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> k = map[w[i] / prime[j]];</span><br><span class="line">      g[i] = (g[i] - <span class="number">1ll</span> * prime[j] * (g[k] - sum_p[j - <span class="number">1</span>]) % P + P) % P;</span><br><span class="line">      h[i] = (h[i] - h[k] + j - <span class="number">1</span> + P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">S</span>(n, <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>哈希冲突</title>
    <url>/2019/04/10/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3396">哈希冲突</a> 很多这种在序列上有修改查询操作，一个$O(1)$一个$O(n)$的题都可以分块把两种操作都变成$O(\sqrt n)$。本题可以预处理模$\leq \sqrt n$的答案，然后$&gt; \sqrt n$的暴力查询，修改就重置预处理的答案就行了。复杂度$O(n^{1.5})$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c -<span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">150000</span> + <span class="number">233</span>, SQRTN = <span class="number">400</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], block, mod[SQRTN][SQRTN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= block; ++j)</span><br><span class="line">            mod[j][i % j] += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">char</span> opt[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, opt);</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">if</span> (*opt == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt;= block)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mod[x][y]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = y; i &lt;= n; i += x)</span><br><span class="line">                    sum += a[i];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= block; ++i)</span><br><span class="line">                mod[i][x % i] += y - a[x];</span><br><span class="line">            a[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> kai586123::<span class="built_in">main</span>(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>国家集训队旅游</title>
    <url>/2019/03/01/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E6%97%85%E6%B8%B8/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1505">[国家集训队]旅游</a> 230行代码 半小时打完 无DEBUG过样例 一次AC 我好爽啊！！！！！！！ 这题可以说是个树链剖分板子题。本题要处理的是边权，树剖处理的是点权。这时候只需要在dfs的时候把边权下放就好了。注意两点的LCA处点权不能用于计算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500000</span> + <span class="number">2333</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> to, nxt, c;</span><br><span class="line">    &#125; g[N];</span><br><span class="line">    <span class="keyword">int</span> head[N], tot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        g[++tot].to = y, g[tot].nxt = head[x],</span><br><span class="line">        g[tot].c = c, head[x] = tot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> w[N], fa[N], son[N], size[N], dep[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">        fa[x] = f, dep[x] = dep[f] + <span class="number">1</span>, size[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">            <span class="keyword">if</span> (y != f) &#123;</span><br><span class="line">                <span class="built_in">dfs1</span>(y, x);</span><br><span class="line">                w[y] = g[i].c;</span><br><span class="line">                size[x] += size[y];</span><br><span class="line">                <span class="keyword">if</span> (size[y] &gt; size[son[x]])</span><br><span class="line">                    son[x] = y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> wt[N], id[N], num, top[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line">        id[x] = ++num, wt[num] = w[x], top[x] = topf;</span><br><span class="line">        <span class="keyword">if</span> (son[x]) &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(son[x], topf);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">                <span class="keyword">if</span> (y != fa[x] &amp;&amp; y != son[x])</span><br><span class="line">                    <span class="built_in">dfs2</span>(y, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> l, r, sum, min, max;</span><br><span class="line">        <span class="keyword">bool</span> rev;</span><br><span class="line">    &#125; t[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls(p) p &lt;&lt; 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs(p) p &lt;&lt; 1  1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        t[p].max = <span class="built_in">max</span>(t[<span class="built_in">ls</span>(p)].max, t[<span class="built_in">rs</span>(p)].max);</span><br><span class="line">        t[p].min = <span class="built_in">min</span>(t[<span class="built_in">ls</span>(p)].min, t[<span class="built_in">rs</span>(p)].min);</span><br><span class="line">        t[p].sum = t[<span class="built_in">ls</span>(p)].sum + t[<span class="built_in">rs</span>(p)].sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t[p].rev) &#123;</span><br><span class="line">            t[<span class="built_in">ls</span>(p)].rev = !t[<span class="built_in">ls</span>(p)].rev;</span><br><span class="line">            t[<span class="built_in">rs</span>(p)].rev = !t[<span class="built_in">rs</span>(p)].rev;</span><br><span class="line">            t[p].rev = !t[p].rev;</span><br><span class="line">            t[<span class="built_in">ls</span>(p)].sum = -t[<span class="built_in">ls</span>(p)].sum;</span><br><span class="line">            t[<span class="built_in">rs</span>(p)].sum = -t[<span class="built_in">rs</span>(p)].sum;</span><br><span class="line">            <span class="built_in">swap</span>(t[<span class="built_in">ls</span>(p)].min, t[<span class="built_in">ls</span>(p)].max);</span><br><span class="line">            t[<span class="built_in">ls</span>(p)].min = -t[<span class="built_in">ls</span>(p)].min;</span><br><span class="line">            t[<span class="built_in">ls</span>(p)].max = -t[<span class="built_in">ls</span>(p)].max;</span><br><span class="line">            <span class="built_in">swap</span>(t[<span class="built_in">rs</span>(p)].min, t[<span class="built_in">rs</span>(p)].max);</span><br><span class="line">            t[<span class="built_in">rs</span>(p)].min = -t[<span class="built_in">rs</span>(p)].min;</span><br><span class="line">            t[<span class="built_in">rs</span>(p)].max = -t[<span class="built_in">rs</span>(p)].max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        t[p].l = l, t[p].r = r;</span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">            t[p].sum = t[p].min = t[p].max = wt[l];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">build</span>(<span class="built_in">ls</span>(p), l, mid);</span><br><span class="line">            <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">            <span class="built_in">push_up</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t[p].l == t[p].r)</span><br><span class="line">            t[p].sum = t[p].min = t[p].max = v;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">push_down</span>(p);</span><br><span class="line">            <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">change</span>(<span class="built_in">ls</span>(p), x, v);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">change</span>(<span class="built_in">rs</span>(p), x, v);</span><br><span class="line">            <span class="built_in">push_up</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) &#123;</span><br><span class="line">            t[p].rev = !t[p].rev;</span><br><span class="line">            t[p].sum = -t[p].sum;</span><br><span class="line">            <span class="built_in">swap</span>(t[p].min, t[p].max);</span><br><span class="line">            t[p].min = -t[p].min;</span><br><span class="line">            t[p].max = -t[p].max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">push_down</span>(p);</span><br><span class="line">            <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">                <span class="built_in">reverse</span>(<span class="built_in">ls</span>(p), l, r);</span><br><span class="line">            <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">                <span class="built_in">reverse</span>(<span class="built_in">rs</span>(p), l, r);</span><br><span class="line">            <span class="built_in">push_up</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (opt == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> t[p].sum;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> t[p].max;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> t[p].min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">push_down</span>(p);</span><br><span class="line">            <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>, ans;</span><br><span class="line">            <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">                ans = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">                    ans += <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r, opt);</span><br><span class="line">                <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">                    ans += <span class="built_in">query</span>(<span class="built_in">rs</span>(p), l, r, opt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">                ans = -INF;</span><br><span class="line">                <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r, opt));</span><br><span class="line">                <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(<span class="built_in">rs</span>(p), l, r, opt));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = INF;</span><br><span class="line">                <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">                    ans = <span class="built_in">min</span>(ans, <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r, opt));</span><br><span class="line">                <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">                    ans = <span class="built_in">min</span>(ans, <span class="built_in">query</span>(<span class="built_in">rs</span>(p), l, r, opt));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">vertex_change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>, id[x], v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">range_reverse</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]])</span><br><span class="line">                <span class="built_in">swap</span>(x, y);</span><br><span class="line">            <span class="built_in">reverse</span>(<span class="number">1</span>, id[top[x]], id[x]);</span><br><span class="line">            x = fa[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (id[x] &gt; id[y])</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="built_in">reverse</span>(<span class="number">1</span>, id[x] + <span class="number">1</span>, id[y]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">range_query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) ans = -INF;</span><br><span class="line">        <span class="keyword">else</span> ans = INF;</span><br><span class="line">        <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]])</span><br><span class="line">                <span class="built_in">swap</span>(x, y);</span><br><span class="line">            <span class="keyword">if</span> (opt == <span class="number">1</span>)</span><br><span class="line">                ans += <span class="built_in">query</span>(<span class="number">1</span>, id[top[x]], id[x], opt);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>)</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(<span class="number">1</span>, id[top[x]], id[x], opt));</span><br><span class="line">            <span class="keyword">else</span> ans = <span class="built_in">min</span>(ans, <span class="built_in">query</span>(<span class="number">1</span>, id[top[x]], id[x], opt));</span><br><span class="line">            x = fa[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (id[x] &gt; id[y])</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>)</span><br><span class="line">            ans += <span class="built_in">query</span>(<span class="number">1</span>, id[x] + <span class="number">1</span>, id[y], opt);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(<span class="number">1</span>, id[x] + <span class="number">1</span>, id[y], opt));</span><br><span class="line">        <span class="keyword">else</span> ans = <span class="built_in">min</span>(ans, <span class="built_in">query</span>(<span class="number">1</span>, id[x] + <span class="number">1</span>, id[y], opt));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">rd</span>() + <span class="number">1</span>, y = <span class="built_in">rd</span>() + <span class="number">1</span>, c = <span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">addedge</span>(x, y, c), <span class="built_in">addedge</span>(y, x, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> opt[<span class="number">10</span>]; <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, opt);</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">rd</span>() + <span class="number">1</span>, y = <span class="built_in">rd</span>() + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">                <span class="built_in">vertex_change</span>(x, --y);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">&#x27;N&#x27;</span>)</span><br><span class="line">                <span class="built_in">range_reverse</span>(x, y);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">range_query</span>(x, y, <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (opt[<span class="number">1</span>] == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">range_query</span>(x, y, <span class="number">2</span>));</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">range_query</span>(x, y, <span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>国家集训队聪聪可可</title>
    <url>/2019/01/15/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E8%81%AA%E8%81%AA%E5%8F%AF%E5%8F%AF/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2634">[国家集训队]聪聪可可</a> 点分治，统计的是距离之和是3的倍数的点对。 观察样例解释，发现自己和自己构成一种情况。这个可以在最终输出答案时加上。观察发现(x, y)与(y, x)算不同的答案，运算后x2即可。 由模运算的运算性质可知，两数mod 3之和mod 3为0即为一对答案。点分治，一颗一颗子树加入数组。因为3的倍数自身就是一个答案，每次初始化数组时把模为0的个数设为1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">20000</span> + <span class="number">2333</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">G</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt, c;</span><br><span class="line">&#125; g[MAXN * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> N, head[MAXN], tot, root, maxson, sz[MAXN], dis[MAXN], mod[<span class="number">3</span>], ans;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    g[++tot].to = y, g[tot].nxt = head[x],</span><br><span class="line">    g[tot].c = c, head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> all)</span> </span>&#123;</span><br><span class="line">    sz[x] = <span class="number">1</span>; <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y = g[i].to; i; i = g[i].nxt, y = g[i].to) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y != fa &amp;&amp; !vis[y]) &#123;</span><br><span class="line">            <span class="built_in">get_root</span>(y, x, all);</span><br><span class="line">            sz[x] += sz[y];</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, sz[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mx = <span class="built_in">max</span>(mx, all - sz[x]);</span><br><span class="line">    <span class="keyword">if</span> (mx &lt; maxson)</span><br><span class="line">        maxson = mx, root = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    dis[++dis[<span class="number">0</span>]] = d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y = g[i].to; i; i = g[i].nxt, y = g[i].to)</span><br><span class="line">        <span class="keyword">if</span> (y != fa &amp;&amp; !vis[y])</span><br><span class="line">            <span class="built_in">get_dis</span>(y, x, d + g[i].c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfz</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    maxson = INT_MAX;</span><br><span class="line">    <span class="built_in">get_root</span>(x, <span class="number">-1</span>, sz[x]);</span><br><span class="line">    x = root;</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    mod[<span class="number">0</span>] = <span class="number">1</span>, mod[<span class="number">1</span>] = mod[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y = g[i].to; i; i = g[i].nxt, y = g[i].to) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[y]) &#123;</span><br><span class="line">            dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">get_dis</span>(y, x, g[i].c);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = dis[<span class="number">0</span>]; j; --j)</span><br><span class="line">                ans += mod[(<span class="number">3</span> - dis[j] % <span class="number">3</span>) % <span class="number">3</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = dis[<span class="number">0</span>]; j; --j)</span><br><span class="line">                ++mod[dis[j] % <span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y = g[i].to; i; i = g[i].nxt, y = g[i].to)</span><br><span class="line">        <span class="keyword">if</span> (!vis[y]) <span class="built_in">dfz</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y == <span class="number">0</span> ? x : <span class="built_in">gcd</span>(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>(), c = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">addedge</span>(x, y, c), <span class="built_in">addedge</span>(y, x, c);</span><br><span class="line">    &#125;</span><br><span class="line">    sz[<span class="number">1</span>] = N, <span class="built_in">dfz</span>(<span class="number">1</span>);</span><br><span class="line">    ans = ans * <span class="number">2</span> + N;</span><br><span class="line">    <span class="keyword">int</span> g_c_d = <span class="built_in">gcd</span>(ans, N * N);</span><br><span class="line">    cout &lt;&lt; ans / g_c_d &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; N * N / g_c_d &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>国家集训队最长双回文串</title>
    <url>/2019/06/02/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E6%9C%80%E9%95%BF%E5%8F%8C%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4555">[国家集训队]最长双回文串</a> 见回文串想到manacher，manacher不但能求出来最长回文串，也能求出来每个位置为中心的最长回文串。这样就可以求出来以每个位置开始或结尾的最长的回文串的长度。 这题要求必须分割，所以要判断两个数字是不是都有值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = (<span class="number">1e5</span> + <span class="number">233</span>) * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span> ch[N] = &#123;<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;#&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>, p[N], r, mid, ans, L[N], R[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isalpha</span>(c))</span><br><span class="line">        ch[++tot] = c, ch[++tot] = <span class="string">&#x27;#&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; r) p[i] = <span class="built_in">min</span>(p[mid * <span class="number">2</span> - i], r - i);</span><br><span class="line">        <span class="keyword">else</span> p[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ch[i - p[i]] == ch[i + p[i]]) ++p[i];</span><br><span class="line">        <span class="keyword">if</span> (p[i] + i &gt; r) r = p[i] + i, mid = i;</span><br><span class="line">        L[i + p[i] - <span class="number">1</span>] = <span class="built_in">max</span>(L[i + p[i] - <span class="number">1</span>], p[i] - <span class="number">1</span>);</span><br><span class="line">        R[i - p[i] + <span class="number">1</span>] = <span class="built_in">max</span>(R[i - p[i] + <span class="number">1</span>], p[i] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= tot; i += <span class="number">2</span>)</span><br><span class="line">        R[i] = <span class="built_in">max</span>(R[i], R[i - <span class="number">2</span>] - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tot; i &gt;= <span class="number">1</span>; i -= <span class="number">2</span>)</span><br><span class="line">        L[i] = <span class="built_in">max</span>(L[i], L[i + <span class="number">2</span>] - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i += <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (L[i] &amp;&amp; R[i])</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, L[i] + R[i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>国王奇遇记 线性插值</title>
    <url>/2020/01/16/%E5%9B%BD%E7%8E%8B%E5%A5%87%E9%81%87%E8%AE%B0-%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4126">国王奇遇记加强版之再加强版</a> 本题有$O(m^2)$做法，网上很多，这里只有$O(m)$。 题意：求 $$\sum_{i=1}^n i^m m^i$$ 令$F_m(n)$等于这个式子。经过大胆打表看题解，可以知道 $$F_m(n) = m^n P_m(n) - P_m(0)$$ 其中$P_m$是$m$次多项式。 下面开始不写$_m$了，懒w 这个结论虽然不知道怎么想出来的，但是可以证明，大约想法就是归纳+差分。 考虑怎么求$P$： $$F(n+1) - F(n) = (n+1)^m m^{n+1} = m^{n+1} P(n+1) - m^n P(n) $$ $$P(n+1) = \frac{P(n)}{m} + (m+1)^m$$ 把$P(n)$表示为$AP(0)+B$。 因为$P$是$m$次多项式，做$m+1$次差分： $$\sum_{i=0}^{m+1} \binom{m+1}{i} (-1)^{m - i} P(i) = 0 $$ 就可以解出$A,B$啦。 <a href="http://blog.miskcoo.com/2015/08/special-polynomial-linear-interpolation">这篇文章</a>中有一种给出$1,m+1$处点值插值的方法，推到用到了很多组合技巧，很有意思。 不过其实直接拉格朗日插值就行。。。结合一些预处理可以做到$O(m)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500000</span> + <span class="number">233</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">fpow</span><span class="params">(ll x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  ll ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = x * x % P)</span><br><span class="line">    <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = ret * x % P;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll fac[N], inv[N], inv_num[N], pre[N], pow_m[N],</span><br><span class="line">  A[N], B[N], p[N], pre_all[N], suf_all[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[N], vis[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  pow_m[<span class="number">0</span>] = pow_m[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">      prime[++tot] = i;</span><br><span class="line">      pow_m[i] = <span class="built_in">fpow</span>(i, m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= m + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">      vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">      pow_m[i * prime[j]] = pow_m[i] * pow_m[prime[j]] % P;</span><br><span class="line">      <span class="keyword">if</span> (!(i % prime[j]))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = fac[<span class="number">0</span>] = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; ++i)</span><br><span class="line">    fac[i] = fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line">  inv[m + <span class="number">1</span>] = <span class="built_in">fpow</span>(fac[m + <span class="number">1</span>], P - <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = m + <span class="number">1</span>; i; --i)</span><br><span class="line">    inv[i - <span class="number">1</span>] = inv[i] * i % P;</span><br><span class="line">  inv_num[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m + <span class="number">1</span>; ++i)</span><br><span class="line">    inv_num[i] = P - <span class="number">1ll</span> * P / i * inv_num[P % i] % P;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = pre_all[<span class="number">0</span>] = suf_all[m + <span class="number">2</span>] = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; ++i)</span><br><span class="line">    pre_all[i] = pre_all[i - <span class="number">1</span>] * (n - i) % P;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = m + <span class="number">1</span>; i; --i)</span><br><span class="line">    suf_all[i] = suf_all[i + <span class="number">1</span>] * (n - i) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A[<span class="number">0</span>] = <span class="number">1</span>, A[<span class="number">1</span>] = inv_num[m], B[<span class="number">1</span>] = pow_m[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    A[i] = A[i - <span class="number">1</span>] * inv_num[m] % P;</span><br><span class="line">    B[i] = (B[i - <span class="number">1</span>] * inv_num[m] % P + pow_m[i]) % P;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> sum_A = <span class="number">0</span>, sum_B = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp = fac[m + <span class="number">1</span>] * inv[i] % P * inv[m + <span class="number">1</span> - i] % P;</span><br><span class="line">    <span class="keyword">if</span> ((m - i) &amp; <span class="number">1</span>)</span><br><span class="line">      tmp = P - tmp;</span><br><span class="line">    sum_A = (sum_A + tmp * A[i]) % P;</span><br><span class="line">    sum_B = (sum_B + tmp * B[i]) % P;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p[<span class="number">0</span>] = P - sum_B * <span class="built_in">fpow</span>(sum_A, P - <span class="number">2</span>) % P;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; ++i)</span><br><span class="line">    p[i] = (A[i] * p[<span class="number">0</span>] + B[i]) % P;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp = p[i];</span><br><span class="line">    tmp = tmp * pre_all[i - <span class="number">1</span>] % P * suf_all[i + <span class="number">1</span>] % P;</span><br><span class="line">    tmp = tmp * inv[i - <span class="number">1</span>] % P * inv[m + <span class="number">1</span> - i] % P;</span><br><span class="line">    <span class="keyword">if</span> ((m + <span class="number">1</span> - i) &amp; <span class="number">1</span>)</span><br><span class="line">      tmp = P - tmp;</span><br><span class="line">    ret = (ret + tmp) % P;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ret = <span class="built_in">fpow</span>(m, n) * ret % P - p[<span class="number">0</span>];</span><br><span class="line">  ret = (ret % P + P) % P;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> std::cout &lt;&lt; <span class="number">1ll</span> * n * (n + <span class="number">1</span>) / <span class="number">2</span> &lt;&lt; std::endl, <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">if</span> (m &gt;= n) &#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>, tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      tmp = tmp * m % P;</span><br><span class="line">      ans = (ans + pow_m[i] * tmp) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">solve</span>() &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>图论题解</title>
    <url>/2020/07/10/%E5%9B%BE%E8%AE%BA%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>人比较菜，找的题也垃圾，轻点喷</p>
<h2 id="GYM102114A-Always-Online"><a href="#GYM102114A-Always-Online" class="headerlink" title="[GYM102114A] Always Online"></a>[GYM102114A] Always Online</h2><p>题意：仙人掌，求最大流异或和。 考虑环，那么注意到如果选环，环上最小的边一定会被割，直接把它割开，边权加在其它边上。之后按边权合并即可</p>
<h2 id="CF1240F-Football"><a href="#CF1240F-Football" class="headerlink" title="[CF1240F] Football"></a>[CF1240F] Football</h2><p>题意：给一张图，选一些边，为每条边分配一个$[1,k]$的值，使得对于每个点的出边，值的出现次数极差$\leq 2$。构造解，最大化$\sum w_i deg_i$。 枚举每一条边，考虑染色：如果有可用的方法，就直接染上。否则考虑对原图进行修改。考虑什么时候加不上新边。可以把一个点出边出现次数化为$0,1,2$。如果不存在可行边，要求不存在颜色在两边出现次数都$&lt; 2$。考虑选择颜色$A$，在$x$出现$2$次，在$y$出现$0$次。$B$同理。 之后选$x,y$中的一个点为起点，走一条$BA$交错的路。之后把它反转。可以发现这样的路一定可以找到，并且反转后，一定可以加入新边。</p>
<h2 id="LibreOJ-β-Round-7-网格图"><a href="#LibreOJ-β-Round-7-网格图" class="headerlink" title="[LibreOJ β Round #7] 网格图"></a>[LibreOJ β Round #7] 网格图</h2><p>题意：网格图内有$K$个障碍，钦定起点，多次询问到终点的距离。其中距离指转向次数。 首先把没用的缩起来：如果多行没有障碍，缩成一行。之后再把连续无障碍的段缩在一起，点数就是$O(K)$了。考虑优化边数：以行向列连边为例，考虑对于每一行，维护一棵线段树。那么连边就变成了区间连边。 具体来说，因为如果横着的是连续的，那么跨过它的一定也连续，所以主席树优化即可。之后BFS就可以了。</p>
<h2 id="JOISC-2016-Day-3-电报"><a href="#JOISC-2016-Day-3-电报" class="headerlink" title="[JOISC 2016 Day 3] 电报"></a>[JOISC 2016 Day 3] 电报</h2><p>题意：给一张图，每个点的出度均为$1$。每个点有代价$c_i$，表示改变它出边指向的代价。最小代价使图变强连通 考虑如何变为强连通：把图断成若干链，再拼起来。如果只有树，那么贪心留下每个点入边最大的就可以了。如果是环，继续这么做。但是可能选了一整个环。特判掉就好了。</p>
<h2 id="IOI2017-古书"><a href="#IOI2017-古书" class="headerlink" title="[IOI2017] 古书"></a>[IOI2017] 古书</h2><p>题意：给一个排列$p$，要把$i$位置的书运到$p_i$位置。从一个位置走到另一个位置的代价是$i-j$。任意时刻，手上可以拿最多一本书。可以拿起，放下，交换，取决于当前位置和自己有没有书。一开始有起点$s$，求最小代价。 先假设起点是$1$。把排列变成图。我们称答案的下界$d(p)=\sum{i-p_i}$。 如果只有一个环，答案是$d(p)$。如果有两个环，则当它们不交时，答案是$d(p)+2$，否则是$d(p)$。推广一下，当有多个环，答案是$d(p)+2E$，其中$E$是没有被环边跨过的边集。 当起点不为$1$时，考虑把和起点相交的环缩在一起。在走的过程中一定会经过边界，那么此时直接走到其它环进行上面的做法即可。 当起点不为$1$时，可能起点被大环套在里面。那么走到大环上需要额外的代价。这个代价可以用最短路求出。</p>
<h2 id="SDOI2019-世界地图"><a href="#SDOI2019-世界地图" class="headerlink" title="[SDOI2019] 世界地图"></a>[SDOI2019] 世界地图</h2><p>题意：给一个网格图，且特别的，网格图左右相连，上下不相连。每次给一个左右区间，求删掉后的MST。$n \leq 100, m \leq 10000$ 求一个前缀MST，求一个后缀MST，合并即可。问题就是如何维护MST。以前缀为例：加入一排点的时候，会影响之前的一些链。链满足两端点都在上一排点。所以维护一个MST的虚树就可以了。</p>
<h2 id="AGC017E-Jigsaw"><a href="#AGC017E-Jigsaw" class="headerlink" title="[AGC017E] Jigsaw"></a>[AGC017E] Jigsaw</h2><p>题意：有条状拼图：中间有一条，左右各有悬空的一条。中间的高度给定。现在要把拼图横着放，满足没有块有左右悬空。判断是否可行。 如果有悬空的，下一块必须不悬空。并且高度相同。定义拼图左右各有一个权值，取决于它是否悬空，以及它在左边还是右边。把左右权值连边。那么就是要找若干条边不交的路径，覆盖整个图，并且特别的，钦定了起点终点类型。 考虑新建一个源点作为起点，路径就变成了回路。考虑入点，入度不能大于出度，出点出度不能大于入度。 特别的，联通块必须存在入出度不等的点。这是因为如果不存在，那么只能对一个点加两条边，不合法。而只要存在一个点不等，就会存在另一个点对称的不等。</p>
<h2 id="ARC092D-Two-Faced-Edges"><a href="#ARC092D-Two-Faced-Edges" class="headerlink" title="[ARC092D] Two Faced Edges"></a>[ARC092D] Two Faced Edges</h2><p>题意：有向图，对于每条边求改变方向后强连通分量数量是否改变 可以发现问题等价于删掉这条边后，是否$x$可以到达$y$和$y$可以到达$x$恰有一个成立。考虑第一个问题怎么做。本质上不经过$(x,y)$就是不经过$x$点。于是删掉$x$点，枚举出点，求是否存在两条到$y$的路。考虑优化，$y$点直接从$(x,y)$经过一次，从任意一个点经过一次，也就是经过两次即可，所以任意点如果已经被经过两次就不用BFS了。</p>
<h2 id="AGC004F-Namori"><a href="#AGC004F-Namori" class="headerlink" title="[AGC004F] Namori"></a>[AGC004F] Namori</h2><p>题意：树或者基环树，可以选一条边，如果两端点颜色相同，同时变色。一开始是白色，求最小变成黑色的次数。 把树黑白染色，之后问题转化为把树上每种颜色取反。这样可以把操作看作swap相邻的颜色。 对于树，贪心的求出每条边需要被经过多少次即可。令两种颜色分别为$1,-1$，维护$f_u$表示子树和。如果根的值不为$0$无解 对于环，删掉一条边当作树先做一下 如果是偶环：这条边假设被走了$x$次，则考虑这条边的两端点到LCA的路径，一个$+x$，一个$-x$。如果直接用DFS树，那么只需对每个点的$f$排序，取中位数为$x$即可 如果是奇环：之前定义操作一条边是swap颜色，但是现在奇环上的边两端颜色相同，所以可以看作是同时把某种颜色数量$+-2$。这条路不可以用来当捷径，所以操作它是不优的。但是它可以改变根的值，所以如果无解可以改为有解。</p>
<h2 id="AGC003F-Fraction-of-Fractal"><a href="#AGC003F-Fraction-of-Fractal" class="headerlink" title="[AGC003F] Fraction of Fractal"></a>[AGC003F] Fraction of Fractal</h2><p>题意：给$01$矩阵。定义$k$级分型是$k-1$级分型中每个$1$的位置放一个$k-1$级分形得到的矩阵。求$k$级分型连通块数。$K \leq 10^{18}$ 首先特判一下不连通的块。如果任意方向两个块都联通，最终图也是联通的。所以只剩下了在左右/上下联通的图。以竖着联通为例，那么可以有这样的推论：最终的图一定是多个竖着的联通条。操作一次会合并若干联通条。 考虑知道了$i-1$的答案，求$i$的。可以发现就是上一次的数量乘一下，减去合并的数量。合并的数量取决于原图中竖着拼起来合并了多少。于是可以矩阵乘法。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>在农场万圣节</title>
    <url>/2019/01/05/%E5%9C%A8%E5%86%9C%E5%9C%BA%E4%B8%87%E5%9C%A3%E8%8A%82/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2921">P2921 [USACO08DEC]在农场万圣节Trick or Treat on the Farm</a> 学了Tarjan准备缩点，冷静分析后发现暴力DFS就能做 DFS思路：因为是只有一条出边的有向图，DFS找环，然后更新环上答案为环的大小，其它点答案为到环距离+环的大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快读和头文件没复制</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> n, nxt[MAXN], d[MAXN], ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[x] = dep;</span><br><span class="line">    <span class="keyword">int</span> y = nxt[x];</span><br><span class="line">    <span class="keyword">if</span> (d[y] &amp;&amp; !ans[y]) &#123;</span><br><span class="line">        ans[x] = d[x] - d[y] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; y != x; ans[y] = ans[x], y = nxt[y]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d[y] &amp;&amp; ans[y])</span><br><span class="line">        ans[x] = ans[y] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(y, dep + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!ans[x])</span><br><span class="line">            ans[x] = ans[y] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        nxt[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!d[i])</span><br><span class="line">            <span class="built_in">dfs</span>(i, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>地铁涨价断边最短路</title>
    <url>/2019/01/11/%E5%9C%B0%E9%93%81%E6%B6%A8%E4%BB%B7%E6%96%AD%E8%BE%B9%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1710">地铁涨价</a> 这题需要断边的同时维护最短路，我们可以反过来考虑，一次性读入所有的断边，全部断开，再动态加回去。 首先在原图上求出每个点的最短路，然后建新图，把边加回去。 每加一条边，检查连接着的两个节点。如果一个节点此时的距离已经是最短距离，另一个则不是，则从这个点出发更新可以更新的最短路。 每次加边时，只有其中一个点的距离已经是最短路，才有可能在这次加边之后直接对其它点是否达到最短距离产生影响。而如果两个点都已经到最短路，则之前已经在加其它边的时候进行过更新。所以这个算法是正确的。 因为只在每个点可以被更新成原图上最短距离时进行更新一次，所以每个点只会被更新一次。复杂度为O(N)。 代码不放了qwq</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>基础最优化练习题 费用流贪心</title>
    <url>/2019/11/14/%E5%9F%BA%E7%A1%80%E6%9C%80%E4%BC%98%E5%8C%96%E7%BB%83%E4%B9%A0%E9%A2%98-%E8%B4%B9%E7%94%A8%E6%B5%81%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P5653">P5653 基础最优化练习题</a> 很不错的贪心题. $$ans = \sum_{i=1}^n b_i w_i $$ $$=\sum_{i=1}^n \Delta b_i \sum_{j=i}^n w_j$$ 记录$w$的后缀和$s$,然后建立费用流模型: 对于$i \in [1,n]$,和源点汇点都连边,然后两个点之间连边是$a$ 显然这张图的最小费用就是答案 考虑用堆模拟费用流 一个一个点的考虑,如果被$a$限制,则考虑退流,选择之前费用最小的一条边退即可 $O(nlogn)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], w[N];</span><br><span class="line">ll s[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> flow;</span><br><span class="line">  ll cost;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b) &#123;</span><br><span class="line">  <span class="keyword">return</span> a.cost &gt; b.cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::priority_queue&lt;Node&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    a[i] = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    w[i] = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i)</span><br><span class="line">    s[i] = s[i + <span class="number">1</span>] + w[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, now = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      ans += m * s[i];</span><br><span class="line">      que.<span class="built_in">push</span>(&#123; m * <span class="number">2</span>, s[i] &#125;);</span><br><span class="line">      now += m;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ans -= m * s[i];</span><br><span class="line">      now -= m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c = now - a[i];</span><br><span class="line">    now = std::<span class="built_in">min</span>(now, a[i]);</span><br><span class="line">    <span class="keyword">while</span> (c &gt; <span class="number">0</span> &amp;&amp; !que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      Node node = que.<span class="built_in">top</span>();</span><br><span class="line">      que.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">int</span> tmp = std::<span class="built_in">min</span>(c, node.flow);</span><br><span class="line">      ans -= tmp * node.cost;</span><br><span class="line">      c -= tmp;</span><br><span class="line">      node.flow -= tmp;</span><br><span class="line">      <span class="keyword">if</span> (node.flow)</span><br><span class="line">        que.<span class="built_in">push</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>多项式补完计划</title>
    <url>/2020/08/24/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p>退役前给自己看的，删了一些东西放出来了，有兴趣可以看看</p>
<hr>
<p>FFT，NTT全世界都会了…</p>
<h2 id="分治FFT"><a href="#分治FFT" class="headerlink" title="分治FFT"></a>分治FFT</h2><p>是一类思想。举个板子： 给出了$g_{1,…,n-1}$，求$f_{0,…,n-1}$ $$f_i = \sum_{j=1}^i f_{i-j} g_j$$ 计算$f$需要用到之前的$f$。所以考虑像CDQ一样的做，用 左半部分贡献右半部分。 对于右半边的点$x$，左边有贡献： $$w_x = \sum_{i=l}^{mid} f_i g_{x - i}$$ 这个东西可以FFT做出来。</p>
<h2 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a>多项式求逆</h2><p>倍增求解。假设已经求出了模$\lceil \frac{x}{2} \rceil$的解$f_0^{-1}(x)$ $$f(x)f^{-1}(x) \equiv f(x)f_0^{-1}(x)\pmod {\lceil \frac{x}{2} \rceil}$$ $$f^{-1}(x) - f_0^{-1}(x) \equiv 0 \pmod {\lceil \frac{x}{2} \rceil}$$ 平方，移项 $$f^{-1}(x) \equiv (2 - f(x)f_0^{-1}(x)) f_0^{-1}(x) \pmod {x^n}$$ $O(nlogn)$</p>
<h2 id="多项式除法"><a href="#多项式除法" class="headerlink" title="多项式除法"></a>多项式除法</h2><p>已知次数为$n,m$的$F(x),G(x)$，求 $$F(x) = Q(x)G(x) + R(x)$$ 我们考虑反转一个多项式的系数，可以发现就是 $$A_R(x) = x^n A(\frac{1}{x})$$ 那么利用反转化简 $$x^n F(\frac{1}{x}) = x^{n-m} Q(\frac{1}{x}) x^mG(\frac{1}{x}) + x^{n-m+1} x^{m-1}R(\frac{1}{x})$$ $$F_R(x) \equiv Q_R(x)G_R(x) + x^{n-m+1}R_R(x) \pmod {x^{n-m+1&#125;&#125;$$ $$Q_R(x) \equiv F_R(x)G_R^{-1}(x)\pmod {x^{n-m+1&#125;&#125;$$ 于是可以求解$Q_R(x)$，然后求出$Q(x),R(x)$。$O(nlogn)$</p>
<h2 id="多项式求导与积分"><a href="#多项式求导与积分" class="headerlink" title="多项式求导与积分"></a>多项式求导与积分</h2><p>$$f(x) = \sum_{i=0}^n a_ix^i$$ $$f^{‘}(x) = \sum_{i=0}^{n-1}(i+1)a_{i+1}x^i$$ $$\int_{1}^n a_i x^i = \sum_{i=1}^{n+1}\frac{a_{i-1}x^i}{i}$$</p>
<h2 id="多项式泰勒展开"><a href="#多项式泰勒展开" class="headerlink" title="多项式泰勒展开"></a>多项式泰勒展开</h2><p>$$g(x) = \sum_{i=0}^{+ \infty} \frac{f^{(i)} (x_0) }{i!} (x - x_0)^i$$</p>
<h2 id="多项式牛顿迭代"><a href="#多项式牛顿迭代" class="headerlink" title="多项式牛顿迭代"></a>多项式牛顿迭代</h2><p>$$g(f(x)) \equiv 0 \pmod{x^n}$$ 已知$g(x)$，求$f(x)$ 一个神奇的东西。其实有了她多项式这些问题都可以随便做啦～。 倍增求解。假装已经求出了$f_0(x)$，满足： $$g(f_0(x)) \equiv 0 \pmod{ x^{\lceil \frac{n}{2} \rceil} }$$ 那么在$f_0(x)$泰勒展开 $$\sum_{i=0}^{+ \infty} \frac{g^{(i)}(f_0(x))}{i!}(f(x)-f_0(x))^i \equiv 0 \pmod{x^n} $$ 因为 $$\forall i \geq 2, (f(x) - f_0(x))^i \equiv 0 \pmod{x^n}$$ 所以可以化简得到 $$g(f_0(x)) + g^{‘} (f_0(x))(f(x) - f_0(x)) \equiv 0 \pmod{x^n}$$ $$f(x) \equiv f_0(x) - \frac{g(f_0(x))}{g^{‘}(f_0(x))} \pmod{x^n}$$</p>
<h2 id="多项式ln"><a href="#多项式ln" class="headerlink" title="多项式ln"></a>多项式ln</h2><p>定义多项式的对数函数为其与麦克劳林级数的复合，即 $$\ln (1 - F(x)) = - \sum_{i=1}^{\infty} \frac{F^{(i)}(x)}{i} $$ 我们令$F(x)=ln(x)$ $$G(x)=F(A(x))$$ $$G^{‘} (x) = F^{‘} (A(x)) A^{‘} (x) = \frac{A^{‘} (x)}{A(x)}$$ 求导求逆求积分。$O(nlogn)$</p>
<h2 id="多项式exp"><a href="#多项式exp" class="headerlink" title="多项式exp"></a>多项式exp</h2><p>同样定义多项式的对数函数为其与麦克劳林级数的复合，即 $$\exp F(x) = \sum_{i=0}^{\infty} \frac{F^{(i)}(x)}{i!}$$ $$F(x) \equiv e^{A(x)} \pmod{x^n}$$ $$\ln F(x) \equiv A(x) \pmod{x^n}$$ $$\ln F(x) - A(x) \equiv 0 \pmod{x^n}$$ 那么考虑令 $$G(F(x)) \equiv \ln F(x) - A(x) \pmod{x^n} $$ 因为$G(F(x)) \equiv 0$，可以把$A(x)$看作常数项，于是很好求导 $$G^{‘}(F(x)) \equiv \frac{1}{F(x)} \pmod{x^n}$$ 用牛顿迭代可知 $$F(x) \equiv F_0(x)(1 - \ln F_0(x) + A(x)) \pmod {x^n}$$ $O(nlogn)$</p>
<h2 id="多项式开根"><a href="#多项式开根" class="headerlink" title="多项式开根"></a>多项式开根</h2><p>会颓exp的式子之后，这个很naive。 $$F(x) \equiv \frac{A(x)}{2F_0(x)} + \frac{F_0(x)}{2} \pmod{x^n}$$ $O(nlogn)$</p>
<h2 id="多项式快速幂"><a href="#多项式快速幂" class="headerlink" title="多项式快速幂"></a>多项式快速幂</h2><p>倍增可以，但是有点慢 $$A^k(x) \equiv \exp(k \ln A(x))$$ $O(nlogn)$ 关于多点求值插值什么的：懒得学，盲猜省选NOI不会考，咕咕（FLAG）</p>
<h2 id="任意模数NTT"><a href="#任意模数NTT" class="headerlink" title="任意模数NTT"></a>任意模数NTT</h2><p>直接用MTT。考虑把数字拆成$xM+y$，其中$M$是一个界限，取$2^{15}-1$ 那么直接考虑FFT，需要$9$次。 主要问题是有一个优化技巧：一次FFT做两个DFT 具体来说就是$P(x)=A(x)+iB(x),Q(x)=conj(P(x))$ 那么对$P$FFT之后，$Q(x)=conj(P(j)),j = (lim-i) \mod lim$ 则$DFT(A) = \frac{P+Q}{2},DFT(B)=-i\frac{P-Q}{2}$ 对于MTT的DFT部分，直接套这个Trick就行了。那么可以得出来$xy$的四个积。 但是IDFT的时候，两个数都是实部虚部都不为0，好像有点问题的样子。。 其实这个问题很好解决（虽然想了很久。。）：令$F=A+Bi$，其中$A,B$都是点值表示，因为两个多项式$A,B$的系数表示都是只有实部不为$0$，那么仔细想一想可以发现，直接把$F$做IDFT就可以还原出来$A,B$，一个在实部一个在虚部。可以理解为，因为它们都是只有一个部有数，分别放在实虚部分，它们是互不影响的。</p>
<hr>
<h2 id="迷惑斯特林数系列"><a href="#迷惑斯特林数系列" class="headerlink" title="迷惑斯特林数系列"></a>迷惑斯特林数系列</h2><h2 id="第二类行"><a href="#第二类行" class="headerlink" title="第二类行"></a>第二类行</h2><p>最简单的一个。。 $$n^m = \sum_{i=0}^m {m \brace i} \binom{n}{i} i!$$ 可以发现，把$\sum$扩展到$n$也是没有问题的 $$n^m = \sum_{i=0}^n {m \brace i} \binom{n}{i} i!$$ $${m \brace n} = \frac{1}{n!} \sum_{i=0}^n \binom{n}{i} (-1)^{n-i} i^m$$ 化简一下就是卷积 $O(nlogn)$</p>
<h2 id="第一类行"><a href="#第一类行" class="headerlink" title="第一类行"></a>第一类行</h2><p>有一个貌似能归纳证明的式子 $$\sum_{i=0}^n{n \brack i}x^i = x^{\overline n}$$ 那么倍增求就行了，手动玩一下二项式。$O(nlogn)$</p>
<h2 id="第二类列"><a href="#第二类列" class="headerlink" title="第二类列"></a>第二类列</h2><p>把列写成OEF，考虑递推式，可以整理得到 $$x^m(\prod_{i=1}^m (1-ix))^{-1}$$ 那么分治NTT就行了，$O(nlog^2n)$</p>
<h2 id="第一类列"><a href="#第一类列" class="headerlink" title="第一类列"></a>第一类列</h2><p>考虑组合意义，$n$个数，由$m$个轮换组成。那么构造轮换EGF（因为有标号），再除掉排列数 $${ n \brack m } = \frac{n!}{m!} [x^n](\sum_{i=1} (i-1)! \frac{x^i}{i!})^m$$ 不是很懂非1的ln，倍增完事$O(nlog^2n)$</p>
<hr>
<p>一类$O(n^2)$的多项式技巧：以exp为例，看这里<a href="https://baka.online/noi-online3%e4%bc%98%e7%a7%80%e5%ad%90%e5%ba%8f%e5%88%97-%e9%9b%86%e5%90%88%e5%b9%82%e7%ba%a7%e6%95%b0exp/">https://baka.online/noi-online3%e4%bc%98%e7%a7%80%e5%ad%90%e5%ba%8f%e5%88%97-%e9%9b%86%e5%90%88%e5%b9%82%e7%ba%a7%e6%95%b0exp/</a> 剩下的更简单，模仿一下就有了</p>
<hr>
<p>奇怪的题目：</p>
<h2 id="付公主的背包"><a href="#付公主的背包" class="headerlink" title="付公主的背包"></a>付公主的背包</h2><p><a href="https://www.luogu.com.cn/problem/P4389">付公主的背包</a> 首先显然构造函数$f_i(x) = \frac{1}{1 - x^{v_i&#125;&#125;$卷起来就行了。但是这个复杂度很高。 考虑用加法代替乘法，求个$\ln $就可以了。这题的$\ln$有极好的性质： $$G(x) = \ln F(x) = \ln \frac{1}{1 - x^v}$$ 考虑求导求积分化简式子： $$G^{‘}(x) = \frac{F^{‘}(x)}{F(x)} = \sum_{i=1}^{\infty} v x^{xi - 1} $$ $$G(x) = \sum_{i=1}^{\infty} \frac{1}{i} x^{vi} $$ 记录每种$v$有几个，暴力求系数，调和级数的复杂度，再敲个多项式$\exp$就行了。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>好看序列</title>
    <url>/2019/01/05/%E5%A5%BD%E7%9C%8B%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p><a href="http://47.104.89.19/problem.php?id=1003">Sxdxfz-OJ 1003: 好看序列</a> 看到难度标着基础就去做了，结果思考了很久…… 第一反应暴力，然而一看范围，最多2000个数字（（<br>想到可以每添加一个数字处理一次，于是研究O(n)算法 一开始的思路是分情况讨论，对于每个新输入的数字判断是否与之前相等之类<br>然而打了很久的表只拿了9%的分。。。。 转变思路，思考每一个新加入的数字与之前的关系，记录每个数字结尾共有多少种方法 一共有sum种方案，数字n结尾有a[n]种方案<br>新加入数字n后，a[n]的值=之前不以n结尾方案+之前以n结尾+单独n存在的方案（1）<br>即新加入后，a[n]=sum+1 于是有了下面的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rint a=<span class="number">1</span>,b=<span class="number">0</span>;<span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">do</span>&#123;c=<span class="built_in">getchar</span>();<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)a=<span class="number">-1</span>;&#125;<span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span>c&lt;<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">do</span>&#123;b=b*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;<span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">50000</span>+<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rint T,n,tmp,sum=<span class="number">0</span>;</span><br><span class="line">    T=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        n=<span class="built_in">read</span>();</span><br><span class="line">        tmp=a[n];</span><br><span class="line">        a[n]=sum+<span class="number">1</span>;</span><br><span class="line">        sum=sum-tmp+a[n];</span><br><span class="line">        a[n]=a[n]&gt;<span class="number">1000000007</span></span><br><span class="line">        ?a[n]%<span class="number">1000000007</span></span><br><span class="line">        :a[n];</span><br><span class="line">        sum=sum&lt;<span class="number">0</span></span><br><span class="line">        ?sum+<span class="number">1000000007</span></span><br><span class="line">        :sum&gt;<span class="number">1000000007</span></span><br><span class="line">            ?sum%<span class="number">1000000007</span></span><br><span class="line">            :sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>子异和 组合线段树</title>
    <url>/2019/09/20/%E5%AD%90%E5%BC%82%E5%92%8C-%E7%BB%84%E5%90%88%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P5127">子异和</a> 分别考虑每一位对答案的贡献。假设第$i$位有$n$个数，$m$个$1$。贡献为： $$\sum_{2 \mid i, 1 \leq i \leq n} \binom{m}{i} 2^{n-m} 2^i = 2^{n-1}2^i $$ 这是一个好的性质，它告诉我们，答案与$1$的个数无关。 用线段树维护区间$or$值。然而，区间$or$并不能直接$xor$，需要维护额外信息。 考虑维护区间$0,1$分别有多少个。可以发现多少个不重要，我们只关心存在与否。进一步的，可以通过维护$and,or$两个值进行求解。 讨论进行更新。如果某一位$xor$的是$0$，显然不影响。$or,and$的关系，有$(0,0),(1,0),(1,1)$三种。简单计算后可以发现，新的$and,or$分别是原来的两个值取反后，$and,or$的结果。 使用树剖+线段树即可，LCT也可以。事实证明，理论复杂度更优的LCT跑的更慢。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200000</span> + <span class="number">2333</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            ret = (<span class="keyword">long</span> <span class="keyword">long</span>)ret * x % P;</span><br><span class="line">        x = (<span class="keyword">long</span> <span class="keyword">long</span>)x * x % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, val[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125; g[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    g[++tot].to = y, g[tot].nxt = head[x],</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N], son[N], size[N], wt[N], num, dep[N], id[N], top[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fat)</span> </span>&#123;</span><br><span class="line">    fa[x] = fat; dep[x] = dep[fat] + <span class="number">1</span>; size[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="keyword">if</span> (y != fat) &#123;</span><br><span class="line">            <span class="built_in">dfs1</span>(y, x);</span><br><span class="line">            <span class="keyword">if</span> (size[son[x]] &lt; size[y])</span><br><span class="line">                son[x] = y;</span><br><span class="line">            size[x] += size[y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line">    top[x] = topf; id[x] = ++num; wt[num] = val[x];</span><br><span class="line">    <span class="keyword">if</span> (!son[x]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], topf);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="keyword">if</span> (y != fa[x] &amp;&amp; y != son[x])</span><br><span class="line">            <span class="built_in">dfs2</span>(y, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> val_and, val_or, tag;</span><br><span class="line">&#125; t[N * <span class="number">4</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(p) p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(p) p &lt;&lt; 1  1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    t[p].val_and = t[<span class="built_in">ls</span>(p)].val_and &amp; t[<span class="built_in">rs</span>(p)].val_and;</span><br><span class="line">    t[p].val_or = t[<span class="built_in">ls</span>(p)].val_or  t[<span class="built_in">rs</span>(p)].val_or;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">unsigned</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> x = t[p].val_and, y = t[p].val_or;</span><br><span class="line">    t[p].val_and = (x ^ v) &amp; (y ^ v);</span><br><span class="line">    t[p].val_or = (x ^ v)  (y ^ v);</span><br><span class="line">    t[p].tag ^= v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[p].tag) &#123;</span><br><span class="line">        <span class="built_in">push</span>(<span class="built_in">ls</span>(p), t[p].tag);</span><br><span class="line">        <span class="built_in">push</span>(<span class="built_in">rs</span>(p), t[p].tag);</span><br><span class="line">        t[p].tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        t[p].val_and = t[p].val_or = wt[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(p), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">unsigned</span> v, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R) &#123;</span><br><span class="line">        <span class="built_in">push</span>(p, v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">        <span class="built_in">change</span>(<span class="built_in">ls</span>(p), l, r, v, L, mid);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">        <span class="built_in">change</span>(<span class="built_in">rs</span>(p), l, r, v, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R) </span><br><span class="line">        <span class="keyword">return</span> t[p].val_or;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">        ret = <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r, L, mid);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">        ret = <span class="built_in">query</span>(<span class="built_in">rs</span>(p), l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">range_change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]])</span><br><span class="line">            std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>, id[top[x]], id[x], v, <span class="number">1</span>, n);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; dep[y])</span><br><span class="line">        std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="built_in">change</span>(<span class="number">1</span>, id[x], id[y], v, <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">range_query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]])</span><br><span class="line">            std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">        val = <span class="built_in">query</span>(<span class="number">1</span>, id[top[x]], id[x], <span class="number">1</span>, n);</span><br><span class="line">        cnt += dep[x] - dep[top[x]] + <span class="number">1</span>;</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; dep[y])</span><br><span class="line">        std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    val = <span class="built_in">query</span>(<span class="number">1</span>, id[x], id[y], <span class="number">1</span>, n);</span><br><span class="line">    cnt += dep[y] - dep[x] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>)val * <span class="built_in">fpow</span>(<span class="number">2</span>, cnt - <span class="number">1</span>) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;data.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">addedge</span>(x, y);</span><br><span class="line">        <span class="built_in">addedge</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        val[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">range_query</span>(x, y));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>(), z = <span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">range_change</span>(x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>字串变换</title>
    <url>/2019/01/05/%E5%AD%97%E4%B8%B2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1032">Luogu P1032 字串变换</a> 还是bfs题，需要特别注意的是需要去重 因为是bfs，一旦找到合适的立马输出，即为最小值 实际上，使用std::string与std::set可以大大简化代码复杂度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string A, B, a[<span class="number">10</span>], b[<span class="number">10</span>], ta, tb;</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; ta &gt;&gt; tb) &#123;</span><br><span class="line">        a[tot] = ta;</span><br><span class="line">        b[tot++] = tb;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;pair&lt;string, <span class="keyword">int</span>&gt; &gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(A, <span class="number">0</span>));</span><br><span class="line">    set&lt;pair&lt;string, <span class="keyword">int</span>&gt; &gt; st;</span><br><span class="line">    st.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(A, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pair&lt;string, <span class="keyword">int</span>&gt; s = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (s.first == B) &#123;</span><br><span class="line">            cout &lt;&lt; s.second;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.second == <span class="number">10</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (rint i = <span class="number">0</span>; i&lt;tot; ++i) &#123;</span><br><span class="line">            string::size_type pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((pos = s.first.<span class="built_in">find</span>(a[i], pos)) != string::npos) &#123;</span><br><span class="line">                string ss = s.first;</span><br><span class="line">                ss.<span class="built_in">replace</span>(pos, a[i].<span class="built_in">size</span>(), b[i]);</span><br><span class="line">                pair&lt;string, <span class="keyword">int</span>&gt; p = <span class="built_in">make_pair</span>(ss, s.second + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (st.<span class="built_in">find</span>(p) == st.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    st.<span class="built_in">insert</span>(p);</span><br><span class="line">                    que.<span class="built_in">push</span>(p);</span><br><span class="line">                &#125;</span><br><span class="line">                pos += a[i].<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">if</span> (pos &gt;= s.first.<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO ANSWER!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>2019.3.2模拟赛</title>
    <url>/2019/03/04/%E5%AD%A6%E9%9C%B8%E7%9A%84%E6%9C%9F%E6%9C%AB/</url>
    <content><![CDATA[<p>周末的考试题，放下题面。 题目描述 到了期末考试之后，比较成绩是学霸们必做的事情，由于这年头成绩单并不公开了，所以从有限的信息里归纳总结出尽可能多的东西，是每个学霸都要干的事情，然而学霸不擅长编程，数据一大，学霸们也表示没有办法。现在Antinomyra同学就接到了学霸T某某的代码任务，可是Antinomyra也不想做…于是交给了你。 具体任务是，一共有个N个同学，你已知了M条信息，其中每一条信息的格式都是“同学A的成绩不高于同学B的成绩”，接下来，问的是，根据给你的M条信息（可能重复），1. 要完整的表达这些信息，最少只要几句格式同上的话就够了；2. 你一共可以写出多少句话来（包括给你的M句，但是不准重复） 输入格式 输入共M+1行。为第一行依次输入两个数N(N&lt;=1000) M(M&lt;=100000)，分别表示总人数和已知的信息条数。接下来还有M行输入，每行输入两个数Ai Bi,（编号从1到n）表示同学Ai 的成绩不会高于 Bi 的成绩 输出格式 输出2个数，先输出最少只要多少句即够推出所有信息，再输出最多可以写出多少句话。输出用一个空格隔开。 样例输入 Sample 1: 3 2 1 2 2 3 Sample 2: 3 3 1 2 2 3 3 1 样例输出 Sample 1: 2 3 Sample 2: 3 6</p>
<hr>
<p>题目中有个坑点，卡了我好久…第一问是用<strong>格式同上</strong>的语句，不一定要用题目给出的句子。 明显可以看出要按类似差分约束的方法建图。所以可以把题意翻译成人话：给定一张有向图，求保持原图约束条件下最少/最多存在几条边。</p>
<hr>
<p>这题做法十分的巧妙： 首先可以发现约束条件可能构成一个强连通分量，其中所有元素的值相等。所以先进行缩点。分析强连通分量内的性质，如果重构强连通分量，我们可以把它变成一个环，边数即为点数（一个点除外）。 然后我们得到了一个DAG。约束关系具有传递性，如在如下图的情况中，我们可以去掉1-&gt;4的这条边。 <img src="https://baka.online/wp-content/uploads/2019/03/graph-1-e1551713561585.png"> 我首先想到的是使用拓扑排序。但是，随即构造了一个反例： <img src="https://baka.online/wp-content/uploads/2019/03/graph-e1551713423109.png"> 在上图中，最佳方案是去掉1-&gt;3，留下剩下的边。但是拓扑排序只会选择更少的边。 所有可以去掉的边，一定是某一条链中祖先节点连下来的边。于是我考虑了使用暴力枚举链上的边，但是复杂度不太对，遂放弃。。。 在GSH大佬钦点之后蒟蒻终于找到了科学算法…在执行差分约束时我们求的是最长路。观察图中能被去掉的边一定不在最长路上——枚举所有最长路即可！去掉DAG上没被经过的边，剩下的边数加上强连通分量内的边即为第一问答案。 对于第二问则简单一些。。。可以从DAG上一个点向所有可以到达的点连一条边，由乘法原理，新增了两点代表的强连通分量大小乘积条边。然而又踩了坑，最后使用的统计到达的点的方法是：使用bitset，暴力进行or操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// By kai586123</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123&#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">0</span>; <span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) a=c==<span class="string">&#x27;-&#x27;</span>?<span class="number">0</span>:<span class="number">1</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) b=b*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> a?b:-b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span> + <span class="number">233</span>, M = <span class="number">100000</span> + <span class="number">2333</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">G</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> from, to, nxt;</span><br><span class="line">        &#125; g[M];</span><br><span class="line">        <span class="keyword">int</span> head[N], tot;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addegde</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            g[++tot].from = x, g[tot].nxt = head[x],</span><br><span class="line">            g[tot].to = y, head[x] = tot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; g1, g2;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dfn[N], low[N], num, stack[N], top, c[N], cnt;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> size[N];</span><br><span class="line">    <span class="keyword">bool</span> ins[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        dfn[x] = low[x] = ++num;</span><br><span class="line">        ins[stack[++top] = x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = g1.head[x]; i; i = g1.g[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = g1.g[i].to;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(y);</span><br><span class="line">                low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ins[y])</span><br><span class="line">                low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y; ++cnt;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                ins[y = stack[top--]] = <span class="literal">false</span>;</span><br><span class="line">                c[y] = cnt, ++size[cnt];</span><br><span class="line">            &#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> add[N][N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dis[N];</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">            g1.<span class="built_in">addegde</span>(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> in[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x)</span><br><span class="line">            <span class="keyword">if</span> (!dfn[x])</span><br><span class="line">                <span class="built_in">tarjan</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g1.tot; ++i)</span><br><span class="line">            <span class="keyword">if</span> (c[g1.g[i].from] != c[g1.g[i].to] &amp;&amp; !add[c[g1.g[i].from]][c[g1.g[i].to]]) &#123;</span><br><span class="line">                g2.<span class="built_in">addegde</span>(c[g1.g[i].from], c[g1.g[i].to]);</span><br><span class="line">                ++in[c[g1.g[i].to]];</span><br><span class="line">                add[c[g1.g[i].from]][c[g1.g[i].to]] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> choose[M];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0xcf</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">        dis[s] = <span class="number">0</span>;</span><br><span class="line">        que.<span class="built_in">push</span>(s);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            vis[x] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = g2.head[x]; i; i = g2.g[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = g2.g[i].to;</span><br><span class="line">                <span class="keyword">if</span> (dis[y] &lt; dis[x] + <span class="number">1</span>) &#123;</span><br><span class="line">                    dis[y] = dis[x] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!vis[y])</span><br><span class="line">                        que.<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g2.tot; ++i)</span><br><span class="line">            <span class="keyword">if</span> (dis[g2.g[i].from] + <span class="number">1</span> == dis[g2.g[i].to])</span><br><span class="line">                choose[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g2.tot; ++i)</span><br><span class="line">            <span class="keyword">if</span> (choose[i])</span><br><span class="line">                ++ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">            <span class="keyword">if</span> (size[i] &gt; <span class="number">1</span>)</span><br><span class="line">                ans += size[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> topo[N], l, r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> to[N];</span><br><span class="line"></span><br><span class="line">    bitset&lt;N&gt; bit[N];</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        vis[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = g2.head[x]; i; i = g2.g[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = g2.g[i].to;</span><br><span class="line">            <span class="keyword">if</span> (!vis[y]) &#123;</span><br><span class="line">                ans += <span class="built_in">dfs</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">            bit[x] = bit[y];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (bit[x][i])</span><br><span class="line">                tmp += size[x] * size[i];</span><br><span class="line">        bit[x][x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans + tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">            <span class="keyword">if</span> (in[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                ans += <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= cnt; ++x)</span><br><span class="line">            ans += size[x] * (size[x] - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">scc</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">            <span class="built_in">spfa</span>(i);</span><br><span class="line">        <span class="keyword">int</span> ans1 = <span class="built_in">solve1</span>();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans2 = <span class="built_in">solve2</span>();</span><br><span class="line">        cout &lt;&lt; ans1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;qimo.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;qimo.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>寻找段落</title>
    <url>/2019/01/05/%E5%AF%BB%E6%89%BE%E6%AE%B5%E8%90%BD/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1419">Luogu P1419 寻找段落</a> 题意：要求找出长度在S到T之间段落最大平均值 首先本题可以二分答案转化为判定性问题 如果一个区间有$k$个元素，和为$sum$，平均值$\ge x$ $sum/k \ge x$ $sum-k \times x \ge 0$ 将每一个值都减去$x$，求出$sum$得到$sum \ge 0$ 求出序列每个元素减去$x$后的前缀和 只要知道$i-T$到$i-S$间的最小值，即可求得区间内最大平均值，可使用单调队列维护 如果区间内$i &lt; j &lt; k$，$pre_i&gt;pre_j$，则$pre_k-pre_j&gt;pre_k-pre_i$，$pre_i$已不是最优答案，可以出队 代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">0</span>; <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">do</span>&#123;c=<span class="built_in">getchar</span>(); <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) a=<span class="number">-1</span>;&#125;<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>c&gt;<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    <span class="keyword">do</span>&#123;b=b*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>; c=<span class="built_in">getchar</span>();&#125;<span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100000</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> num[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,S,T;</span><br><span class="line"><span class="keyword">double</span> lft,rigt,ans,mid;</span><br><span class="line"><span class="keyword">double</span> pre_sum[MAXN];</span><br><span class="line">std::deque&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    que.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line">        pre_sum[i]=pre_sum[i<span class="number">-1</span>]+(<span class="keyword">double</span>)num[i]-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=S)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>() &amp;&amp; pre_sum[que.<span class="built_in">front</span>()]&gt;pre_sum[i-S])</span><br><span class="line">                que.<span class="built_in">pop_front</span>();</span><br><span class="line">            que.<span class="built_in">push_back</span>(i-S);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!que.<span class="built_in">empty</span>() &amp;&amp; que.<span class="built_in">front</span>()&lt;i-T)</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span>(!que.<span class="built_in">empty</span>() &amp;&amp; pre_sum[i]-pre_sum[que.<span class="built_in">front</span>()]&gt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    N=<span class="built_in">read</span>(); S=<span class="built_in">read</span>(); T=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i) num[i]=<span class="built_in">read</span>();</span><br><span class="line">    lft=<span class="number">-10000.0</span>; rigt=<span class="number">10000.0</span>;</span><br><span class="line">    <span class="keyword">while</span>(rigt-lft&gt;=<span class="number">1e-5</span>)&#123;</span><br><span class="line">        mid=(rigt+lft)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">judge</span>(mid))</span><br><span class="line">            lft=ans=mid;</span><br><span class="line">        <span class="keyword">else</span> rigt=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3f\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>小C找朋友</title>
    <url>/2019/04/19/%E5%B0%8Fc%E6%89%BE%E6%9C%8B%E5%8F%8B/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4264">小C找朋友</a> 神神神…可以理解为图上hash，给每个点一个随机值，xor起来即可快速判断连着的边是否相等。这题不相邻的也可以做朋友，注意读题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000000</span> + <span class="number">2333</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[N][<span class="number">2</span>], head[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ll_rand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>)<span class="built_in">rand</span>() * <span class="built_in">rand</span>() + <span class="built_in">rand</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> val[N], xx[N], ans;</span><br><span class="line">map&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// hash&lt;string&gt; seed;</span></span><br><span class="line">    <span class="comment">// srand(seed(&quot;i love u forever&quot;));</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="number">233</span>);</span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        val[i] = <span class="built_in">ll_rand</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        g[i][<span class="number">0</span>] = <span class="built_in">rd</span>(); g[i][<span class="number">1</span>] = <span class="built_in">rd</span>();</span><br><span class="line">        xx[g[i][<span class="number">0</span>]] ^= val[g[i][<span class="number">1</span>]];</span><br><span class="line">        xx[g[i][<span class="number">1</span>]] ^= val[g[i][<span class="number">0</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">if</span> ((xx[g[i][<span class="number">0</span>]] ^ val[g[i][<span class="number">1</span>]]) == (xx[g[i][<span class="number">1</span>]] ^ val[g[i][<span class="number">0</span>]]))</span><br><span class="line">            ++ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ++mp[xx[i]];</span><br><span class="line">    <span class="keyword">for</span> (map&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt;::iterator i = mp.<span class="built_in">begin</span>(); i != mp.<span class="built_in">end</span>(); ++i)</span><br><span class="line">        ans += (<span class="keyword">long</span> <span class="keyword">long</span>)i-&gt;second * (i-&gt;second - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> kai586123::<span class="built_in">main</span>(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>小清新人渣的本愿</title>
    <url>/2019/04/10/%E5%B0%8F%E6%B8%85%E6%96%B0%E4%BA%BA%E6%B8%A3%E7%9A%84%E6%9C%AC%E6%84%BF/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3674">小清新人渣的本愿</a> lxl的题，无修改只有询问，不强制在线，一眼莫队，乘法的询问暴力分解就可以，$O(\sqrt n)$，然后分析了下加减法时间就不会了。从题解里get新技能www。 方法：bitset优化莫队。开两个bitset储存哪些数字$a$，以及$N-a$出现过，分别记为$now1$，$now2$。 给定$a$，判断是否存在$x-y=a$。只需要把$now1$和$now1 &lt;&lt; a$与一下。如果非空就可以。 给定$a$，判断是否存在$x+y=a$。加法不能直接做。$x+y=x-(N-y)+N$，$x-(N-y)=a-N$。所以把$now2&lt;&lt;a-N$，即$now2&gt;&gt;N-a$，与一下$now1$就可以了。 复杂度$O(n^{1.5}/32)$，就能水过去了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c -<span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">2333</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], block, pos[N], L[N], ans[N], cnt[N];</span><br><span class="line">bitset&lt;N + 1&gt; now1, now2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> opt, l, r, v, id;</span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> Query &amp;x, <span class="keyword">const</span> Query &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pos[x.l] == pos[y.l] ?</span><br><span class="line">        x.r &lt; y.r : x.l &lt; y.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (++cnt[x] == <span class="number">1</span>)</span><br><span class="line">        now1[x] = now2[N - x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (--cnt[x] == <span class="number">0</span>)</span><br><span class="line">        now1[x] = now2[N - x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        q[i].opt = <span class="built_in">rd</span>(), q[i].l = <span class="built_in">rd</span>(),</span><br><span class="line">        q[i].r = <span class="built_in">rd</span>(), q[i].v = <span class="built_in">rd</span>();</span><br><span class="line">        q[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    block = n / <span class="built_in">sqrt</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        pos[i] = (i - <span class="number">1</span>) / block + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l = <span class="number">1</span>, r = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) <span class="built_in">add</span>(a[++r]);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) <span class="built_in">del</span>(a[r--]);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) <span class="built_in">del</span>(a[l++]);</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) <span class="built_in">add</span>(a[--l]);</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (q[i].opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> ((now1 &amp; (now1 &lt;&lt; q[i].v)).<span class="built_in">any</span>())</span><br><span class="line">                    ans[q[i].id] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> ((now1 &amp; (now2 &gt;&gt; (N - q[i].v))).<span class="built_in">any</span>())</span><br><span class="line">                    ans[q[i].id] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= q[i].v; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!(q[i].v % j) &amp;&amp; now1[j] &amp;&amp; now1[q[i].v / j]) &#123;</span><br><span class="line">                        ans[q[i].id] = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">puts</span>(ans[i] ? <span class="string">&quot;hana&quot;</span> : <span class="string">&quot;bi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> kai586123::<span class="built_in">main</span>(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>已经没有什么好害怕的了 二项式反演</title>
    <url>/2019/08/13/%E5%B7%B2%E7%BB%8F%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%AE%B3%E6%80%95%E7%9A%84%E4%BA%86-%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P4859">已经没有什么好害怕的了</a> 直接做不可做，求正好为$k$，可以用$\geq k$的容斥出来。 对数组排序，令$f_{i,j}$表示前$i$个$a$中进行选择，产生了$j$对$a &gt; b$的。 $$f_{i,j}=f_{i-1,j}+f_{i-1,j-1}(pre_i-(j-1))$$ 其中，$pre_i$表示比$a_i$小的$b$的数量。 令$A_i=f_{n,i}(n-i)!$，即$\geq i$的方案数。 令$B_i$为$=i$的方案数。 $$A_i=\sum_{j=i}^n \binom{j}{i}B_j$$ $$B_i=\sum_{j=i}^n (-1)^{j-i} \binom{j}{i}A_j$$</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>小Z的礼物 轮廓线DPmin-max容斥</title>
    <url>/2019/12/16/%E5%B0%8Fz%E7%9A%84%E7%A4%BC%E7%89%A9/</url>
    <content><![CDATA[<p><a href="http://uoj.ac/problem/422">小Z的礼物</a> 一直对轮廓线DP什么的不熟，于是来练练手… 题目要求的其实是取到所有硬币次数的$\max$，那么显然可以$\min - \max$容斥，求$\min$就行了。进一步的，求出每一个集合有多少覆盖方案，就知道了答案。 然而枚举集合复杂度过高，发现$n \leq 6$，考虑轮廓线DP。 定义$f_{i,j,s,k}$表示$(i,j)$，状态为$s$，有$k$个覆盖方案的总和。因为容斥系数是$(-1)^{s}$，可以不存这个系数，直接在转移的时候用加减维护。 没怎么写过，于是参（zhao）考（chao）了网上的代码…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">7</span>, M = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, lim1, lim2;</span><br><span class="line"><span class="keyword">char</span> map[N][M];</span><br><span class="line">ll f[<span class="number">2</span>][(<span class="number">1</span> &lt;&lt; N) + <span class="number">5</span>][N * M * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> now;</span><br><span class="line">ll inv[N * M * <span class="number">2</span>];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T &amp;x, T y)</span> </span>&#123;</span><br><span class="line">  x = x + y &gt;= P ? x + y - P : x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  lim1 = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">  lim2 = <span class="number">2</span> * n * m - n - m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    std::cin &gt;&gt; (map[i] + <span class="number">1</span>);</span><br><span class="line">  inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n * m * <span class="number">2</span>; ++i)</span><br><span class="line">    inv[i] = P - P / i * inv[P % i] % P;</span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = P - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">      now ^= <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">memset</span>(f[now], <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f[now]));</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= lim1; ++s) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= lim2; ++k) &#123;</span><br><span class="line">          <span class="keyword">if</span> (f[now ^ <span class="number">1</span>][s][k]) &#123;</span><br><span class="line">            <span class="keyword">int</span> _s = s &amp; (lim1 ^ (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)));</span><br><span class="line">            <span class="built_in">add</span>(f[now][_s][k], f[now ^ <span class="number">1</span>][s][k]);</span><br><span class="line">            <span class="keyword">if</span> (map[j][i] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">              _s = <span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>);</span><br><span class="line">              <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; !(s &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))))</span><br><span class="line">                ++cnt;</span><br><span class="line">              <span class="keyword">if</span> (j &gt; <span class="number">1</span> &amp;&amp; !(s &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">2</span>))))</span><br><span class="line">                ++cnt;</span><br><span class="line">              <span class="keyword">if</span> (j != n)</span><br><span class="line">                ++cnt;</span><br><span class="line">              <span class="keyword">if</span> (i != m)</span><br><span class="line">                ++cnt;</span><br><span class="line">              <span class="built_in">add</span>(f[now][_s][k + cnt], P - f[now ^ <span class="number">1</span>][s][k]);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= lim1; ++s)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= lim2; ++k)</span><br><span class="line">      <span class="built_in">add</span>(ans, f[now][s][k] * inv[k] % P);</span><br><span class="line">  ans = ans * lim2 % P;</span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>最小回文划分</title>
    <url>/2020/06/11/%E6%9C%80%E5%B0%8F%E5%9B%9E%E6%96%87%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/93152631">丢链接跑路</a> 例题：CF906E 把串交叉成新串，原串的反转对应新串的回文，套个板子上去</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>SCP-S模拟测试47 题解</title>
    <url>/2019/09/20/scp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9547-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://baka.online/wp-content/uploads/2019/09/csp-s.pdf">题点这里</a> 打挂两行泪</p>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>傻题，题解无。然而打挂了。。</p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>傻题，不过貌似全世界写的都是线段树合并。我写的dsu on tree，跑的蛮快。</p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>好题。 考虑一种可行方案。把原串的前t个截掉，剩下的部分和原串头部对齐，一定可以完全匹配。 也就是说，t一定是原串长度，减去原串的某个border长度。用kmp可以简单求出这些t。 题目要求一个新串，满足和原串的border完全相同，也就是说，next数组完全相同。 从串末递归求出所有要用到的next，从小到大排序。 每个阶段构造到当前的next的长度。记当前和上一个next分别为$nxt_i,nxt_{i-1}$ 如果$2nxt_{i-1} &lt; nxt_i$，复制原来的答案接到末尾，中间剩下的部分填0。求一下新的答案next，如果结尾next和原串不同，把中间0的最后一个改成1。 否则，把原来的答案最后一部分移到新的部分就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;bits/stdc++.h&amp;gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[N], ans[N];</span><br><span class="line"><span class="keyword">int</span> n, m, nxt1[N], set[N], nxt2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n, <span class="keyword">int</span> nxt[], <span class="keyword">int</span> st = <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (st &amp;lt; <span class="number">2</span>) st = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = st; i &amp;lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = nxt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (j &amp;amp;&amp;amp; str[j + <span class="number">1</span>] != str[i])</span><br><span class="line">            j = nxt[j];</span><br><span class="line">        <span class="keyword">if</span> (str[j + <span class="number">1</span>] == str[i])</span><br><span class="line">            ++j;</span><br><span class="line">        nxt[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(&amp;quot;%s&amp;quot;, str + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">fill</span>(nxt1 + <span class="number">1</span>, nxt1 + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    std::<span class="built_in">fill</span>(nxt2 + <span class="number">1</span>, nxt2 + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    std::<span class="built_in">fill</span>(ans + <span class="number">1</span>, ans + n + <span class="number">1</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">kmp</span>(str, n, nxt1);</span><br><span class="line"></span><br><span class="line">    m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i = nxt1[i])</span><br><span class="line">        set[++m] = i;</span><br><span class="line">    std::<span class="built_in">reverse</span>(set + <span class="number">1</span>, set + m + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &amp;lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set[i - <span class="number">1</span>] * <span class="number">2</span> &amp;lt; set[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &amp;lt;= set[i - <span class="number">1</span>]; ++j)</span><br><span class="line">                ans[j + set[i] - set[i - <span class="number">1</span>]] = ans[j];</span><br><span class="line">            <span class="built_in">kmp</span>(ans, set[i], nxt2, set[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nxt2[set[i]] != set[i - <span class="number">1</span>])</span><br><span class="line">                ans[set[i] - set[i - <span class="number">1</span>]] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            <span class="built_in">kmp</span>(ans, set[i], nxt2, set[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = set[i]; j &amp;gt; set[i - <span class="number">1</span>]; --j)</span><br><span class="line">                ans[j] = ans[j - set[i] + set[i - <span class="number">1</span>]];</span><br><span class="line">            <span class="built_in">kmp</span>(ans, set[i], nxt2, set[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[n + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">puts</span>(ans + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(&amp;quot;%d&amp;quot;, &amp;amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>最小路径覆盖问题</title>
    <url>/2019/02/01/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2764">最小路径覆盖问题</a> 二分图求最小路径覆盖，做法是拆点成入和出（中间不需要连边），源点向出点连边，入点向汇点连边，跑二分图匹配即可。答案=n-最大匹配数。 证明： 自己想了个证明…由二分图性质可匹配后点只连着一条边，即对应原图中点入度出度都&lt;=1。 首先证明这样一定在原图中选择了尽可能多的边。如果一条边x-&gt;y可以被选取，那么对应二分图中x出点一定出度为0，y入点入度为0，即一条增广路。所以一定被选取。 其次，证明答案=n-最大匹配数。可以将一条被选取的边对应它出发点，那么可以发现一条路径覆盖中，最后一个点是没有对应边的。一条路径覆盖中，边=点-1。那么边总=点总-总覆盖数。 可以这样理解，每增加一条边，即合并了两个路径覆盖。原来n个点有n个路径覆盖，所以做法正确。 写了个Dinic跑最大流，复杂度很ok。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">6000</span> * <span class="number">100</span>, INF = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">int</span> n, m, s = MAXN - <span class="number">2</span>, t = MAXN - <span class="number">1</span>, ans;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> to, nxt, f;</span><br><span class="line">    &#125; g[MAXN * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], tot = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> deg[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">        g[++tot].to = y, g[tot].nxt = head[x],</span><br><span class="line">        g[tot].f = f, head[x] = tot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">addedge</span>(x, y, f);</span><br><span class="line">        <span class="built_in">addedge</span>(y, x, <span class="number">0</span>);</span><br><span class="line">        ++deg[y];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dis[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        dis[s] = <span class="number">1</span>; que.<span class="built_in">push</span>(s);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!dis[g[i].to] &amp;&amp; g[i].f) &#123;</span><br><span class="line">                    dis[g[i].to] = dis[x] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (g[i].to == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(g[i].to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[t];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> to[MAXN];</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> mf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == t) <span class="keyword">return</span> mf;</span><br><span class="line">        <span class="keyword">int</span> used = <span class="number">0</span>, tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[g[i].to] == dis[x] + <span class="number">1</span> &amp;&amp; g[i].f) &#123;</span><br><span class="line">                tmp = <span class="built_in">dfs</span>(g[i].to, <span class="built_in">min</span>(mf - used, g[i].f));</span><br><span class="line">                <span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">                    used += tmp;</span><br><span class="line">                    g[i].f -= tmp;</span><br><span class="line">                    g[i ^ <span class="number">1</span>].f += tmp;</span><br><span class="line">                    vis[g[i].to] = <span class="literal">true</span>;</span><br><span class="line">                    to[x] = g[i].to;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> dis[g[i].to] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> used;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">add</span>(s, i + n, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">add</span>(i, t, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">add</span>(x + n, y, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">bfs</span>())</span><br><span class="line">            ans += <span class="built_in">dfs</span>(s, INF);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = to[i + n]; j; j = to[j + n])</span><br><span class="line">                    cout &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        cout &lt;&lt; n - ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>序列取数</title>
    <url>/2019/01/05/%E5%BA%8F%E5%88%97%E5%8F%96%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1430">Luogu P1430 序列取数</a> 蒟蒻觉得很复杂的区间dp题… $A, B$两人从给定的长度为$N$的序列中轮流取数，都取自己最大结果，求A最终得分 当$A$取得数字和最大时，由于总和一定，$B$取得的数字和最小 让$dp[l, r]$表示取到$[l, r]$时，$A$的得分减去$B$的得分 若更新$dp[l, r]$，区间$[l, r]$中的每一段都应该已被更新 对于这一区间，有三种操作方法：</p>
<ul>
<li>$A$选取区间内所有的数</li>
<li>$A$从左到右选取一部分</li>
<li>$A$从右到左选取一部分</li>
</ul>
<p>对于后两种情况，以$A$选取了$[l, i]$，$B$选取了$[i+1, r]$为例： 前半段$A$选取$S[A]$，后半段$S[A_1]$，$B$选取$S[B_1]$ $dp[l, r] = S[A] + S[A_1] - S[B_1] = S[A] - (S[B_1] - S[A_1])$ 数组$dp$表示的是$A$先选取的情况，若$B$先选取，则$dp$意义变为$B$的得分减去$A$的得分 我们求出前缀和数组$sum$，则有： $dp[l, r] = S[A] - dp[i+1, r] = sum[i - 1] - sum[l - 1] - dp[i][r]$，$l + 1 \leq i \leq r$ 基于此思路写出$O(n^3)$算法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>,b = <span class="number">0</span>; <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">do</span> &#123;c=<span class="built_in">getchar</span>(); <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) a = <span class="number">-1</span>;&#125; <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span>  c &gt; <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>; c = <span class="built_in">getchar</span>();&#125; <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            a[i] = <span class="built_in">read</span>();</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = len; r &lt;= n; ++l, ++r) &#123;</span><br><span class="line">                dp[l][r] = sum[r] - sum[l - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">                    dp[l][r] = <span class="built_in">max</span>(dp[l][r], sum[i - <span class="number">1</span>] - sum[l - <span class="number">1</span>] - dp[i][r]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = r - <span class="number">1</span>; i &gt;= l; --i) &#123;</span><br><span class="line">                    dp[l][r] = <span class="built_in">max</span>(dp[l][r], sum[r] - sum[i] - dp[l][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (sum[n] + dp[<span class="number">1</span>][n]) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>40分，爽到……</p>
<hr>
<p>于是考虑优化到$O(n^2)$的算法： 考虑将dp转移方程种有i的两项放在一起，我们可以维护两个数组，保存它们的最大或最小值，省去一次循环 仍然以刚才的情况举例： $sum[i - 1] - sum[l - 1] - dp[i][r] = (sum[i - 1] - dp[i][r]) - sum[l - 1]$ 令$P[l][r] = sum[l - 1] - dp[l][r]$，$left[l][r] = min(P[i][j] \mid l \leq i \leq j \leq r) $ $dp[l][r]$最大，则$P[l][r]$最大，维护$left$最大值即可 $dp[l][r] = max(dp[l][r], left[l+1][r] - sum[l-1])$ $left[l][r] = max(left[l+1][r], sum[l-1] - dp[l][r])$ 如果从$len = 1$开始，会出现$l = r = 1$，$l + 1 &gt; r$，所以$len = 2$开始 为所有$len = 1$，即$l = r$增加一段预处理即可 最终AC代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>,b = <span class="number">0</span>; <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">do</span> &#123; c=<span class="built_in">getchar</span>(); <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) a = <span class="number">-1</span>; &#125; <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span>  c &gt; <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123; b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>; c = <span class="built_in">getchar</span>(); &#125; <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN], sum[MAXN], dp[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> lft[MAXN][MAXN], rigt[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            a[i] = <span class="built_in">read</span>();</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(lft, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(lft));</span><br><span class="line">        <span class="built_in">memset</span>(rigt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(rigt));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i][i] = a[i];</span><br><span class="line">            lft[i][i] = sum[i - <span class="number">1</span>] - dp[i][i];</span><br><span class="line">            rigt[i][i] = dp[i][i] + sum[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = len; r &lt;= n; ++l, ++r) &#123;</span><br><span class="line">                dp[l][r] = sum[r] - sum[l - <span class="number">1</span>];</span><br><span class="line">                dp[l][r] = <span class="built_in">max</span>(dp[l][r], lft[l + <span class="number">1</span>][r] - sum[l - <span class="number">1</span>]);</span><br><span class="line">                dp[l][r] = <span class="built_in">max</span>(dp[l][r], sum[r] - rigt[l][r - <span class="number">1</span>]);</span><br><span class="line">                lft[l][r] = <span class="built_in">max</span>(lft[l + <span class="number">1</span>][r], sum[l - <span class="number">1</span>] - dp[l][r]);</span><br><span class="line">                rigt[l][r] = <span class="built_in">min</span>(rigt[l][r - <span class="number">1</span>], dp[l][r] + sum[r]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (dp[<span class="number">1</span>][n] + sum[n]) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>收集邮票 期望DP</title>
    <url>/2019/09/06/%E6%94%B6%E9%9B%86%E9%82%AE%E7%A5%A8-%E6%9C%9F%E6%9C%9Bdp/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P4550">收集邮票</a> 被题意杀了。。购买第$k$张，是第$k$次购买的意思。 令$f_i$为收集够$i$个邮票的期望次数。 $$f_i=\frac{n-i+1}{n}f_{i-1}+\frac{i-1}{n}f_i$$ $$f_i=f_{i-1}+\frac{n}{n-i+1}$$ 然后，令$g_i$为收集$i$个邮票的期望价格。 $$f_i=\frac{n-i+1}{n}(g_{i-1}+f_{i-1}+1)+\frac{i-1}{n}(g_i+f_i+1)$$ 用$f_i$替换里面的$f_{i-1}$，可以得到一个很好看的式子 $$g_i=g_{i-1}+\frac{n}{n-i+1}f_i$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="keyword">double</span> f = <span class="number">0</span>, g = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        f = f + (<span class="number">1.0</span> * n) / (n - i + <span class="number">1</span>);</span><br><span class="line">        g = g + (<span class="number">1.0</span> * n) / (n - i + <span class="number">1</span>) * f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, g);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>机器人搬重物</title>
    <url>/2019/01/05/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%90%AC%E9%87%8D%E7%89%A9/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1126">Luogu P1126 机器人搬重物</a> 标准bfs题，注意一下别让机器人跑出去 用ans数组记录最小值即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, sx, sy, ex, ey;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">60</span>][<span class="number">60</span>], ans[<span class="number">60</span>][<span class="number">60</span>];</span><br><span class="line"><span class="keyword">char</span> d;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Direction</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, nxt;</span><br><span class="line">    <span class="built_in">Direction</span>(<span class="keyword">int</span> _x = <span class="number">0</span>, <span class="keyword">int</span> _y = <span class="number">0</span>, <span class="keyword">int</span> _nxt = <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">        x = _x; y = _y; nxt = _nxt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Direction dire[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Robot</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, t; <span class="keyword">char</span> d;</span><br><span class="line">    <span class="built_in">Robot</span>(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y, <span class="keyword">int</span> <span class="keyword">_t</span>, <span class="keyword">char</span> _d) &#123;</span><br><span class="line">        x = _x; y = _y; t = <span class="keyword">_t</span>; d = _d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;Robot&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (rint i = <span class="number">0</span>; i&lt;N; ++i) <span class="keyword">for</span> (rint j = <span class="number">0</span>; j&lt;M; ++j)</span><br><span class="line">        cin &gt;&gt; a[i][j];</span><br><span class="line">    cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; ex &gt;&gt; ey &gt;&gt; d;</span><br><span class="line"></span><br><span class="line">    dire[<span class="string">&#x27;N&#x27;</span>] = <span class="built_in">Direction</span>(<span class="number">-1</span>, <span class="number">0</span>, <span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">    dire[<span class="string">&#x27;E&#x27;</span>] = <span class="built_in">Direction</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;S&#x27;</span>);</span><br><span class="line">    dire[<span class="string">&#x27;S&#x27;</span>] = <span class="built_in">Direction</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;W&#x27;</span>);</span><br><span class="line">    dire[<span class="string">&#x27;W&#x27;</span>] = <span class="built_in">Direction</span>(<span class="number">0</span>, <span class="number">-1</span>, <span class="string">&#x27;N&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    que.<span class="built_in">push</span>(<span class="built_in">Robot</span>(sx, sy, <span class="number">0</span>, d));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Robot r = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r.t&gt;ans[r.x][r.y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> ans[r.x][r.y] = r.t;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (rint i = <span class="number">0</span>, j = r.d; i&lt;<span class="number">4</span>; ++i, j = dire[j].nxt) &#123;</span><br><span class="line">            rint t = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>  i == <span class="number">3</span>) t = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) t = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (rint k = <span class="number">1</span>; k &lt;= <span class="number">3</span>; ++k) &#123;</span><br><span class="line">                rint _x = r.x + dire[j].x*k,</span><br><span class="line">                    _y = r.y + dire[j].y*k;</span><br><span class="line">                <span class="keyword">if</span> (_x &lt;= <span class="number">0</span>  _x &gt;= N  _y &lt;= <span class="number">0</span>  _y &gt;= M)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (a[_x][_y]  a[_x - <span class="number">1</span>][_y] </span><br><span class="line">                    a[_x][_y - <span class="number">1</span>]  a[_x - <span class="number">1</span>][_y - <span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                que.<span class="built_in">push</span>(<span class="built_in">Robot</span>(_x, _y, r.t + t, (<span class="keyword">char</span>)j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ans[ex][ey] != <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; ans[ex][ey];</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给代码中间加了空行分段是不是很良心2333333</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>杨氏矩阵（杨表） 学习笔记</title>
    <url>/2020/07/31/%E6%9D%A8%E6%B0%8F%E7%9F%A9%E9%98%B5%EF%BC%88%E6%9D%A8%E8%A1%A8%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>其实学这个并不能帮我改变NOI要打铁这件事 从19年集训队论文里抄了一下。省略证明，记一些不严谨，仅仅是能用级别的结论。</p>
<h2 id="杨表的插入"><a href="#杨表的插入" class="headerlink" title="杨表的插入"></a>杨表的插入</h2><p>比如插入行，扫每一行，找到比它大的最小值，交换一下继续下一行。注意到杨表的单调性，可以二分。b找不到就丢这一行后面</p>
<h2 id="杨表与LIS"><a href="#杨表与LIS" class="headerlink" title="杨表与LIS"></a>杨表与LIS</h2><p>杨表第一行的长度就是LIS。</p>
<h2 id="排列计数"><a href="#排列计数" class="headerlink" title="排列计数"></a>排列计数</h2><p>枚举$n$的所有拆分，把它们的$f$（有多少种杨表）的平方加入答案</p>
<h2 id="杨表计数"><a href="#杨表计数" class="headerlink" title="杨表计数"></a>杨表计数</h2><p>定义$h$是某个格子的正下边，正右边（包括自己）一共有几个格子。有钩子公式： $$f_{\lambda} = \frac{n!}{\prod h_{\lambda}(i,j)}$$</p>
<h2 id="LIS长度限制的排列计数"><a href="#LIS长度限制的排列计数" class="headerlink" title="LIS长度限制的排列计数"></a>LIS长度限制的排列计数</h2><p>其实就是限制一下形态之后的杨表计数 $k=2$：$\frac{1}{n+1}\binom{2n}{n}$ $k=3$：$\frac{1}{(n+1)^2(n+2)}\sum_{j=0}^n \binom{2j}{j}\binom{n+1}{k+1}\binom{n+2}{k+1}$ 后面的貌似比较难搞。不过可以证明，这玩意是可以递推的。</p>
<hr>
<p>剩下的东西摸了，来两个题：</p>
<h2 id="BJWC2018-最长上升子序列"><a href="#BJWC2018-最长上升子序列" class="headerlink" title="[BJWC2018]最长上升子序列"></a>[BJWC2018]最长上升子序列</h2><p>考虑暴力枚举$n$的划分，之后用钩子定理搞一下有多少杨表记为$f$，则把$f^2 \lambda_1$计入答案。 当然这个题还有另一种做法：考虑对每个位置的LIS差分，则变成了01序列，DP套DP搞一下即可</p>
<h2 id="CTSC2017-最长上升子序列"><a href="#CTSC2017-最长上升子序列" class="headerlink" title="[CTSC2017]最长上升子序列"></a>[CTSC2017]最长上升子序列</h2><p>最长上升序列不超过$k$，等价于可以划分为不超过$k$个下降序列，即等价于杨表的前$k$列一共有多少元素。 注意到序列给定，于是只需扫描线，动态维护杨表。就有了一个平方算法。 注意到改变杨表的插入方式是等价的，并且对于一个元素，它两位坐标中的min是根号的，于是维护两种矩阵就可以了。至于如何维护第二个矩阵？反转比较方式即可。</p>
<h2 id="三格骨牌"><a href="#三格骨牌" class="headerlink" title="三格骨牌"></a>三格骨牌</h2><p>一道网上找到的模拟赛题 <a href="https://www.cnblogs.com/coldchair/p/11116902.html">https://www.cnblogs.com/coldchair/p/11116902.html</a> <a href="https://memset0.cn/contest20190711">https://memset0.cn/contest20190711</a> 有点丧心病狂，不写了。大概是个钩子定理的题</p>
<h2 id="雅礼集训-2017-Day11-PATH"><a href="#雅礼集训-2017-Day11-PATH" class="headerlink" title="[雅礼集训 2017 Day11]PATH"></a>[雅礼集训 2017 Day11]PATH</h2><p>考虑二维的情况：首先易知这玩意是个卡特兰数。卡特兰数对应了$2 \times n$的杨表。类比一下，这道题就是给定了划分$\lambda$，求有多少种杨表。 考虑钩子公式：要求$\prod h(i,j)$。考虑枚举每个$i$，则可能的值在$[1,\lambda_i+n-i]$之间。首先全乘上，再除掉不合法的。可以注意到，一行的值不一样，所以是个阶乘 考虑什么情况下会不合法：令$r_i =\lambda_i+n-i$，则$r_i - r_j(i &lt; j)$不合法。拆开之后发现FFT一下就行了</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>清华集训2012 模积和</title>
    <url>/2019/07/27/%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2012-%E6%A8%A1%E7%A7%AF%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P2260">[清华集训2012]模积和</a> $$\sum_{i=1}^n \sum_{j=1}^m(n \ {\rm mod} \ i)(m \ {\rm mod} \ i), i \neq j$$ $$\sum_{i=1}^n \sum_{j=1}^m(n \ {\rm mod} \ i)(m \ {\rm mod} \ i) - \sum_{i=1}^&#123;&#123;\rm min}(n,m)}(n \ {\rm mod} \ i)(m \ {\rm mod} \ i)$$ $$\sum_{i=1}^n (n \ {\rm mod} \ i) \sum_{j=1}^m(m \ {\rm mod} \ i) - \sum_{i=1}^&#123;&#123;\rm min}(n,m)}(n \ {\rm mod} \ i)(m \ {\rm mod} \ i)$$ $$\sum_{i=1}^n (n - \lfloor \frac{n}{i} \rfloor) \sum_{j=1}^m(m - \lfloor \frac{m}{i} \rfloor) - \sum_{i=1}^&#123;&#123;\rm min}(n,m)}(n - \lfloor \frac{n}{i} \rfloor)(m - \lfloor \frac{m}{i} \rfloor)$$ $$(n^2 - \sum_{i=1}^n \lfloor \frac{n}{i} \rfloor )(m^2 - \sum_{j=1}^m \lfloor \frac{m}{i} \rfloor)) - {\rm min}(n,m)nm + \sum_{i=1}^&#123;&#123;\rm min}(n,m)} i(n \lfloor \frac{m}{i} \rfloor + m \lfloor \frac{n}{i} \rfloor) - i^2(\lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor)$$ 这式子打起来真累啊… 然后数论分块就行了 不可读代码预警：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">19940417</span>, I2 = <span class="number">9970209</span>, I6 = <span class="number">3323403</span>;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) std::<span class="built_in">swap</span>(n, m);</span><br><span class="line">    <span class="keyword">int</span> tmp1 = n % P * n % P, tmp2 = m % P * m % P,</span><br><span class="line">        tmp3 = n % P * n % P * m % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">        r = n / (n / l),</span><br><span class="line">        tmp1 = (tmp1 - ((r % P * (r + <span class="number">1</span>) % P * I2 % P)</span><br><span class="line">            - (l % P * (l - <span class="number">1</span>) % P * I2 % P)) * (n / l) % P) % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= m; l = r + <span class="number">1</span>)</span><br><span class="line">        r = m / (m / l),</span><br><span class="line">        tmp2 = (tmp2 - ((r % P * (r + <span class="number">1</span>) % P * I2 % P)</span><br><span class="line">            - (l % P * (l - <span class="number">1</span>) % P * I2 % P)) * (m / l) % P) % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">        r = std::<span class="built_in">min</span>(n / (n / l), m / (m / l)),</span><br><span class="line">        tmp3 = (tmp3 - (n % P * (m / l) + m % P * (n / l)) % P</span><br><span class="line">            * ((r % P * (r + <span class="number">1</span>) % P * I2 % P) % P</span><br><span class="line">            - (l % P * (l - <span class="number">1</span>) % P * I2 % P)) % P</span><br><span class="line">            + ((r % P * (r + <span class="number">1</span>) % P * (r * <span class="number">2</span> + <span class="number">1</span>) % P * I6 % P)</span><br><span class="line">            - (l % P * (l - <span class="number">1</span>) % P * (l * <span class="number">2</span> - <span class="number">1</span>) % P * I6 % P))</span><br><span class="line">            % P * (n / l) % P * (m / l)) % P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ((((tmp1 % P + P) % P)</span><br><span class="line">        * ((tmp2 % P + P) % P) % P - tmp3) % P + P) % P);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>残缺的字符串</title>
    <url>/2019/07/01/%E6%AE%8B%E7%BC%BA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4173">残缺的字符串</a> 萌新刚学OI第一天，说错别喷我OAO。 下标从$0$开始，通配符值为$0$，定义两串差异值$(A,B)=\sum_{i=0}^{n-1}(A[i]-B[i])^2A[i]B[i]$。平方是为了不出现正负和为$0$。显然这式子为$0$的时候匹配。 本题，匹配到$B$串的$i$处，定义$f[i]$为差异值。把$A$串翻转一下，就能推出式子：$f[i]=\sum_{j=0}^i(A[j]-B[i-j])^2A[j]B[i-j]= \sum_{j=0}^i A[j]^3B[i-j] + \sum_{j=0}^i A[j]^2B[i-j]^2 + \sum_{j=0}^i A[j]B[i-j]^3$。其实就是三个卷积。FFT。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300000</span> * <span class="number">4</span> + <span class="number">2333</span>, P = <span class="number">998244353</span>, G = <span class="number">3</span>, Gi = <span class="number">332748118</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">fpow</span><span class="params">(LL x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    LL ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = x * x % P)</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = ret * x % P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lim = <span class="number">1</span>, L, rev[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(LL f[], <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i])</span><br><span class="line">            std::<span class="built_in">swap</span>(f[i], f[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        LL T = <span class="built_in">fpow</span>(o == <span class="number">1</span> ? G : Gi, (P - <span class="number">1</span>) / (i &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += (i &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            LL w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k, w = w * T % P) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = f[j + k], ny = w * f[i + j + k] % P;</span><br><span class="line">                f[j + k] = (nx + ny) % P;</span><br><span class="line">                f[i + j + k] = (nx - ny + P) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> aa[N], bb[N];</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line">LL A[N], B[N], C[N];</span><br><span class="line"><span class="keyword">int</span> que[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s%s&quot;</span>, &amp;m, &amp;n, aa, bb);</span><br><span class="line">    std::<span class="built_in">reverse</span>(aa, aa + m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">if</span> (aa[i] != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            a[i] = aa[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (bb[i] != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            b[i] = bb[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lim &lt;= n + m) </span><br><span class="line">        lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>)  ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) &#123;</span><br><span class="line">        A[i] = a[i] * a[i] * a[i];</span><br><span class="line">        B[i] = b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NTT</span>(A, <span class="number">1</span>); <span class="built_in">NTT</span>(B, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        C[i] = (C[i] + A[i] * B[i]) % P;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) &#123;</span><br><span class="line">        A[i] = a[i] * a[i];</span><br><span class="line">        B[i] = b[i] * b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NTT</span>(A, <span class="number">1</span>); <span class="built_in">NTT</span>(B, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        C[i] = (C[i] - A[i] * B[i] * <span class="number">2</span> + P) % P;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) &#123;</span><br><span class="line">        A[i] = a[i];</span><br><span class="line">        B[i] = b[i] * b[i] * b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NTT</span>(A, <span class="number">1</span>); <span class="built_in">NTT</span>(B, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        C[i] = (C[i] + A[i] * B[i]) % P;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NTT</span>(C, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!C[i]) que[++que[<span class="number">0</span>]] = i - m + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, que[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= que[<span class="number">0</span>]; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, que[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>清华集训2017榕树之心 换根DP</title>
    <url>/2020/06/09/%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2017%E6%A6%95%E6%A0%91%E4%B9%8B%E5%BF%83-%E6%8D%A2%E6%A0%B9dp/</url>
    <content><![CDATA[<p><a href="http://uoj.ac/problem/345">[清华集训2017]榕树之心</a></p>
<blockquote>
<p>“榕树还是当年的榕树，你却不是当年的你了”</p>
</blockquote>
<p>先只算根，发现就是要把子树配对，使得根不会动。那么从下往上考虑，因为在比较深的树里如果能匹配很多对，上面需要更多的时候就可以随便减少一些给上面用。那么尽量在深的地方匹配是优秀的。 考虑把子树分成若干堆，考虑用最大的一堆和其它的消除。发现最大的一堆过分大的时候，是消不干净的，这时候需要从子树中拿出来一些匹配。否则只取决于奇偶。 考虑计算其它点的答案：先把根顺着链拉到目标点，之后不动了。于是把链缩成一个点即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> W, T, n, ans[N];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size[N], son[N], dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  size[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y : G[x]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (y != fa) &#123;</span><br><span class="line">      <span class="built_in">dfs1</span>(y, x);</span><br><span class="line">      <span class="keyword">if</span> (size[y] &gt; size[son[x]])</span><br><span class="line">        son[x] = y;</span><br><span class="line">      size[x] += size[y];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> half = size[x] - <span class="number">1</span> - size[son[x]];</span><br><span class="line">  <span class="keyword">if</span> (half &gt;= dp[son[x]] + <span class="number">1</span>)</span><br><span class="line">    dp[x] = (size[x] - <span class="number">1</span>) &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    dp[x] = dp[son[x]] + <span class="number">1</span> - half;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> all, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fir = max, sec = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y : G[x]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (y != fa) &#123;</span><br><span class="line">      <span class="keyword">if</span> (size[y] &gt;= size[fir]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (size[fir] &gt; size[sec])</span><br><span class="line">          sec = fir;</span><br><span class="line">        fir = y;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size[y] &gt; size[sec]) &#123;</span><br><span class="line">        sec = y;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(all &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="keyword">int</span> half = all - size[fir], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (half &gt;= dp[fir] + <span class="number">1</span>)</span><br><span class="line">      cnt = all &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cnt = dp[fir] - half;</span><br><span class="line">    ans[x] = !cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y : G[x]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (y != fa) &#123;</span><br><span class="line">      <span class="built_in">dfs2</span>(y, x, all - <span class="number">1</span>, y == fir ? sec : fir);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">    G[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    G[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> up = W == <span class="number">3</span> ? <span class="number">1</span> : n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= up; ++i)</span><br><span class="line">    <span class="built_in">putchar</span>(ans[i] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    G[i].<span class="built_in">clear</span>();</span><br><span class="line">    size[i] = son[i] = dp[i] = <span class="number">0</span>;</span><br><span class="line">    ans[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  W = <span class="built_in">rd</span>(), T = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>烷基计数 Burnside引理生成函数FFT</title>
    <url>/2019/12/26/%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0-burnside%E5%BC%95%E7%90%86%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0fft/</url>
    <content><![CDATA[<p><a href="https://loj.ac/problem/6538">烷基计数 加强版 加强版</a> 因为我太菜没有约，只能去学高中数学/化学（ 题意就是求无标号，有根，儿子不超过$3$个的树的数量。 做法还是很神奇的。 做一个简单DP：令$f_x$表示$x$个点的答案： $$f_x = \sum_{i+j+k+1 = x} f_i f_j f_k$$ $\uparrow$明显是错的。要去除重复的答案。 其实暴力容斥就行，练一下数数，用Burnside引理。方案数是不动点的平均值。 推一推可以找出六种置换中不动点分别有多少。 $$f_x = \frac{ \sum_{i+j+k+1 = x} f_i f_j f_k + 3\sum_{2i + j + 1 = x} f_i f_j + 2 \sum_{3i + 1 = x} f_i }{6}$$ 写成生成函数： $$F(x) = x \frac{ F(x)^3 + 3 F(x^2)F(x) + 2F(x^3) }{6} + 1$$ 考虑牛顿迭代。在$\mod \lfloor \frac{x}{2} \rfloor$意义下求出$F_0(x)$后，实际上当前的$x,F(x^2),F(x^3)$都知道了。它们可以看做常数项。 $$A(F(x)) \equiv x \frac{ F(x)^3 + 3 F(x^2)F(x) + 2F(x^3) }{6} + 1 - F(x) \equiv 0$$ $$F(x) = F_0(x) - \frac{A(F_0(x))}{A(F_0(x))’}$$ $$A(F(x))’ = x \frac{3F(x)^2 + 3F(x^2)}{6} - 1$$ 带进去就可以做了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">8e5</span> + <span class="number">233</span>, P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">fpow</span><span class="params">(ll x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  ll ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = x * x % P)</span><br><span class="line">    <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = ret * x % P;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Gp = <span class="number">3</span>, Gpi = <span class="built_in">fpow</span>(Gp, P - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rev[N], L, lim;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  L = <span class="number">0</span>, lim = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (lim &lt; n) lim &lt;&lt;= <span class="number">1</span>, ++L;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; ++i)</span><br><span class="line">    rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>)  ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll f[], <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; ++i)</span><br><span class="line">    <span class="keyword">if</span> (i &lt; rev[i])</span><br><span class="line">      std::<span class="built_in">swap</span>(f[i], f[rev[i]]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    ll T = <span class="built_in">fpow</span>(o == <span class="number">1</span> ? Gp : Gpi, (P - <span class="number">1</span>) / (i &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += i &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">      ll w = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k, w = w * T % P) &#123;</span><br><span class="line">        ll nx = f[j + k], ny = f[i + j + k] * w % P;</span><br><span class="line">        f[j + k] = nx + ny &gt;= P ? nx + ny - P : nx + ny;</span><br><span class="line">        f[i + j + k] = nx - ny &gt;= <span class="number">0</span> ? nx - ny : nx - ny + P;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (o == <span class="number">-1</span>) &#123;</span><br><span class="line">    ll inv = <span class="built_in">fpow</span>(lim, P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">      f[i] = f[i] * inv % P;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_inv</span><span class="params">(ll F[], ll G[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">    G[<span class="number">0</span>] = <span class="built_in">fpow</span>(F[<span class="number">0</span>], P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">get_inv</span>(F, G, (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">static</span> ll T[N];</span><br><span class="line">  <span class="built_in">init</span>(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    T[i] = i &lt; n ? F[i] : <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">NTT</span>(G, <span class="number">1</span>), <span class="built_in">NTT</span>(T, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    G[i] = ((<span class="number">2</span> - G[i] * T[i]) % P + P) * G[i] % P;</span><br><span class="line">  <span class="built_in">NTT</span>(G, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; lim; ++i)</span><br><span class="line">    G[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; ll A[N], B[N], C[N], D[N], E[N], F[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> A[<span class="number">0</span>] = <span class="number">1</span>, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">  <span class="built_in">solve</span>((n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>); <span class="built_in">init</span>(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    B[i] = C[i] = D[i] = E[i] = F[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> &lt; n) B[i * <span class="number">2</span>] = A[i];</span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">3</span> &lt; n) C[i * <span class="number">3</span>] = A[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">NTT</span>(A, <span class="number">1</span>), <span class="built_in">NTT</span>(B, <span class="number">1</span>), <span class="built_in">NTT</span>(C, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) &#123;</span><br><span class="line">    D[i] = (A[i] * A[i] % P * A[i] % P + <span class="number">3</span> * B[i] * A[i] % P + <span class="number">2</span> * C[i]) % P;</span><br><span class="line">    E[i] = (<span class="number">3</span> * A[i] * A[i] % P + <span class="number">3</span> * B[i]) % P;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">NTT</span>(A, <span class="number">-1</span>), <span class="built_in">NTT</span>(D, <span class="number">-1</span>), <span class="built_in">NTT</span>(E, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = lim - <span class="number">1</span>; i; --i)</span><br><span class="line">    D[i] = D[i - <span class="number">1</span>], E[i] = E[i - <span class="number">1</span>];</span><br><span class="line">  D[<span class="number">0</span>] = <span class="number">6</span>; E[<span class="number">0</span>] = P - <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    D[i] = (D[i] - <span class="number">6</span> * A[i] % P + P) % P;</span><br><span class="line">  <span class="built_in">get_inv</span>(E, F, lim);</span><br><span class="line">  <span class="built_in">NTT</span>(D, <span class="number">1</span>), <span class="built_in">NTT</span>(F, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    F[i] = (P - D[i] * F[i] % P) % P;</span><br><span class="line">  <span class="built_in">NTT</span>(F, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    A[i] = (A[i] + F[i]) % P;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; lim; ++i)</span><br><span class="line">    A[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cin &gt;&gt; n;</span><br><span class="line">  <span class="built_in">init</span>(n);</span><br><span class="line">  <span class="built_in">solve</span>(n + <span class="number">1</span>);</span><br><span class="line">  std::cout &lt;&lt; A[n] &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>方格取数加强版</title>
    <url>/2019/03/31/%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E5%8A%A0%E5%BC%BA%E7%89%88/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2045">方格取数加强版</a> 其实是大水题，但是看到tkj博客写了，也想写一个（这什么理由…? 拆下点，然后s-&gt;(1,1)，(n,n)-&gt;t，流量k，(i,j)-&gt;(i+1,j)，(i,j)-&gt;(i,j+1)，入-&gt;出，流量INF，入-&gt;出，流量1费用c，跑最大费用最大流。入出之间两条边，分别表示可以取一次和可以通过无数次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50000</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt, cost, flow;</span><br><span class="line">&#125; g[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot = <span class="number">1</span>, n, k, num, id[<span class="number">100</span>][<span class="number">100</span>][<span class="number">2</span>],</span><br><span class="line">    s = ++num, t = ++num, dis[N], ans;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> f, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    g[++tot].to = y, g[tot].nxt = head[x], g[tot].flow = f,</span><br><span class="line">    g[tot].cost = c, head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> f, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">addedge</span>(x, y, f, c);</span><br><span class="line">    <span class="built_in">addedge</span>(y, x, <span class="number">0</span>, -c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    dis[t] = <span class="number">0</span>, vis[t] = <span class="literal">true</span>, que.<span class="built_in">push</span>(t);</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[i ^ <span class="number">1</span>].flow &amp;&amp; dis[g[i].to] &gt; dis[x] - g[i].cost) &#123;</span><br><span class="line">                dis[g[i].to] = dis[x] - g[i].cost;</span><br><span class="line">                <span class="keyword">if</span> (!vis[g[i].to]) &#123;</span><br><span class="line">                    vis[g[i].to] = <span class="literal">true</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(g[i].to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[s] != INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> mf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t) <span class="keyword">return</span> mf;</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> used = <span class="number">0</span>, tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g[i].flow &amp;&amp; !vis[g[i].to] &amp;&amp; dis[g[i].to] == dis[x] - g[i].cost) &#123;</span><br><span class="line">            tmp = <span class="built_in">dfs</span>(g[i].to, <span class="built_in">min</span>(g[i].flow, mf - used));</span><br><span class="line">            ans += tmp * g[i].cost, used += tmp,</span><br><span class="line">            g[i].flow -= tmp, g[i ^ <span class="number">1</span>].flow += tmp;</span><br><span class="line">            <span class="keyword">if</span> (used == mf) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">costflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">spfa</span>())</span><br><span class="line">        <span class="built_in">dfs</span>(s, INF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(), k = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            id[i][j][<span class="number">0</span>] = ++num;</span><br><span class="line">            id[i][j][<span class="number">1</span>] = ++num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="built_in">add</span>(id[i][j][<span class="number">0</span>], id[i][j][<span class="number">1</span>], <span class="number">1</span>, -<span class="built_in">rd</span>());</span><br><span class="line">            <span class="built_in">add</span>(id[i][j][<span class="number">0</span>], id[i][j][<span class="number">1</span>], INF, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">add</span>(id[i][j][<span class="number">1</span>], id[i + <span class="number">1</span>][j][<span class="number">0</span>], INF, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">add</span>(id[i][j][<span class="number">1</span>], id[i][j + <span class="number">1</span>][<span class="number">0</span>], INF, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add</span>(s, id[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], k, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">add</span>(id[n][n][<span class="number">1</span>], t, k, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">costflow</span>();</span><br><span class="line">    cout &lt;&lt; -ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> kai586123::<span class="built_in">main</span>(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>牛客CSP-S集训营4排列计数机 斯特林数DP线段树</title>
    <url>/2019/11/06/%E7%89%9B%E5%AE%A2csp-s%E9%9B%86%E8%AE%AD%E8%90%A54%E6%8E%92%E5%88%97%E8%AE%A1%E6%95%B0%E6%9C%BA-%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0dp%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/1103/C">排列计数机</a> 神仙题…. (博客有点bug打不出斯特林数的括号,用$S$代替了) 首先我们要知道第二类斯特林数的一个式子: $$x^m = \sum_{i=0}^m S(m,i) i! \binom{x}{i}$$ 这个式子的意思是,$m$个不同球丢进$x$个盒子里,可以空的方案数,等于钦定$i$个非空方案数之和 所以只需要维护所有$\binom{x}{i}$就行了 考虑一个数数的式子,$f_{i,j}$表示前$i$个数,并且以$i$结尾的子段中,最大数有$j$个的数量 $$f_{i,j} = \sum_{k &lt; i, A_k &lt; A_i} f_{k, j - 1} 2^{ less_{k,i} }$$ $less_{i,j}$表示区间$(i,j)$中比$A_i$小的数数量 那么,最终对于每种最大值出现次数$j$,对答案的贡献是 $$\sum_{i} f_{i,j} 2^{less_{i,n+1&#125;&#125;$$ 考虑用线段树优化这个$O(n^3)$的DP 线段树每个节点维护一个数组.令数组$B_{A_i}=i$,那么扫到第$i$个的时候,线段树叶子$j$的数组$k$,表示 $$\sum_x f_{B_j,x} 2^{less_{B_j,i&#125;&#125; \binom{x}{k}$$ 考虑$i-1 \rightarrow i$时的影响.首先, $&gt; A_i$的贡献是$\times 2$ 我们考虑下面两个式子: $$f_{i,j} = \sum_k f_{k,j-1}$$ $$\binom{n}{m} = \binom{n-1}{m-1} + \binom{n-1}{m}$$ 我们现在线段树可以得到对于任意$x$的这个东西 $$\sum_k f_{k,j-1} \binom{j-1}{x}$$ 所以按照组合数的式子求和,就可以更新新的叶子的值了 最后就可以借助$S$求答案了,具体看代码吧……. <a href="https://www.luogu.org/paste/jjdvozzy">不乱码的代码看这里</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">233</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, A[N], S[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> val[<span class="number">21</span>], tag;</span><br><span class="line">  <span class="built_in">Node</span>() &#123;</span><br><span class="line">    tag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(val, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(val));</span><br><span class="line">  &#125;</span><br><span class="line">&#125; tree[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(p) p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(p) p &lt;&lt; 1  1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)</span><br><span class="line">    tree[p].val[i] = (<span class="keyword">long</span> <span class="keyword">long</span>)tree[p].val[i] * v % P;</span><br><span class="line">  tree[p].tag = (<span class="keyword">long</span> <span class="keyword">long</span>)tree[p].tag * v % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tree[p].tag != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">push</span>(<span class="built_in">ls</span>(p), tree[p].tag);</span><br><span class="line">    <span class="built_in">push</span>(<span class="built_in">rs</span>(p), tree[p].tag);</span><br><span class="line">    tree[p].tag = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node <span class="keyword">operator</span>+(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b) &#123;</span><br><span class="line">  Node ret;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)</span><br><span class="line">    ret.val[i] = (a.val[i] + b.val[i]) % P;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">push</span>(p, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">pushdown</span>(p);</span><br><span class="line">  <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">    <span class="built_in">mul</span>(<span class="built_in">ls</span>(p), l, r, L, mid);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">    <span class="built_in">mul</span>(<span class="built_in">rs</span>(p), l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">  tree[p] = tree[<span class="built_in">ls</span>(p)] + tree[<span class="built_in">rs</span>(p)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R)</span><br><span class="line">    <span class="keyword">return</span> tree[p];</span><br><span class="line">  <span class="built_in">pushdown</span>(p);</span><br><span class="line">  <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid &amp;&amp; r &gt; mid)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r, L, mid)</span><br><span class="line">      + <span class="built_in">query</span>(<span class="built_in">rs</span>(p), l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r, L, mid);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, Node y, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">    tree[p].val[<span class="number">0</span>] = y.val[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">      tree[p].val[i] = (y.val[i] + y.val[i - <span class="number">1</span>]) % P;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pushdown</span>(p);</span><br><span class="line">  <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">    <span class="built_in">insert</span>(<span class="built_in">ls</span>(p), x, y, L, mid);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">insert</span>(<span class="built_in">rs</span>(p), x, y, mid + <span class="number">1</span>, R);</span><br><span class="line">  tree[p] = tree[<span class="built_in">ls</span>(p)] + tree[<span class="built_in">rs</span>(p)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen(&quot;c.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">  n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    A[i] = <span class="built_in">rd</span>();</span><br><span class="line"></span><br><span class="line">  S[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">      S[i][j] = (S[i - <span class="number">1</span>][j - <span class="number">1</span>] + (<span class="keyword">long</span> <span class="keyword">long</span>)j * S[i - <span class="number">1</span>][j]) % P;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (A[i] != n)</span><br><span class="line">      <span class="built_in">mul</span>(<span class="number">1</span>, A[i] + <span class="number">1</span>, n, <span class="number">1</span>, n);</span><br><span class="line">    Node ret;</span><br><span class="line">    <span class="keyword">if</span> (A[i] != <span class="number">1</span>)</span><br><span class="line">      ret = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, A[i] - <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    ++ret.val[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">1</span>, A[i], ret, <span class="number">1</span>, n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>, pow = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    ans = (ans + S[m][i] * pow % P * tree[<span class="number">1</span>].val[i]) % P;</span><br><span class="line">    pow = pow * (i + <span class="number">1</span>) % P;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>留言板</title>
    <url>/1970/01/01/%E7%95%99%E8%A8%80%E6%9D%BF/</url>
    <content><![CDATA[<p>OwO</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>管理</title>
    <url>/2019/01/05/%E7%99%BB%E9%99%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
  </entry>
  <entry>
    <title>砝码称重</title>
    <url>/2019/01/05/%E7%A0%9D%E7%A0%81%E7%A7%B0%E9%87%8D/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1441">Luogu P1441 砝码称重</a> 在N个数中去掉M个数，剩下的取任意个数相加，求最多能得到多少种和 看到题解里有用位运算的，不过本题dfs+dp即可解决 首先dfs出所有去掉M个数后的情况，暴力枚举即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s表示选中数字最大和</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n + m &gt; N + <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="built_in">dp</span>(s);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(n + <span class="number">1</span>, m, s);</span><br><span class="line">        use[n] = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(n + <span class="number">1</span>, m - <span class="number">1</span>, s - a[n]);</span><br><span class="line">        use[n] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由数据范围可知，本题的和最大不超过2000，容易想到dp求和的数量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    f[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!use[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = s; j &gt;= a[i]; --j)&#123;</span><br><span class="line">            f[j] = f[j-a[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s; ++i)&#123;</span><br><span class="line">        cnt += f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>第十四届中北大学ACM程序设计竞赛 题解</title>
    <url>/2019/05/19/%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%B1%8A%E4%B8%AD%E5%8C%97%E5%A4%A7%E5%AD%A6acm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>看了看，题比去年的简单很多，而且真大佬们都没来。封榜之前切了九道题，后面一小时一个没过，没想到还是Rank1了。。。 中北大学官网挂了，所以先从别的博客里找题面…代码也等复活再补 一些吐槽：气球没给够，还有一个漏气了…那个评测机性能太差啦！！！！成功吃我5发罚时。还有学校居然不给奖品/给本校的有特等奖我的是一等奖… 一些奇怪的总结：考试前记得吃饭…考到后面有点饿，想不出来题，状态没了…</p>
<h3 id="A-CQW又迟到了"><a href="#A-CQW又迟到了" class="headerlink" title="A.CQW又迟到了"></a>A.CQW又迟到了</h3><p>模拟就行了，不说。</p>
<h3 id="B-CQW的倔强"><a href="#B-CQW的倔强" class="headerlink" title="B.CQW的倔强"></a>B.CQW的倔强</h3><p>暴力能过，不说。</p>
<h3 id="C-WYS非常方"><a href="#C-WYS非常方" class="headerlink" title="C.WYS非常方"></a>C.WYS非常方</h3><p>给定n&lt;=5000个点，求能围成的最大矩形。 枚举对角线，然后算出另外两个点坐标。这题内存开的小，用set存点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; p[<span class="number">5000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//int map[6000][6000];</span></span><br><span class="line"></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; map[<span class="number">6000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc_xielv</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b.y &gt;= a.y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        p[i].x = <span class="built_in">rd</span>();</span><br><span class="line">        p[i].y = <span class="built_in">rd</span>();</span><br><span class="line"><span class="comment">//      map[p[i].x][p[i].y] = true;</span></span><br><span class="line">        map[p[i].x].<span class="built_in">insert</span>(p[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            Point a = p[i], b = p[j];</span><br><span class="line">            <span class="keyword">if</span> (a.x &gt; b.x)</span><br><span class="line">                <span class="built_in">swap</span>(a, b);</span><br><span class="line">            <span class="keyword">int</span> xl = <span class="built_in">calc_xielv</span>(a, b);</span><br><span class="line">            <span class="keyword">if</span> (xl == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = <span class="built_in">abs</span>(a.x - b.x) + <span class="built_in">abs</span>(a.y - b.y);</span><br><span class="line">                <span class="keyword">if</span> (tmp &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> x1 = b.x - tmp / <span class="number">2</span>, x2 = a.x + tmp / <span class="number">2</span>, y1 = a.y + tmp / <span class="number">2</span>, y2 = b.y - tmp / <span class="number">2</span>;</span><br><span class="line"><span class="comment">//                  if (map[x1][y1] &amp;&amp; map[x2][y2]) &#123;</span></span><br><span class="line"><span class="comment">//                      ans = max(ans, ((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y)) / 2);</span></span><br><span class="line"><span class="comment">//                  &#125;</span></span><br><span class="line">                    <span class="keyword">if</span> (x1 &gt; N  x2 &gt; N  y1 &gt; N  y2 &gt; N) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (x1 &lt; <span class="number">1</span>  x2 &lt; <span class="number">1</span>  y1 &lt; <span class="number">1</span>  y2 &lt; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (map[x1].<span class="built_in">find</span>(y1) != map[x1].<span class="built_in">end</span>() &amp;&amp; map[x2].<span class="built_in">find</span>(y2) != map[x2].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        ans = <span class="built_in">max</span>(ans, ((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y)) / <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = <span class="built_in">abs</span>(a.x - b.x) + <span class="built_in">abs</span>(a.y - b.y);</span><br><span class="line">                <span class="keyword">if</span> (tmp &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                  int x1 = b.x - tmp / 2, x2 = a.x + tmp / 2, y1 = a.y + tmp / 2, y2 = b.y - tmp / 2;</span></span><br><span class="line">                    <span class="keyword">int</span> x1 = a.x + tmp / <span class="number">2</span>, x2 = b.x - tmp / <span class="number">2</span>, y1 = b.y + tmp / <span class="number">2</span>, y2 = a.y - tmp / <span class="number">2</span> ;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (x1 &gt; N  x2 &gt; N  y1 &gt; N  y2 &gt; N) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (x1 &lt; <span class="number">1</span>  x2 &lt; <span class="number">1</span>  y1 &lt; <span class="number">1</span>  y2 &lt; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (map[x1].<span class="built_in">find</span>(y1) != map[x1].<span class="built_in">end</span>() &amp;&amp; map[x2].<span class="built_in">find</span>(y2) != map[x2].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        ans = <span class="built_in">max</span>(ans, ((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y)) / <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="D-绝对强者LYF"><a href="#D-绝对强者LYF" class="headerlink" title="D.绝对强者LYF"></a>D.绝对强者LYF</h3><p>水题，排序就行了，不说</p>
<h3 id="E-1009的奇思妙想"><a href="#E-1009的奇思妙想" class="headerlink" title="E.1009的奇思妙想"></a>E.1009的奇思妙想</h3><p>作为考场唯一A掉这个题的，吐槽一下。。。一开始写的程序本题跑最大数据0.15s，交上去TLE…后来改成本地0.1s的才过… 因为全是四位质数，我们DP，可以随手写出转移方程：$f[i][j]$表示考虑了i位，结尾3位是j的情况。枚举所有四位质数，f[i][后三位]+=f[i-1][前三位]。从前面转移来就行。卡卡常就过了。</p>
<h3 id="F-CQW的幸福"><a href="#F-CQW的幸福" class="headerlink" title="F.CQW的幸福"></a>F.CQW的幸福</h3><p>把$4^n$个因子换成$2^{2n}$。有个数学结论：令$a=\sum_i {p_i}^{c_i},p \in prime$。那么$a$的因数个数就是$\prod (c_i+1)$。由唯一分解定理，组合一下，显然成立。我们筛出2n个质数塞进小根堆里，每次取出一个乘进答案，平方一下塞回堆里。</p>
<h3 id="G-FWJ的追求者"><a href="#G-FWJ的追求者" class="headerlink" title="G.FWJ的追求者"></a>G.FWJ的追求者</h3><p>显然如果能表示出1~n/2，那么只需要一个n-n/2就可以表示剩下的。每次/2，cnt+1。</p>
<h3 id="H-ZBT的学分"><a href="#H-ZBT的学分" class="headerlink" title="H.ZBT的学分"></a>H.ZBT的学分</h3><p>如果存在喜欢的，就枚举选哪个，转化为不存在喜欢的情况。 有32个活动，$O(2^{32})$枚举必TLE。然而我们可以借鉴meet in the middle搜索那种做法，折半的做。 即把活动分成两部分，$O(2^{16})$分别拼一下，然后排序，枚举其中一个，在另一个里面二分，找有多少匹配值。</p>
<h3 id="I-SHT的梦想"><a href="#I-SHT的梦想" class="headerlink" title="I.SHT的梦想"></a>I.SHT的梦想</h3><p>线段树维护修改，然后查询扩展欧拉定理搞一下。</p>
<h3 id="J-ZBT的游戏"><a href="#J-ZBT的游戏" class="headerlink" title="J.ZBT的游戏"></a>J.ZBT的游戏</h3><p>线段树+bitset。每个点开个bitset表示存在的颜色。然后就很裸了。</p>
<h3 id="K-ZJ和LQW打羽毛球"><a href="#K-ZJ和LQW打羽毛球" class="headerlink" title="K.ZJ和LQW打羽毛球"></a>K.ZJ和LQW打羽毛球</h3><p>忘记题了…考场上也没做出来…</p>
<h3 id="L-SW和ZK的恋爱"><a href="#L-SW和ZK的恋爱" class="headerlink" title="L.SW和ZK的恋爱"></a>L.SW和ZK的恋爱</h3><p>如果某数个位是1，3，7，9，显然只有*10才能加0。 如果是2，4，6，8，*5即可。 如果是5，*2即可。 递归搞一下，完事。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> x = n % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            <span class="built_in">dfs</span>(n / <span class="number">10</span>, k - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">1</span>  x == <span class="number">3</span>  x == <span class="number">7</span>  x == <span class="number">9</span>) &#123;</span><br><span class="line">            cout &lt;&lt; n;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">                cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">                cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(n * <span class="number">2</span>, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(n * <span class="number">5</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k; cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">dfs</span>(n, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="M-SunW的假期"><a href="#M-SunW的假期" class="headerlink" title="M.SunW的假期"></a>M.SunW的假期</h3><p>掰手指都能数清，略。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>简单博弈论 | SG函数 学习笔记</title>
    <url>/2019/11/09/%E7%AE%80%E5%8D%95%E5%8D%9A%E5%BC%88%E8%AE%BA-sg%E5%87%BD%E6%95%B0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>昨日膜你赛考了SG函数 发现一道题都没写过所以也没想到 大惊 赶快补习一下…</p>
<hr>
<h3 id="Nim游戏"><a href="#Nim游戏" class="headerlink" title="Nim游戏"></a>Nim游戏</h3><p>估计全世界博弈论都是第一个学的Nim游戏… Nim游戏就是给定$n$堆物品,$i$堆有$A_i$个,每个人可以选一堆拿任意多,没的取的输. 做法是,先手必胜, $$\oplus_{i=1}^n A_i \neq 0$$</p>
<h4 id="简单证明"><a href="#简单证明" class="headerlink" title="简单证明"></a>简单证明</h4><p>如果xor和不为$0$,设最高二进制不为$0$位为$k$,肯定有一个数,$k$位为$1$,那么我们可以取走一些使得它变成$0$. 对于对手一个使得xor不为$0$的操作,显然可以用上述办法消除影响,因此必败 貌似这个操作叫Nim和的说</p>
<h3 id="Nim-k游戏"><a href="#Nim-k游戏" class="headerlink" title="Nim-k游戏"></a>Nim-k游戏</h3><p>就是可以取$k$堆.推广xor运算为$\mod (k+1)$的即可</p>
<h3 id="阶梯Nim游戏"><a href="#阶梯Nim游戏" class="headerlink" title="阶梯Nim游戏"></a>阶梯Nim游戏</h3><p>挑选一个位置$i$,任选个数移到$i-1$ 如果一个人把一个位置上的移动了,另一个人可以把那些再前移,所以等价于在奇数位置玩Nim游戏</p>
<h3 id="反Nim游戏"><a href="#反Nim游戏" class="headerlink" title="反Nim游戏"></a>反Nim游戏</h3><p>取走最后一个的人输 必胜要求满足以下条件之一: 存在一堆个数$&gt; 1$,xor不为$0$ 每一堆个数都是$1$,xor为$0$</p>
<hr>
<h3 id="Sprague-Grundy函数"><a href="#Sprague-Grundy函数" class="headerlink" title="Sprague-Grundy函数"></a>Sprague-Grundy函数</h3><p>$$SG(x) = {\rm mex}_y \lbrace SG(y) \rbrace$$ 其中$y$是有向图游戏中$x$可以到达的状态 必胜SG函数$&gt;0$,否则必败</p>
<h4 id="简单证明-1"><a href="#简单证明-1" class="headerlink" title="简单证明:"></a>简单证明:</h4><p>归纳法. 最终状态为$0$ 如果存在必胜态,那么必有后继必败,$SG$必不为$0$ 反之亦然</p>
<h3 id="Sprague-Grundy定理"><a href="#Sprague-Grundy定理" class="headerlink" title="Sprague-Grundy定理"></a>Sprague-Grundy定理</h3><h4 id="游戏的和"><a href="#游戏的和" class="headerlink" title="游戏的和"></a>游戏的和</h4><p>存在有向图游戏$G_i$,定义$G$是任选某个$G_i$并且行动的有向图游戏,那么有 $$SG(G) = \oplus_{i=1}^n SG(G_i)$$</p>
<h4 id="简单证明-2"><a href="#简单证明-2" class="headerlink" title="简单证明"></a>简单证明</h4><p>其实和Nim游戏证明差不多…</p>
<h3 id="SG函数与Nim游戏"><a href="#SG函数与Nim游戏" class="headerlink" title="SG函数与Nim游戏"></a>SG函数与Nim游戏</h3><p>我们考虑用SG函数处理Nim游戏.每一堆都是一个有向图游戏,石子数量正好等于SG函数值. 完 全 一 致</p>
<h3 id="反SG函数"><a href="#反SG函数" class="headerlink" title="反SG函数"></a>反SG函数</h3><p>就是反Nim游戏那个东西,规则也一样</p>
<hr>
<h3 id="其他博弈问题"><a href="#其他博弈问题" class="headerlink" title="其他博弈问题"></a>其他博弈问题</h3><p>这部分证明大部分先咕了…</p>
<h3 id="Bash博弈"><a href="#Bash博弈" class="headerlink" title="Bash博弈"></a>Bash博弈</h3><p>一堆$n$个物品,每次取$[1,m]$个 取光胜必败条件: $n \mod (m+1) = 0$,归纳可</p>
<h4 id="简单证明-3"><a href="#简单证明-3" class="headerlink" title="简单证明"></a>简单证明</h4><p>很简单,一定存在方案使得两个人各取一次,$sum = m +1$</p>
<h3 id="Wythoff博弈"><a href="#Wythoff博弈" class="headerlink" title="Wythoff博弈"></a>Wythoff博弈</h3><p>我是鸽王</p>
<h3 id="树上删边游戏"><a href="#树上删边游戏" class="headerlink" title="树上删边游戏"></a>树上删边游戏</h3><p>$$SG(leaf) = 0$$ $$SG(x) = \oplus (SG(y)+1)$$</p>
<h3 id="无向图删边游戏"><a href="#无向图删边游戏" class="headerlink" title="无向图删边游戏"></a>无向图删边游戏</h3><p>“将图中的任意一个偶环缩成一个新点，任意一个奇环缩成一个新点加一个新边；所有连到原先环上的边全部改为与新点相连。这样的改动不会影响图的SG 值。”</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>简单的数学题</title>
    <url>/2019/06/29/%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3768">简单的数学题</a> 简单你emoji，我太菜了 $$\sum_{i=1}^n \sum_{j=1}^n ijgcd(i,j)$$ $$\sum_{i=1}^n \sum_{j=1}^n ij \sum_{d \mid gcd(i,j)} \varphi(d)$$ $$\sum_{d=1}^n \varphi(d) \sum_{d \mid i}^n \sum_{d \mid j}^n ij $$ $$\sum_{d=1}^n \varphi(d) d^2 \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{d} \rfloor} ij $$ $$\sum_{d=1}^n \varphi(d) d^2 \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{d} \rfloor} ij $$ 一看数据范围，发现不可做，光速补习杜教筛 然后令 $$f(x)=\varphi(x) x^2,g(x)=x^2$$ 那么卷一下 $$(f*g)(x)=\sum_{i \mid x} \varphi(i) i^2 (\frac{x}{i})^2= x^3$$ 可做了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e6</span>;</span><br><span class="line"><span class="keyword">int</span> mod, inv, n, phi[N], pri[N], tot, ss[N], ans;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ss[<span class="number">1</span>] = phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) pri[++tot] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * pri[j] &lt; N; ++j) &#123;</span><br><span class="line">            vis[i * pri[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                phi[i * pri[j]] = phi[i] * pri[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[i * pri[j]] = phi[i] * (pri[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ss[i] = (ss[i - <span class="number">1</span>] + phi[i] * i % mod * i % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = ret * x % mod;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sp2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x * (x + <span class="number">1</span>) % mod * (x * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">        % mod * inv % mod &lt; <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;?&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> x * (x + <span class="number">1</span>) % mod * (x * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">        % mod * inv % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sp3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((x * (x + <span class="number">1</span>) / <span class="number">2</span> % mod)</span><br><span class="line">        * (x * (x + <span class="number">1</span>) / <span class="number">2</span> % mod) % mod &lt; <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;?&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> (x * (x + <span class="number">1</span>) / <span class="number">2</span> % mod)</span><br><span class="line">        * (x * (x + <span class="number">1</span>) / <span class="number">2</span> % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; N) <span class="keyword">return</span> ss[x];</span><br><span class="line">    <span class="keyword">if</span> (s[x]) <span class="keyword">return</span> s[x];</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">sp3</span>(x % mod);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, r; l &lt;= x; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = x / (x / l);</span><br><span class="line">        ret = (ret - (<span class="built_in">sp2</span>(r % mod) - <span class="built_in">sp2</span>((l - <span class="number">1</span>) % mod) + mod) % mod</span><br><span class="line">            * <span class="built_in">calc</span>(x / l) % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[x] = ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = n / (n / l);</span><br><span class="line">        ans = (ans + <span class="built_in">sp3</span>((n / l) % mod) *</span><br><span class="line">            ((<span class="built_in">calc</span>(r) - <span class="built_in">calc</span>(l - <span class="number">1</span>) % mod)</span><br><span class="line">            + mod) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; mod &gt;&gt; n;</span><br><span class="line">    inv = <span class="built_in">fpow</span>(<span class="number">6</span>, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">init</span>(); <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>简单题</title>
    <url>/2019/06/30/%E7%AE%80%E5%8D%95%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3687">简单题</a> 简单你emoji，我太菜了 题目四个问题，一一解答：</p>
<ol>
<li>按位处理求有多少1的子集</li>
<li>n&gt;=2就是0</li>
<li>算出现多少次</li>
<li>本题正文：</li>
</ol>
<p>观察到$\Sigma$很小，开一个bitset存哪些和出现次数为奇数即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    bitset&lt;2001000&gt; bit;</span><br><span class="line">    bit[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x; cin &gt;&gt; x;</span><br><span class="line">        bit ^= bit &lt;&lt; x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2001000</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (bit[i])</span><br><span class="line">            ans ^= i;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>红色的幻想乡</title>
    <url>/2019/03/02/%E7%BA%A2%E8%89%B2%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3801">红色的幻想乡</a> 二维线段树爆空间，改用一个巧妙的办法。注意到红雾叠加偶数次会消失，容易想到异或。交点处不放红雾，可以看作横竖方向叠加。 开两个线段树，分别表示横向/纵向某区间有没有红雾。对于修改操作，修改$x$，$y$线段树对应的$x$，$y$位置。对于查询操作，我们令$cnt_x$，$cnt_y$分别表示$[x1,x2]$，$[y1,y2]$内有红雾的个数。则由容斥原理，答案为$cnt_x(y2-y1+1)+cnt_y(x2-x1+1)-2cnt_xcnt_y$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000000</span> + <span class="number">2333</span>;</span><br><span class="line">    <span class="keyword">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val[N], sum[N];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (L == R) val[p] ^= <span class="number">1</span>, sum[p] = val[p];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">change</span>(p &lt;&lt; <span class="number">1</span>, x, L, mid);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">change</span>(p &lt;&lt; <span class="number">1</span>  <span class="number">1</span>, x, mid + <span class="number">1</span>, R);</span><br><span class="line">                sum[p] = sum[p &lt;&lt; <span class="number">1</span>] + sum[p &lt;&lt; <span class="number">1</span>  <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R) <span class="keyword">return</span> sum[p];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (l &lt;= mid) ans += <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>, l, r, L, mid);</span><br><span class="line">                <span class="keyword">if</span> (r &gt; mid) ans += <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>  <span class="number">1</span>, l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; tn, tm;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>(), q = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">rd</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">                tn.<span class="built_in">change</span>(<span class="number">1</span>, <span class="built_in">rd</span>(), <span class="number">1</span>, n);</span><br><span class="line">                tm.<span class="built_in">change</span>(<span class="number">1</span>, <span class="built_in">rd</span>(), <span class="number">1</span>, m);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> x1 = <span class="built_in">rd</span>(), y1 = <span class="built_in">rd</span>(), x2 = <span class="built_in">rd</span>(), y2 = <span class="built_in">rd</span>(),</span><br><span class="line">                    x = tn.<span class="built_in">query</span>(<span class="number">1</span>, x1, x2, <span class="number">1</span>, n),</span><br><span class="line">                    y = tm.<span class="built_in">query</span>(<span class="number">1</span>, y1, y2, <span class="number">1</span>, m);</span><br><span class="line">                cout &lt;&lt; ((<span class="keyword">long</span> <span class="keyword">long</span>)x * (y2 - y1 + <span class="number">1</span>)</span><br><span class="line">                    + (<span class="keyword">long</span> <span class="keyword">long</span>)y * (x2 - x1 + <span class="number">1</span>) - <span class="number">2LL</span> * x * y) &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>算术天才⑨与等差数列</title>
    <url>/2019/05/28/%E7%AE%97%E6%9C%AF%E5%A4%A9%E6%89%8D%E2%91%A8%E4%B8%8E%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4373">算术天才⑨与等差数列</a> 神奇的线段树题。</p>
<h3 id="菜菜的解法1（玄学）："><a href="#菜菜的解法1（玄学）：" class="headerlink" title="菜菜的解法1（玄学）："></a>菜菜的解法1（玄学）：</h3><p>观察到等差数列这玩意完全没法直接存嘛…我们可以考虑用hash的思想，维护区间的一些什么东西。维护区间和不太科学，那就维护区间平方和，立方和，…。显然维护的越多越稳。 推一波等差数列平方和式子： 令首项为$x$，项数为$n$，公差为$d$，则 $$ \sum_{i=1}^n (x+(i-1)d)^2 \newline =\sum_{i=0}^{n-1} (x+id)^2 \newline =\sum_{i=0}^{n-1} x^2+2xid+i^2d^2 \newline =nx + 2xd \sum_{i=0}^{n-1} i + d^2 \sum_{i=0}^{n-1} i^2 \newline =nx + xdn(n-1) + \frac {d^2n(n-1)(2n-1)}{6} $$ 所以我们维护一下最小数和区间平方和，每次算一下等差数列平方和就行了。</p>
<h3 id="强强的解法2（正解）："><a href="#强强的解法2（正解）：" class="headerlink" title="强强的解法2（正解）："></a>强强的解法2（正解）：</h3><p>一坨数字能成为等差数列，它们满足以下性质： $max-min=d$ $gcd(abs(a_i-a_{i-1}))=k$ $[l,r]$内数字无重复，即$max(pre[a_i])&lt;l$。 所以维护一下每个数字上一次出现位置，区间最大公约数，最大值，最小值就行了。 解法1代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300000</span> + <span class="number">2333</span>, P = <span class="number">1000000007</span>, INV = <span class="number">166666668</span>, INF = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, cnt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, min, v;</span><br><span class="line">&#125; t[N * <span class="number">4</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(p) p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(p) p &lt;&lt; 1  1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    t[p].min = <span class="built_in">min</span>(t[<span class="built_in">ls</span>(p)].min, t[<span class="built_in">rs</span>(p)].min);</span><br><span class="line">    t[p].v = (t[<span class="built_in">ls</span>(p)].v + t[<span class="built_in">rs</span>(p)].v) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[p].l = l; t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        t[p].min = <span class="built_in">rd</span>();</span><br><span class="line">        t[p].v = t[p].min * t[p].min % P;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(p), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[p].l == t[p].r) &#123;</span><br><span class="line">        t[p].v = y * y % P;</span><br><span class="line">        t[p].min = y;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">        <span class="built_in">change</span>(<span class="built_in">ls</span>(p), x, y);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">change</span>(<span class="built_in">rs</span>(p), x, y);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_pair</span>(t[p].min, t[p].v);</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ret = <span class="built_in">make_pair</span>(INF, <span class="number">0</span>), tmp;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) &#123;</span><br><span class="line">        tmp = <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r);</span><br><span class="line">        ret.first = <span class="built_in">min</span>(ret.first, tmp.first);</span><br><span class="line">        ret.second = (ret.second + tmp.second) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) &#123;</span><br><span class="line">        tmp = <span class="built_in">query</span>(<span class="built_in">rs</span>(p), l, r);</span><br><span class="line">        ret.first = <span class="built_in">min</span>(ret.first, tmp.first);</span><br><span class="line">        ret.second = (ret.second + tmp.second) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (l * x % P * x % P</span><br><span class="line">        + x * k % P * l % P * (l - <span class="number">1</span>) % P</span><br><span class="line">        + k * k % P * l % P * (l - <span class="number">1</span>) % P</span><br><span class="line">        * (l * <span class="number">2</span> - <span class="number">1</span>) % P * INV % P) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p = <span class="built_in">query</span>(<span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">calc</span>(p.first, k, r - l + <span class="number">1</span>) == p.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">rd</span>() ^ cnt, y = <span class="built_in">rd</span>() ^ cnt;</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>, x, y);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="built_in">rd</span>() ^ cnt, r = <span class="built_in">rd</span>() ^ cnt, k = <span class="built_in">rd</span>() ^ cnt;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">solve</span>(l, r, k)) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> kai586123::<span class="built_in">main</span>(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>由于WordPress的Bug，近期代码都乱码了</title>
    <url>/2019/09/22/%E7%94%B1%E4%BA%8Ewordpress%E7%9A%84bug%EF%BC%8C%E8%BF%91%E6%9C%9F%E4%BB%A3%E7%A0%81%E9%83%BD%E4%B9%B1%E7%A0%81%E4%BA%86/</url>
    <content><![CDATA[<p>如题。 不过相信不影响阅读OwO</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>行列式 | 矩阵树定理 学习笔记</title>
    <url>/2019/07/26/%E8%A1%8C%E5%88%97%E5%BC%8F-%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h3><p>举个例子： $$\det(A) = \begin{vmatrix} A \end{vmatrix} = \begin{vmatrix} 1 &amp; 1 &amp; 4\ 5 &amp; 1 &amp; 4\ \end{vmatrix}$$ 定义$S_n$为全排列集合，若$\sigma$逆序对数量为$t$，${\rm sgn}(\sigma)=(-1)^t$ $$\det(A) = \sum_{\sigma \in S_n} {\rm sgn}(\sigma) \prod_{i=1}^n a_{i,\sigma(i)}$$</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul>
<li>$\det(A)=\det(A^T)$</li>
<li>交换两行，取相反数</li>
</ul>
<h5 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h5><p>逆序对变化数为奇数。</p>
<ul>
<li>  某一行$\times k$，行列式$\times k$</li>
</ul>
<h5 id="推论："><a href="#推论：" class="headerlink" title="推论："></a>推论：</h5><p>两行相等，或成比例，行列式为$0$</p>
<ul>
<li>  两个行列式只有一行不同，它们行列式和等于不同的行相加，其它行不变的行列式</li>
</ul>
<h5 id="证明：-1"><a href="#证明：-1" class="headerlink" title="证明："></a>证明：</h5><p>对定义式用乘法分配率</p>
<h5 id="推论：-1"><a href="#推论：-1" class="headerlink" title="推论："></a>推论：</h5><p>行列式一行$\times k$，加在另一行上，行列式的值不变。</p>
<h4 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h4><p>由最后一条性质，我们可以把一个行列式变为上三角的形式。 $$\det(A) =k \det(A’)=k\prod_{i=1}^nA’_{i,i}$$ 其中，$k = 1 \ or -1$，是高斯消元的时候交换行时候维护的。</p>
<h3 id="矩阵树定理"><a href="#矩阵树定理" class="headerlink" title="矩阵树定理"></a>矩阵树定理</h3><h4 id="几个矩阵"><a href="#几个矩阵" class="headerlink" title="几个矩阵"></a>几个矩阵</h4><h5 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h5><p>$A$，没什么好说的。</p>
<h5 id="度数矩阵"><a href="#度数矩阵" class="headerlink" title="度数矩阵"></a>度数矩阵</h5><p>$D$，$D_{i,i}=\deg(v_i)$，$D_{i,j}=0$。 $deg$是度数。</p>
<h5 id="Laplacian矩阵"><a href="#Laplacian矩阵" class="headerlink" title="Laplacian矩阵"></a>Laplacian矩阵</h5><p>拉普拉斯矩阵$L$。 $$L=D-A$$</p>
<h4 id="生成树个数"><a href="#生成树个数" class="headerlink" title="生成树个数"></a>生成树个数</h4><p>把$L$去掉任意一行一列，求剩下的矩阵的行列式的绝对值，即为生成树个数。 证明很复杂，不会证。</p>
<h3 id="矩阵树定理Plus"><a href="#矩阵树定理Plus" class="headerlink" title="矩阵树定理Plus"></a>矩阵树定理Plus</h3><h4 id="变元矩阵树定理"><a href="#变元矩阵树定理" class="headerlink" title="变元矩阵树定理"></a>变元矩阵树定理</h4><p>我们来具体考虑一下上面式子求出来的是什么。 经过大力看博客背结论，我们知道了，实际上上式求的是： $$\sum_{T} \prod_{e \in T} e$$ $T$是生成树，$e$是里面的边。</p>
<h4 id="有向图的矩阵树定理"><a href="#有向图的矩阵树定理" class="headerlink" title="有向图的矩阵树定理"></a>有向图的矩阵树定理</h4><p>可以单独计算外向，内向树形图的个数。 修改度数矩阵，外向只保留外向边，内向只保留内向边。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>被虐垫底测试（3）</title>
    <url>/2019/08/03/%E8%A2%AB%E8%99%90%E5%9E%AB%E5%BA%95%E6%B5%8B%E8%AF%95%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<p>题在洛谷有。</p>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p><a href="https://www.luogu.org/problem/P3938">斐波那契</a> 每个点的父亲，都是它减去斐波那契数列里比它小的那一项。 这样就可以随便做了。</p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p><a href="https://www.luogu.org/problem/P3939">数颜色</a> 所以为什么全场就两个人过了。。。。。。 数据结构学傻做法：主席树 数据结构没学傻做法：发现是查一种颜色，开vector存下标二分。</p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p><a href="https://www.luogu.org/problem/P3940">分组</a> 字典序最小-&gt;分的位置靠前-&gt;从后往前做。 $K=1$时，开一个$vis[]$，每次查到新数枚举一个$k$，使得$k * k - val &lt; N$，查询这个有没有$vis$过。 $K=2$时部分分算法： 考虑一下如何判定一堆数字可否分成两组。把不能放在一组的连边，二分图染色。 每一段的长度显然是有单调性的，二分一下判断，能拿$70$多分。 $K=2$时算法： 显然当新加入一个数，使得图中存在三元环的时候，必须要新分组了。 类似关押罪犯，用并查集维护点之间的关系。然后有两种做法： 第一种是std。在值域上建并查集。如果没有重复的值，正好可以做。如果有重复的值$x$，只有$2x$是一个完全平方数的时候，才会产生影响。这时候，必须把它们放在两组。可以把它们放在两组的条件，是没有任何一个值和它的和是完全平方数。 另一种好写一些，是在位置上建并查集，用vector维护每种值出现的下标，判断的时候枚举下标。这种做法不需要讨论重复的数，但是慢一些。 强行手写vector的第二种做法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">131072</span> * <span class="number">2</span> + <span class="number">2333</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, K, w[N], val[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SubTask1 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n, lst = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">bool</span> clear = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k * k - val[i] &lt; N; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k * k - val[i] &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (vis[k * k - val[i]]) &#123;</span><br><span class="line">                    clear = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (clear) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= lst; ++j)</span><br><span class="line">                    vis[val[j]] = <span class="number">0</span>;</span><br><span class="line">                w[++m] = lst = i;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[val[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], v[N * <span class="number">10</span>], nxt[N * <span class="number">10</span>], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    v[++tot] = y; nxt[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    head[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SubTask2 &#123;</span><br><span class="line">    <span class="keyword">int</span> fa[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">find</span>(fa[x]); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x != y) fa[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; ++i)</span><br><span class="line">            fa[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n, ok = <span class="number">1</span>; i; --i, ok = <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k * k - val[i] &lt; N; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k * k - val[i] &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (vis[k * k - val[i]] == m + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> ttt = head[k * k - val[i]]; ttt; ttt = nxt[ttt]) &#123;</span><br><span class="line">                        <span class="keyword">int</span> x = v[ttt];</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">find</span>(i) == <span class="built_in">find</span>(x)) &#123;</span><br><span class="line">                            ok = <span class="number">0</span>; <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="built_in">unite</span>(i, x + n), <span class="built_in">unite</span>(i + n, x);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!ok) w[++m] = i;</span><br><span class="line">            <span class="keyword">if</span> (vis[val[i]] != m + <span class="number">1</span>) &#123;</span><br><span class="line">                vis[val[i]] = m + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">clear</span>(val[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">push_back</span>(val[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(), K = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        val[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">if</span> (K == <span class="number">1</span>) SubTask1::<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">else</span> SubTask2::<span class="built_in">solve</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, w[m - i + <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>联考2020 B卷 丁香之路 欧拉回路</title>
    <url>/2020/06/24/%E8%81%94%E8%80%832020-b%E5%8D%B7-%E4%B8%81%E9%A6%99%E4%B9%8B%E8%B7%AF-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6628">丁香之路</a> 假装已经知道了要走哪些边，可以发现答案就确定了。那么问题就是确定走哪些边。首先输入的肯定要走，并且还要再加一些，使得可以形成欧拉路。 欧拉路不好处理，就从T到S连一条边变成欧拉回路。欧拉回路需要满足两个条件：度数是偶数，联通。 从小往大扫，如果两个点的度数都是奇数，就让它们连一条边。之后图中剩下了若干联通块。考虑连接它们。可以发现一定向最近的点连边比较优秀，于是只有$O(n)$条有用的边。贪心的把联通块连起来。 然后就发现自己过不了… 去loj orz了一下AC代码，发现了问题：把两个奇数连起来这条边不一定有用。确实我们要走回来，但是不一定走这条边。 于是可以把连一条边改成把中间所有点串成一条链。这样是正确的，因为中间的点左右各加一条边，奇偶性不变。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cerr;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2600</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, sum, ins[N];</span><br><span class="line"><span class="keyword">int</span> deg[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> x, y; &#125;;</span><br><span class="line">std::vector&lt;Edge&gt; E[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N], Fa[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  deg[s] ^= <span class="number">1</span>, deg[t] ^= <span class="number">1</span>;</span><br><span class="line">  ++ins[s], ++ins[t];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    fa[i] = Fa[i];</span><br><span class="line">    E[i].<span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ret = sum;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(deg[i] &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (!j) j = i;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; i; ++k) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">find</span>(k), y = <span class="built_in">find</span>(k + <span class="number">1</span>);</span><br><span class="line">        fa[x] = y;</span><br><span class="line">      &#125;</span><br><span class="line">      ret += i - j, j = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ins[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (j &lt;= i) j = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= n &amp;&amp; (!ins[j]  <span class="built_in">find</span>(j) == <span class="built_in">find</span>(i)))</span><br><span class="line">      ++j;</span><br><span class="line">    <span class="keyword">if</span> (j &lt;= n) E[j - i].<span class="built_in">push_back</span>(&#123; i, j &#125;);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : E[i]) &#123;</span><br><span class="line">      <span class="keyword">int</span> x = <span class="built_in">find</span>(e.x), y = <span class="built_in">find</span>(e.y);</span><br><span class="line">      <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">        fa[x] = y, ret += <span class="number">2</span> * i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  deg[s] ^= <span class="number">1</span>, deg[t] ^= <span class="number">1</span>;</span><br><span class="line">  --ins[s], --ins[t];</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>(), s = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    fa[i] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">    sum += std::<span class="built_in">abs</span>(x - y);</span><br><span class="line">    deg[x] ^= <span class="number">1</span>, deg[y] ^= <span class="number">1</span>;</span><br><span class="line">    ++ins[x], ++ins[y];</span><br><span class="line">    x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (x != y) fa[x] = y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    Fa[i] = fa[i];</span><br><span class="line">  <span class="keyword">for</span> (t = <span class="number">1</span>; t &lt;= n; ++t)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">solve</span>());</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>火柴排队</title>
    <url>/2019/02/17/%E7%81%AB%E6%9F%B4%E6%8E%92%E9%98%9F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1966">火柴排队</a> noip的小水题，手玩一下就出来了，虽然证明有点麻烦…（某犇：OI没有证明 显然，只动第一行，只动第二行都可以且答案一样。本题要求两行分别冒泡排序后，得到的距离最小的交换次数。即逆序对。 本题中可以将两行都排序后计算距离，求得最小值。 证明：将第一行记为$a$，第二行记为$b$并排序。若最优方案中$a$排列为$a_{p1},a_{p2},…,a_{pn}$，则有 $\sum_{i=1}^{n}(a_{pi}-b_{i})^2\newline =\sum_{i=1}^{n}(a_{pi}^2+b_{i}^2-2a_{pi}b_i)\newline =\sum_{i=1}^{n}a_{pi}^2+\sum_{i=1}^{n}b_{i}^2-2\sum_{i=1}^{n}a_{pi}b_i$ 显然要令和最小，$\sum_{i=1}^{n}a_{pi}b_i$最大。由<a href="https://en.wikipedia.org/wiki/Rearrangement_inequality">排序不等式</a>可知，给$a$也排序，和最大。 因此，我们只需要把两行排序，得到不移动其中一行下另一行应该去的位置，求逆序对即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">0</span>;<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))a=c==<span class="string">&#x27;-&#x27;</span>?<span class="number">0</span>:<span class="number">1</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))b=b*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a?b:-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">2333</span>;</span><br><span class="line"><span class="keyword">int</span> n,c[N],d[N],ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id,v;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;node)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v&lt;node.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">mergesort</span>(l,mid),<span class="built_in">mergesort</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">int</span> i=l,j=mid+<span class="number">1</span>,k=l;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i]&gt;c[j])(ans+=mid-i+<span class="number">1</span>)%=<span class="number">99999997</span>,d[k++]=c[j++];</span><br><span class="line">        <span class="keyword">else</span> d[k++]=c[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)d[k++]=c[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r)d[k++]=c[j++];</span><br><span class="line">    <span class="keyword">for</span>(i=l;i&lt;=r;++i)c[i]=d[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)a[i].id=i,a[i].v=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)b[i].id=i,b[i].v=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>),<span class="built_in">sort</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)c[a[i].id]=b[i].id;</span><br><span class="line">    <span class="built_in">mergesort</span>(<span class="number">1</span>,n);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>被虐垫底测试（1）</title>
    <url>/2019/07/29/%E8%A2%AB%E8%99%90%E5%9E%AB%E5%BA%95%E6%B5%8B%E8%AF%95%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://baka.online/wp-content/uploads/2019/07/problem.pdf">考试题点这里</a> 上午去了学车机房看了眼衡中OJ，发现有考试，看了看题。 T1模拟题，不写了，T2口胡一个，T3口胡一个。写了半小时。 期望得分：200 实际得分：70 emmmmmmm</p>
<hr>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>水题，没写，不说了</p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>第一眼dsu on tree，第二眼按时间顺序排序的可并堆，第三眼发现可并堆不可做，改成动态开点线段树，第四眼线段树上二分查询。 做完了。 代码改了好久好久</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125; g[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    g[++tot].to = y, g[tot].nxt = head[x],</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N], son[N], size[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    size[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="keyword">if</span> (y != fa[x]) &#123;</span><br><span class="line">            fa[y] = x;</span><br><span class="line">            <span class="built_in">dfs1</span>(y);</span><br><span class="line">            size[x] += size[y];</span><br><span class="line">            <span class="keyword">if</span> (size[son[x]] &lt; size[y])</span><br><span class="line">                son[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lim[N];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; op[N], qu[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> ls[N * <span class="number">180</span>], rs[N * <span class="number">180</span>], val[N * <span class="number">180</span>], sz[N * <span class="number">180</span>], root[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> last[N], stk[N * <span class="number">100</span>], top;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> color[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rbin[N * <span class="number">180</span>], rbin_top;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> qaq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">new_mem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num + <span class="number">1</span> &lt; N * <span class="number">180</span>)</span><br><span class="line">        <span class="keyword">return</span> ++num;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> rbin[rbin_top--];</span><br><span class="line">    <span class="keyword">return</span> ++num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    rbin[++rbin_top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">0</span>) last[stk[top--]] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    sz[p] = sz[ls[p]] + sz[rs[p]];</span><br><span class="line">    val[p] = val[ls[p]] + val[rs[p]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p) p = <span class="built_in">new_mem</span>();</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        sz[p] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (y != <span class="number">-1</span>)</span><br><span class="line">            val[p] = y;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">        <span class="built_in">change</span>(ls[p], x, y, L, mid);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">change</span>(rs[p], x, y, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> &amp;rt)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (last[color[L]] &gt; L) &#123;</span><br><span class="line">            <span class="built_in">change</span>(rt, last[color[L]], <span class="number">0</span>, <span class="number">1</span>, m);</span><br><span class="line">            <span class="built_in">change</span>(rt, L, <span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line">            last[color[L]] = L;</span><br><span class="line"></span><br><span class="line">            stk[++top] = color[L];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (last[color[L]] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">change</span>(rt, L, <span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line">            last[color[L]] = L;</span><br><span class="line"></span><br><span class="line">            stk[++top] = color[L];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">change</span>(rt, L, <span class="number">-1</span>, <span class="number">1</span>, m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">del</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge</span>(ls[p], L, mid, rt);</span><br><span class="line">    <span class="built_in">merge</span>(rs[p], mid + <span class="number">1</span>, R, rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> lim, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!lim) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sz[p] &lt;= lim)</span><br><span class="line">        <span class="keyword">return</span> val[p];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sz[ls[p]] &lt;= lim) &#123;</span><br><span class="line">        ret += val[ls[p]];</span><br><span class="line">        ret += <span class="built_in">query</span>(rs[p], lim - sz[ls[p]], mid + <span class="number">1</span>, R);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret += <span class="built_in">query</span>(ls[p], lim, L, mid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="keyword">if</span> (y != fa[x] &amp;&amp; y != son[x]) &#123;</span><br><span class="line">            <span class="built_in">solve</span>(y);</span><br><span class="line">            <span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (son[x])</span><br><span class="line">        <span class="built_in">solve</span>(son[x]);</span><br><span class="line">    root[x] = root[son[x]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; op[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> co = color[op[x][i]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (last[co] &gt; op[x][i]) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">change</span>(root[x], last[co], <span class="number">0</span>, <span class="number">1</span>, m);</span><br><span class="line">            <span class="built_in">change</span>(root[x], op[x][i], <span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line"></span><br><span class="line">            last[co] = op[x][i];</span><br><span class="line"></span><br><span class="line">            stk[++top] = co;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (last[co] == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">change</span>(root[x], op[x][i], <span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line"></span><br><span class="line">            last[co] = op[x][i];</span><br><span class="line"></span><br><span class="line">            stk[++top] = co;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">change</span>(root[x], op[x][i], <span class="number">-1</span>, <span class="number">1</span>, m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="keyword">if</span> (y != fa[x] &amp;&amp; y != son[x]) &#123;</span><br><span class="line">            <span class="built_in">merge</span>(root[y], <span class="number">1</span>, m, root[x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> baka = <span class="built_in">query</span>(root[x], lim[x], <span class="number">1</span>, m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qu[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        ans[qu[x][i]] = baka;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lisan[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">addedge</span>(x, y);</span><br><span class="line">        <span class="built_in">addedge</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        lim[i] = <span class="built_in">rd</span>();</span><br><span class="line"></span><br><span class="line">    m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">        lisan[i] = color[i] = y;</span><br><span class="line">        op[x].<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(lisan + <span class="number">1</span>, lisan + m + <span class="number">1</span>);</span><br><span class="line">    tt = std::<span class="built_in">unique</span>(lisan + <span class="number">1</span>, lisan + m + <span class="number">1</span>) - lisan - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        color[i] = std::<span class="built_in">lower_bound</span>(lisan + <span class="number">1</span>, lisan + tt + <span class="number">1</span>, color[i]) - lisan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        qu[<span class="built_in">rd</span>()].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>首先多个区间，但是是独立的。求一个区间的答案乘上区间数就行了。 每个区间内，枚举一下最大数$i$，那么最大数为$i$的方案数为$i^k-(i-1)^k$。 答案是 $$\frac{\sum_{i=1}^m w_i(i^k-(i-1)^k)}{m^k}(n-k+1)$$ 然后挂了好多分…注意答案是正数。。然后特判一下无解。。。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>被虐垫底测试（5）</title>
    <url>/2019/08/13/%E8%A2%AB%E8%99%90%E5%9E%AB%E5%BA%95%E6%B5%8B%E8%AF%95%EF%BC%885%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://baka.online/wp-content/uploads/2019/08/NOIP%E6%A8%A1%E6%8B%9F%E9%A2%981.pdf">题在这里</a></p>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>枚举答案，考虑一个贪心，度数为$1$的点必须选。这样向上删点，如果某个点删去子树中所有选择的联通块后大小正好为枚举的大小，它也可以。 精简这个过程，每个点如果大小为答案倍数，就可以划分出一块。</p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>二分答案。定义一个“跳”的动作。跳一次，就是向前走一些距离，直到走到某个点，使得这一段的和大于答案。 倍增处理跳的过程，然后枚举起点，跳$m$次，如果跳够了一圈，那么就是可行的。</p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>被假数据坑了。。 考虑一条边$x \to y$，其中$val_y=1$。那么，我们可以把$x$连向所有$y$的出边，跳过$y$。这样就解决了题目中对于不同路径的限制。 求出最短路图，在图上用bitset维护每个点连出的点。DFS维护bitset。发现如果有两个点，权值都为$1$，它们之间形成了一个$0$环，只用一次DFS是不够的。事实上需要三次DFS。 最后在这个图上DP统计答案就可以了。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>被虐垫底测试（6）</title>
    <url>/2019/08/14/%E8%A2%AB%E8%99%90%E5%9E%AB%E5%BA%95%E6%B5%8B%E8%AF%95%EF%BC%886%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://baka.online/wp-content/uploads/2019/08/NOIP%E6%A8%A1%E6%8B%9F%E9%A2%9823.pdf">题在这里</a></p>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>模拟题，记录所有要操作的点，每次对折的时候把他们都折了，同时更新一下左右端点。</p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>$$L \leq xS {\ \rm mod\ } M \leq R$$ 考虑可以直接解出解的情况。 $$xS {\ \rm mod\ } M = x(S{\ \rm mod\ } M ){\ \rm mod\ } M $$ 把$S {\ \rm mod\ } M$，如果此时的$x &lt; M$，直接得解。 $$L \leq xS-kM \leq R$$ $$-R+xS \leq kM \leq -L + xS$$ $$-R {\ \rm mod\ } S \leq kM {\ \rm mod\ } S \leq -L {\ \rm mod\ } S$$ 发现这个式子和要求的长得一样。递归求解，因为每次都涉及到一个$S {\ \rm mod\ } M$的操作，$O(logn)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> S, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= M  L &gt; R) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (S % M == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    S %= M; <span class="keyword">int</span> tmp = L % S == <span class="number">0</span> ? L / S : L / S + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tmp * S &lt;= R) <span class="keyword">return</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="built_in">solve</span>(S, M, (-R % S + S) % S, (-L % S + S) % S);</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">-1</span>) <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">int</span> x = (L + k * M) % S == <span class="number">0</span> ? (L + k * M) / S : (L + k * M) / S + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// std::cerr &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// std::cerr &lt;&lt; M &lt;&lt; &quot; &quot; &lt;&lt; S &lt;&lt; &quot; &quot; &lt;&lt; L &lt;&lt; &quot; &quot; &lt;&lt; R &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">if</span> (S * x - k * M &lt;= R) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; std::cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> M, S, L, R; std::cin &gt;&gt; M &gt;&gt; S &gt;&gt; L &gt;&gt; R;</span><br><span class="line">        <span class="comment">// printf(&quot;%lld\n&quot;, solve(M, S, L, R));</span></span><br><span class="line">        R = std::<span class="built_in">min</span>(R, M - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">solve</span>(M, S, L, R));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>不可做的数位DP。 分别求出$[1,R],[1,L-1]$反转后在$[L,R]$的答案就好了。 枚举从第几位开始搜，令$f_{pos,dig,x1,x2}$表示从$pos$位开始搜，已经走过的长度是$dig$，$x1,x2$分别表示前$dig$位反转后和$L,R$比较大小的结果。（实际上$f$可以删一维。。） $$f_{pos,dig,x1,x2}=\sum_{i=0}^{lim}f_{pos-1,dig+1,nx1,nx2}$$ 这个$nx1,nx2$，表示已经有的前缀加上$i$，和已有的$L,R$后缀加上它们对应位置新的一位，比大小的结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> uLL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dkynoipafo</span><span class="params">(uLL x, <span class="keyword">int</span> dig[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; x; x /= <span class="number">10</span>)</span><br><span class="line">        dig[++dig[<span class="number">0</span>]] = x % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cwyakioi</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> lst = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y ? <span class="number">0</span> : x &gt; y ? <span class="number">2</span> : lst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">int</span> sp1[N], sp2[N], sp3[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N][N][<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">uLL f[N][N][<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">uLL <span class="title">gmkakioi</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> dig, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">bool</span> lim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!lim &amp;&amp; vis[pos][dig][x1][x2])</span><br><span class="line">        <span class="keyword">return</span> f[pos][dig][x1][x2];</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dig &lt; sp1[<span class="number">0</span>]) x1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (dig &lt; sp2[<span class="number">0</span>]) x2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> x1 != <span class="number">0</span> &amp;&amp; x2 != <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    uLL gmk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, up = lim ? sp3[pos - <span class="number">1</span>] : <span class="number">9</span>; i &lt;= up; ++i)</span><br><span class="line">        gmk += <span class="built_in">gmkakioi</span>(pos - <span class="number">1</span>, dig + <span class="number">1</span>, <span class="built_in">cwyakioi</span>(i, sp1[dig + <span class="number">1</span>], x1), <span class="built_in">cwyakioi</span>(i, sp2[dig + <span class="number">1</span>], x2), lim &amp;&amp; (i == up));</span><br><span class="line">    <span class="keyword">if</span> (!lim) vis[pos][dig][x1][x2] = <span class="number">1</span>, f[pos][dig][x1][x2] = gmk;</span><br><span class="line">    <span class="keyword">return</span> gmk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uLL <span class="title">tkjakioi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    uLL tkj = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sp3[<span class="number">0</span>]; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, lim = (i == sp3[<span class="number">0</span>] ? sp3[i] : <span class="number">9</span>); j &lt;= lim; ++j)</span><br><span class="line">            tkj += <span class="built_in">gmkakioi</span>(i, <span class="number">1</span>, <span class="built_in">cwyakioi</span>(j, sp1[<span class="number">1</span>]), <span class="built_in">cwyakioi</span>(j, sp2[<span class="number">1</span>]), i == sp3[<span class="number">0</span>] &amp;&amp; j == lim);</span><br><span class="line">    <span class="keyword">return</span> tkj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uLL <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        sp1[i] = sp2[i] = sp3[i] = <span class="number">0</span>;</span><br><span class="line">    uLL L, R, ans = <span class="number">0</span>; std::cin &gt;&gt; L &gt;&gt; R;</span><br><span class="line">    <span class="built_in">dkynoipafo</span>(L, sp1); <span class="built_in">dkynoipafo</span>(R, sp2); <span class="built_in">dkynoipafo</span>(R, sp3);</span><br><span class="line">    ans += <span class="built_in">tkjakioi</span>();</span><br><span class="line">    <span class="keyword">if</span> (L &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        sp3[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dkynoipafo</span>(L - <span class="number">1</span>, sp3);</span><br><span class="line">        ans -= <span class="built_in">tkjakioi</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, a, b; std::cin &gt;&gt; T &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">while</span> (T--) std::cout &lt;&lt; <span class="built_in">solve</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>被虐垫底测试（7）</title>
    <url>/2019/08/16/%E8%A2%AB%E8%99%90%E5%9E%AB%E5%BA%95%E6%B5%8B%E8%AF%95%EF%BC%887%EF%BC%89/</url>
    <content><![CDATA[<p>先咕咕了，改完再来填。</p>
<h2 id="Update-19-10-6："><a href="#Update-19-10-6：" class="headerlink" title="Update 19.10.6："></a>Update 19.10.6：</h2><h1 id="我-事-鸽-王"><a href="#我-事-鸽-王" class="headerlink" title="我 事 鸽 王"></a>我 事 鸽 王</h1>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>被虐垫底测试（8）</title>
    <url>/2019/08/16/%E8%A2%AB%E8%99%90%E5%9E%AB%E5%BA%95%E6%B5%8B%E8%AF%95%EF%BC%888%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://baka.online/wp-content/uploads/2019/08/problem-1.pdf">在？看看题？</a> 因为T1写的太蠢，代码太长，倒着写。</p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>NOIP题里的莫比乌斯反演。。。 定义$A(x),B(x),C(x)$，分别表示$gcd$为$x$的对数，$gcd$为$x$的倍数的对数，为$x$倍数的数的个数。 $$B(x)=\frac{C(x)(C(x)-1)}{2}$$ $C$可以通过枚举约数直接维护。 $$B(n)=\sum_{n \mid d} A(d)$$ 这是个莫比乌斯反演的板子。 $$A(n)=\sum_{n \mid d}\mu(\frac{d}{n})B(d)$$ 答案就是$A(1)$ $$A(1)=\sum_{d=1}\mu(d)B(d)$$ 就可以做了。$O(n\sqrt n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">233</span>, M = <span class="number">5e5</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, val[N], prime[M], mu[M], tot, vis[M], cond[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[M], g[M], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;gcd.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) prime[++tot] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt; M; ++j) &#123;</span><br><span class="line">            vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i * prime[j]] = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        val[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="built_in">rd</span>(); cond[opt] ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cond[opt] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= val[opt]; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (val[opt] % i == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans -= mu[i] * g[i];</span><br><span class="line">                    ++f[i]; g[i] = f[i] * (f[i] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                    ans += mu[i] * g[i];</span><br><span class="line">                    <span class="keyword">if</span> (i * i != val[opt]) &#123;</span><br><span class="line">                        <span class="keyword">int</span> j = val[opt] / i;</span><br><span class="line">                        ans -= mu[j] * g[j];</span><br><span class="line">                        ++f[j]; g[j] = f[j] * (f[j] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                        ans += mu[j] * g[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= val[opt]; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (val[opt] % i == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans -= mu[i] * g[i];</span><br><span class="line">                    --f[i]; g[i] = f[i] * (f[i] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                    ans += mu[i] * g[i];</span><br><span class="line">                    <span class="keyword">if</span> (i * i != val[opt]) &#123;</span><br><span class="line">                        <span class="keyword">int</span> j = val[opt] / i;</span><br><span class="line">                        ans -= mu[j] * g[j];</span><br><span class="line">                        --f[j]; g[j] = f[j] * (f[j] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                        ans += mu[j] * g[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>传说中的FloodFill算法。 具体来说，就是把一块水池看作一个桶，那么水位肯定是桶边上最低的木条的长度。用优先队列BFS，每次取出来的是水位最低的位置，这样就可以保证进入每个桶的时候都是用的最小值，就对了。 这个算法看起来有点玄学。。还有个强大的算法，就是每个点的水位高度，都是它到边界的所有路径上选最大的点，再取一个最小值。这是个最小生成树的形式，做一下就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>, dx[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;, dy[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ht[N][N], qaq[N][N], vis[N][N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, h;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.h &gt; b.h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::priority_queue&lt;Node&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;water.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            qaq[i][j] = ht[i][j] = <span class="built_in">rd</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        que.<span class="built_in">push</span>(&#123; i, <span class="number">0</span>, <span class="number">0</span> &#125;);</span><br><span class="line">        que.<span class="built_in">push</span>(&#123; i, m + <span class="number">1</span>, <span class="number">0</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        que.<span class="built_in">push</span>(&#123; <span class="number">0</span>, i, <span class="number">0</span> &#125;);</span><br><span class="line">        que.<span class="built_in">push</span>(&#123; n + <span class="number">1</span>, i, <span class="number">0</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node node = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = node.x + dx[i], ny = node.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (nx &lt; <span class="number">1</span>  nx &gt; n  ny &lt; <span class="number">1</span>  ny &gt; m  vis[nx][ny])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            vis[nx][ny] = <span class="number">1</span>;</span><br><span class="line">            qaq[nx][ny] = std::<span class="built_in">max</span>(qaq[nx][ny], node.h);</span><br><span class="line">            que.<span class="built_in">push</span>(&#123; nx, ny, qaq[nx][ny] &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i, <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, qaq[i][j] - ht[i][j]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>我写了一种非常蠢的做法。。。$f_{i,j,k}$表示位置$i$状态为$j$，位置$i-1$的为$k$的方案数。大力枚举就行了。 直接放代码。。。。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">233</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n, ans, f[N][<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Sub1 &#123;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[<span class="number">2</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; str[<span class="number">2</span>] != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;2&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; str[<span class="number">2</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (str[n] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[n - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (str[n] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; str[n - <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (str[n] == <span class="string">&#x27;2&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (str[n] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; str[n - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>  str[i + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((str[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) + (str[i + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) != <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((str[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) + (str[i + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) != <span class="number">2</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> pick)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == n + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// if (check()) &#123;</span></span><br><span class="line">                <span class="comment">// std::cout &lt;&lt; (str + 1) &lt;&lt; std::endl;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">return</span> pick &amp;&amp; <span class="built_in">check</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str[x] != <span class="string">&#x27;?&#x27;</span>) <span class="keyword">return</span> <span class="built_in">dfs</span>(x + <span class="number">1</span>, pick);</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        str[x] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ret += <span class="built_in">dfs</span>(x + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        str[x] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        ret += <span class="built_in">dfs</span>(x + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        str[x] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        ret += <span class="built_in">dfs</span>(x + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        str[x] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        ret += <span class="built_in">dfs</span>(x + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        str[x] = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Sub3 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">2</span>] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) f[<span class="number">2</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>) f[<span class="number">2</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">2</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) f[<span class="number">2</span>][<span class="number">1</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) f[<span class="number">2</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>) f[<span class="number">2</span>][<span class="number">1</span>][<span class="number">0</span>] = f[<span class="number">2</span>][<span class="number">1</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">2</span>] == <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) f[<span class="number">2</span>][<span class="number">2</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>) f[<span class="number">2</span>][<span class="number">2</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">2</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) f[<span class="number">2</span>][<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) f[<span class="number">2</span>][<span class="number">3</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>) f[<span class="number">2</span>][<span class="number">3</span>][<span class="number">1</span>] = f[<span class="number">2</span>][<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">2</span>] == <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>  str[<span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>) f[<span class="number">2</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>  str[<span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>) f[<span class="number">2</span>][<span class="number">1</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>  str[<span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>) f[<span class="number">2</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>  str[<span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>) f[<span class="number">2</span>][<span class="number">2</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>  str[<span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>) f[<span class="number">2</span>][<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>  str[<span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>) f[<span class="number">2</span>][<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = str[i] == <span class="string">&#x27;0&#x27;</span>, b = str[i] == <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">                c = str[i] == <span class="string">&#x27;2&#x27;</span>, d = str[i] == <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;?&#x27;</span>) a = b = c = d = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (a) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] != <span class="number">-1</span>)</span><br><span class="line">                    f[i][<span class="number">0</span>][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] != <span class="number">-1</span>)</span><br><span class="line">                    f[i][<span class="number">0</span>][<span class="number">0</span>] = (std::<span class="built_in">max</span>(f[i][<span class="number">0</span>][<span class="number">0</span>], <span class="number">0</span>) + f[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]) % P;</span><br><span class="line">                <span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">3</span>] != <span class="number">-1</span>)</span><br><span class="line">                    f[i][<span class="number">0</span>][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] != <span class="number">-1</span>)</span><br><span class="line">                    f[i][<span class="number">1</span>][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] != <span class="number">-1</span>)</span><br><span class="line">                    f[i][<span class="number">1</span>][<span class="number">0</span>] = (std::<span class="built_in">max</span>(f[i][<span class="number">1</span>][<span class="number">0</span>], <span class="number">0</span>) + f[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]) % P;</span><br><span class="line">                <span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">3</span>] != <span class="number">-1</span>)</span><br><span class="line">                    f[i][<span class="number">1</span>][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">                <span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">3</span>][<span class="number">1</span>] != <span class="number">-1</span>)</span><br><span class="line">                    f[i][<span class="number">1</span>][<span class="number">3</span>] = f[i - <span class="number">1</span>][<span class="number">3</span>][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">3</span>][<span class="number">2</span>] != <span class="number">-1</span>)</span><br><span class="line">                    f[i][<span class="number">1</span>][<span class="number">3</span>] = (std::<span class="built_in">max</span>(f[i][<span class="number">1</span>][<span class="number">3</span>], <span class="number">0</span>) + f[i - <span class="number">1</span>][<span class="number">3</span>][<span class="number">2</span>]) % P;</span><br><span class="line">                <span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">3</span>][<span class="number">3</span>] != <span class="number">-1</span>)</span><br><span class="line">                    f[i][<span class="number">1</span>][<span class="number">3</span>] = (std::<span class="built_in">max</span>(f[i][<span class="number">1</span>][<span class="number">3</span>], <span class="number">0</span>) + f[i - <span class="number">1</span>][<span class="number">3</span>][<span class="number">3</span>]) % P;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">3</span>][<span class="number">1</span>] != <span class="number">-1</span>)</span><br><span class="line">                    f[i][<span class="number">2</span>][<span class="number">3</span>] = f[i - <span class="number">1</span>][<span class="number">3</span>][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">3</span>][<span class="number">2</span>] != <span class="number">-1</span>)</span><br><span class="line">                    f[i][<span class="number">2</span>][<span class="number">3</span>] = (std::<span class="built_in">max</span>(f[i][<span class="number">2</span>][<span class="number">3</span>], <span class="number">0</span>) + f[i - <span class="number">1</span>][<span class="number">3</span>][<span class="number">2</span>]) % P;</span><br><span class="line">                <span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">3</span>][<span class="number">3</span>] != <span class="number">-1</span>)</span><br><span class="line">                    f[i][<span class="number">2</span>][<span class="number">3</span>] = (std::<span class="built_in">max</span>(f[i][<span class="number">2</span>][<span class="number">3</span>], <span class="number">0</span>) + f[i - <span class="number">1</span>][<span class="number">3</span>][<span class="number">3</span>]) % P;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (d) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] != <span class="number">-1</span>)</span><br><span class="line">                    f[i][<span class="number">3</span>][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] != <span class="number">-1</span>)</span><br><span class="line">                    f[i][<span class="number">3</span>][<span class="number">1</span>] = (std::<span class="built_in">max</span>(f[i][<span class="number">3</span>][<span class="number">1</span>], <span class="number">0</span>) + f[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]) % P;</span><br><span class="line">                <span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>] != <span class="number">-1</span>)</span><br><span class="line">                    f[i][<span class="number">3</span>][<span class="number">2</span>] = f[i - <span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">                <span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">3</span>][<span class="number">1</span>] != <span class="number">-1</span>)</span><br><span class="line">                    f[i][<span class="number">3</span>][<span class="number">3</span>] = f[i - <span class="number">1</span>][<span class="number">3</span>][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">3</span>][<span class="number">2</span>] != <span class="number">-1</span>)</span><br><span class="line">                    f[i][<span class="number">3</span>][<span class="number">3</span>] = (std::<span class="built_in">max</span>(f[i][<span class="number">3</span>][<span class="number">3</span>], <span class="number">0</span>) + f[i - <span class="number">1</span>][<span class="number">3</span>][<span class="number">2</span>]) % P;</span><br><span class="line">                <span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">3</span>][<span class="number">3</span>] != <span class="number">-1</span>)</span><br><span class="line">                    f[i][<span class="number">3</span>][<span class="number">3</span>] = (std::<span class="built_in">max</span>(f[i][<span class="number">3</span>][<span class="number">3</span>], <span class="number">0</span>) + f[i - <span class="number">1</span>][<span class="number">3</span>][<span class="number">3</span>]) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;---3---&quot; &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; 4; ++i)</span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt; 4; ++j)</span></span><br><span class="line">        <span class="comment">//         printf(&quot;%d %d %d\n&quot;, i, j, f[3][i][j]);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;---4---&quot; &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; 4; ++i)</span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt; 4; ++j)</span></span><br><span class="line">        <span class="comment">//         printf(&quot;%d %d %d\n&quot;, i, j, f[4][i][j]);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f[n][<span class="number">0</span>][<span class="number">0</span>] != <span class="number">-1</span>)</span><br><span class="line">            ans = (ans + f[n][<span class="number">0</span>][<span class="number">0</span>]) % P;</span><br><span class="line">        <span class="keyword">if</span> (f[n][<span class="number">0</span>][<span class="number">1</span>] != <span class="number">-1</span>)</span><br><span class="line">            ans = (ans + f[n][<span class="number">0</span>][<span class="number">1</span>]) % P;</span><br><span class="line">        <span class="keyword">if</span> (f[n][<span class="number">1</span>][<span class="number">3</span>] != <span class="number">-1</span>)</span><br><span class="line">            ans = (ans + f[n][<span class="number">1</span>][<span class="number">3</span>]) % P;</span><br><span class="line">        <span class="keyword">if</span> (f[n][<span class="number">3</span>][<span class="number">1</span>] != <span class="number">-1</span>)</span><br><span class="line">            ans = (ans + f[n][<span class="number">3</span>][<span class="number">1</span>]) % P;</span><br><span class="line">        <span class="keyword">if</span> (f[n][<span class="number">3</span>][<span class="number">2</span>] != <span class="number">-1</span>)</span><br><span class="line">            ans = (ans + f[n][<span class="number">3</span>][<span class="number">2</span>]) % P;</span><br><span class="line">        <span class="keyword">if</span> (f[n][<span class="number">3</span>][<span class="number">3</span>] != <span class="number">-1</span>)</span><br><span class="line">            ans = (ans + f[n][<span class="number">3</span>][<span class="number">3</span>]) % P;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;mine.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;1.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>) &#123; <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;?&#x27;</span>) ++cnt;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt;= <span class="number">12</span>) &#123;</span><br><span class="line">            Sub1::<span class="built_in">solve</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Sub3::<span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>被虐垫底测试（9）</title>
    <url>/2019/08/17/%E8%A2%AB%E8%99%90%E5%9E%AB%E5%BA%95%E6%B5%8B%E8%AF%95%EF%BC%889%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://baka.online/wp-content/uploads/2019/08/problem-2.pdf">题在这里</a> 真垫底了………都会做-&gt;调不出来-&gt;几十分 EASY LIFE</p>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>限制答案的位置，一定在某两个点之间的连线的中点上。基于这个思路，考虑存在一条路径把地图分成了两半，这条路径上的最大边最小时，就是答案。 这个明显是个MST模型。Prim求MST，$O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6000</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">    <span class="keyword">double</span> cost;</span><br><span class="line">&#125; g[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">double</span> c)</span> </span>&#123;</span><br><span class="line">    g[++tot].to = y, g[tot].nxt = head[x],</span><br><span class="line">    g[tot].cost = c, head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, X[N], Y[N], from[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">double</span> dis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>  x == k + <span class="number">1</span>  y == <span class="number">0</span>  y == k + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">sqrt</span>((<span class="keyword">double</span>)(Y[x] - Y[y]) * (Y[x] - Y[y]));</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">sqrt</span>((<span class="keyword">double</span>)(X[x] - X[y]) * (X[x] - X[y])</span><br><span class="line">        + (<span class="keyword">double</span>)(Y[x] - Y[y]) * (Y[x] - Y[y]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k + <span class="number">1</span>; ++i)</span><br><span class="line">        dis[i] = <span class="number">1e18</span>;</span><br><span class="line">    Y[k + <span class="number">1</span>] = m;</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    std::<span class="built_in">fill</span>(from, from + k + <span class="number">2</span>, N - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x = <span class="number">-1</span>; i &lt;= k + <span class="number">1</span>; ++i, x = <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k + <span class="number">1</span>; ++j)</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; (x == <span class="number">-1</span>  dis[j] &lt; dis[x]))</span><br><span class="line">                x = j;</span><br><span class="line">        vis[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (from[x] != N - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">addedge</span>(from[x], x, dis[x]);</span><br><span class="line">            <span class="built_in">addedge</span>(x, from[x], dis[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k + <span class="number">1</span>; ++j)</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; dis[j] &gt; <span class="built_in">get_dis</span>(x, j)) </span><br><span class="line">                dis[j] = <span class="built_in">get_dis</span>(x, j), from[j] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == k + <span class="number">1</span>) ans = max;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        <span class="keyword">if</span> (y != fa)</span><br><span class="line">            <span class="built_in">dfs</span>(y, x, std::<span class="built_in">max</span>(max, g[i].cost));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>(), k = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">        X[i] = <span class="built_in">rd</span>(), Y[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">prim</span>(); <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.9lf\n&quot;</span>, ans / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>线段树维护单调栈。 先介绍一下这个黑科技：比如要维护一个单减的单调栈，定义函数${\rm query}(l,r,v)$，表示查询$l,r$后面压入一个$v$的答案。 调用时，使用${\rm query}(l,r,0)$。在内部分类讨论： 如果当前区间已经被要查询的区间包含了： 如果右儿子最大值$rmax$大于$v$，${\rm query}(l,mid,rmax),{\rm query}(mid+1,r,v)$。 否则，可以发现右边全被弹了，${\rm query}(l,mid,v)$。 如果当前区间没有被要查询的区间包含： 如果查询的当前区间的某一半，直接递归。 否则，先查询右边，${\rm query}(mid+1,r,v)$，并且得到一个右边要查询区间的最大值$rmax$，${\rm query}(l,imd,rmax)$。 显然是$O(nlog^2n)$的。 回到这个题，定义$f_i$，表示删掉$[1,i]$的最小代价。 定义$q_i,q_{p_i}=i$。可以发现，对于$j \in [1,p_i]$，它们中形成下降子序列的$t_j$，$f_{t_j}$都可以转移到$f_i$。 用线段树维护一下就可以了。 至于那种转移为什么是对的：考虑$f_i$从$f_j$转移来，$j &lt; i$，一定有$(j,i)$的点连着的边，都被$[1,j]$或者$i$截掉了。现在考虑右侧点，假设某个点$a$对应的$q_a$可行，后面出现了另一个可行的$b$，则必须有$q_b &lt; q_a$，以便截断$a$连着的边。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using std::cerr;</span></span><br><span class="line"><span class="comment">// using std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">2333</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> max, val, mem;</span><br><span class="line">&#125; t[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(p) p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(p) p &lt;&lt; 1  1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> qaqmax;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[p].max &lt; v) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> qaqmax = std::<span class="built_in">max</span>(qaqmax, t[p].max), t[p].val;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[<span class="built_in">rs</span>(p)].max &lt;= v)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r, v, L, mid);</span><br><span class="line">        qaqmax = std::<span class="built_in">max</span>(qaqmax, t[p].max);</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">min</span>(t[<span class="built_in">ls</span>(p)].mem, <span class="built_in">query</span>(<span class="built_in">rs</span>(p), l, r, v, mid + <span class="number">1</span>, R));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid &amp;&amp; r &gt; mid) &#123;</span><br><span class="line">        qaqmax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="built_in">query</span>(<span class="built_in">rs</span>(p), l, r, v, mid + <span class="number">1</span>, R);</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">min</span>(tmp, <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r, qaqmax, L, mid));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r, v, L, mid);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(p), l, r, v, mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    t[p].max = std::<span class="built_in">max</span>(t[<span class="built_in">ls</span>(p)].max, t[<span class="built_in">rs</span>(p)].max);</span><br><span class="line">    t[p].val = std::<span class="built_in">min</span>(t[<span class="built_in">ls</span>(p)].val, t[<span class="built_in">rs</span>(p)].val);</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    t[<span class="built_in">ls</span>(p)].mem = <span class="built_in">query</span>(<span class="built_in">ls</span>(p), L, mid, t[<span class="built_in">rs</span>(p)].max, L, mid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> y1, <span class="keyword">int</span> y2, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> (<span class="keyword">void</span>)(t[p].max = y2, t[p].val = y1);</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">update</span>(<span class="built_in">ls</span>(p), x, y1, y2, L, mid);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(<span class="built_in">rs</span>(p), x, y1, y2, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">pushup</span>(p, L, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, p[N], q[N], c[N], f[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        p[i] = <span class="built_in">rd</span>(), q[p[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        c[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">4</span>; ++i)</span><br><span class="line">        t[i].mem = t[i].val = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">0</span>, p[i] - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        f[i] = (tmp == INF ? <span class="number">0</span> : tmp) + c[i];</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>, p[i], f[i], i, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INF, o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (o &lt; p[i])</span><br><span class="line">            o = p[i], ans = std::<span class="built_in">min</span>(ans, f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>令$x$为$y$的祖先。 $$\frac{c_y-c_x}{dis_{x,y&#125;&#125;$$ $$-\frac{c_x-c_y}{dep_x-dep_y}$$ 把$dep$看作横坐标，$c$看作纵坐标，最优点一定在下凸壳上。 DFS这棵树，维护祖先链的凸包。考试写了二分，挂了。。 有一个科技：倍增维护。$fa_{x,i}$，以$x$为最后一个点凸包向前走$2^i$的位置。利用这个就不需要二分和栈的科技，可以很好的维护凸包了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">2333</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span>, INF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, val[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125; g[N];</span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    g[++tot] = &#123; y, head[x] &#125;;</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep[N], lg[N], fa[N][<span class="number">21</span>];</span><br><span class="line"><span class="keyword">double</span> slo[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)(val[x] - val[y]) / (dep[x] - dep[y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> xx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[xx]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = xx, y = g[i].to;</span><br><span class="line">        dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">20</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">            <span class="keyword">if</span> (slo[fa[x][j]] - <span class="built_in">slope</span>(fa[x][j], y) &gt; -eps)</span><br><span class="line">                x = fa[x][j];</span><br><span class="line">        <span class="keyword">if</span> (slo[x] - <span class="built_in">slope</span>(x, y) &gt; -eps)</span><br><span class="line">            x = fa[x][<span class="number">0</span>];</span><br><span class="line">        slo[y] = <span class="built_in">slope</span>(x, y);</span><br><span class="line">        fa[y][<span class="number">0</span>] = x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; ++j)</span><br><span class="line">            fa[y][j] = fa[fa[y][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">solve</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        val[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">addedge</span>(<span class="built_in">rd</span>(), i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    slo[<span class="number">0</span>] = slo[<span class="number">1</span>] = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[<span class="number">1</span>]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to;</span><br><span class="line">        fa[y][<span class="number">0</span>] = dep[y] = <span class="number">1</span>;</span><br><span class="line">        slo[y] = <span class="built_in">slope</span>(<span class="number">1</span>, y);</span><br><span class="line">        <span class="built_in">solve</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.9lf\n&quot;</span>, -slo[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>计划列表</title>
    <url>/2019/10/04/%E8%AE%A1%E5%88%92%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>已经十月了，再继续没命考试就凉了，定一个复习计划表。 思维练习。noip应该没多少数学，终点练习DP。找题单。 复习二分图，网络流简单内容。主要是各种定理。 简单博弈论。nim级别的。 SOS DP。貌似是黑科技。 复习各种板子。树套树和LCT。Tarjan搞清楚。</p>
<hr>
<p>这里是看网页/做题计划： <a href="https://www.cnblogs.com/clrs97/p/5817684.html">BZOJ3145</a> <a href="https://www.cnblogs.com/acha/p/7502122.html">BZOJ3145</a> <a href="https://www.cnblogs.com/acha/p/9042984.html">竞赛图</a> <a href="https://loj.ac/problem/6041">又是字符串</a> <a href="https://blog.csdn.net/litble/article/details/93746964">广义线段树</a></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>记使用WSL（Windows Subsystem for Linux）的一些问题</title>
    <url>/2020/02/23/%E8%AE%B0%E4%BD%BF%E7%94%A8wsl%EF%BC%88windows-subsystem-for-linux%EF%BC%89%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>关于为什么用WSL：曾经是用Manjaro的，但是某次下载东西，硬盘不够了，就把Linux删了…实际上对于OI来说，WSL已经够用了，可以同时享受到Linux写代码，和Windows的易用。</p>
<hr>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>其实安装没什么问题…直接装Ubuntu就好…换个国内源什么的</p>
<h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><p>装好zsh和ohmyzsh什么的都很简单。可以发现Windows上打开WSL有两个命令：一个是wsl.exe，一个是bash.exe。后面那个顾名思义，是强行开bash的。所以要用第一个。</p>
<h2 id="terminal"><a href="#terminal" class="headerlink" title="terminal"></a>terminal</h2><p>WSL装好之后自带的那个太丑了。GitHub上有很多非常好看的终端，但是他们有一个共性问题：在Vim里鼠标不能用。（好像是Windows的问题）经测试，找到了<a href="https://github.com/mskyaxl/wsl-terminal">wsl-terminal</a>。虽然不是很好看，但是比自带的强很多，而且可以用鼠标。</p>
<h2 id="ls配色"><a href="#ls配色" class="headerlink" title="ls配色"></a>ls配色</h2><p>ls配色默认特别丑，就是那个绿色的方块。。。 在~/.zshrc下加入这几行就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Change ls colours</span><br><span class="line">LS_COLORS=&quot;ow=01;36;40&quot; &amp;&amp; export LS_COLORS</span><br><span class="line"></span><br><span class="line"># make cd use the ls colours</span><br><span class="line">zstyle &#x27;:completion:*&#x27; list-colors &quot;$&#123;(@s.:.)LS_COLORS&#125;&quot;</span><br><span class="line">autoload -Uz compinit</span><br><span class="line">compinit</span><br></pre></td></tr></table></figure>

<h2 id="复制代码"><a href="#复制代码" class="headerlink" title="复制代码"></a>复制代码</h2><p>复制代码到剪切板肯定不能手动托嘛。WSL有一个很厉害的特性：可以直接在里面打开Windows下的软件。 所以 cat foo.bar clip.exe 这样就可以复制到Windows剪切板里了。Vim里绑个键就行</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>国家集训队小Z的袜子（莫队板子）</title>
    <url>/2019/02/27/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E5%B0%8Fz%E7%9A%84%E8%A2%9C%E5%AD%90%EF%BC%88%E8%8E%AB%E9%98%9F%E6%9D%BF%E5%AD%90%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2038">[国家集训队]小Z的袜子</a> 混了半年才过了莫队板子，总结一下。。。 莫队是用来离线解决区间查询问题的算法，一般，已知$[l, r]$的答案，可以$O(1)$的移动两端得到新答案。下面的复杂度分析也基于这个假设。 考虑从$[l, r]$的答案转移到$[l’, r’]$，复杂度为$O(l-l’+r-r’)$。所以，如果构建出所有询问的最小曼哈顿距离生成树，复杂度最小。 然而这么做难度略高，这时候就有了莫队算法：将区间分块，把询问按照所在区块为第一关键字，右端点为第二关键字排序，这样可以得到很优秀的复杂度。即$O(n\sqrt m)$。 证明：令分块大小为$s$，则有$n/s$块。考虑在一个分块内的询问，因为右端点有序，最多移动$O(n)$次，$O(n^2/s)$。移动左端点所在分块时，右端点最多移动$O(n)$，也是$O(n^2/s)$。一个区间内和转移区间时，左端点移动都是$O(s)$的，$m$次询问，$O(sm)$。总复杂度$O(n^2/s+sm)$。 因为一般问题内$m&gt;=n$，令$s=n/ \sqrt m$，总复杂度化为$O(n\sqrt m)$。不知道网上为什么分块大小都是$s=\sqrt n$。。。。明显跑得慢嘛= = 回到这个题，令$c_i$为$i$颜色出现次数，明显区间$[l,r]$的答案是 $(\sum_i(c_i(c_i-1)/2))/((r-l+1)<em>(r-l)/2)\newline =(\sum_ic_i^2-(r-l+1))/((r-l+1)</em>(r-l)/2)$ 所以，我们排序后一边移动一边维护$\sum_ic_i^2$即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50000</span> + <span class="number">2333</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, color[N], pos[N], block;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans, sum[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ok, all;</span><br><span class="line">&#125; node[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp1</span><span class="params">(<span class="keyword">const</span> Node &amp;x, <span class="keyword">const</span> Node &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos[x.l] == pos[y.l])</span><br><span class="line">        <span class="keyword">return</span> x.r &lt; y.r;</span><br><span class="line">    <span class="keyword">return</span> x.l &lt; y.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp2</span><span class="params">(<span class="keyword">const</span> Node &amp;x, <span class="keyword">const</span> Node &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.id &lt; y.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> add)</span> </span>&#123;</span><br><span class="line">    ans -= sum[color[p]] * sum[color[p]];</span><br><span class="line">    sum[color[p]] += add;</span><br><span class="line">    ans += sum[color[p]] * sum[color[p]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y == <span class="number">0</span> ? x : <span class="built_in">gcd</span>(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        color[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        node[i].l = <span class="built_in">rd</span>(), node[i].r = <span class="built_in">rd</span>(),</span><br><span class="line">        node[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        pos[i] = (i - <span class="number">1</span>) / block + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(node + <span class="number">1</span>, node + m + <span class="number">1</span>, comp1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l = <span class="number">1</span>, r = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node[i].l == node[i].r) &#123;</span><br><span class="line">            node[i].ok = <span class="number">0</span>;</span><br><span class="line">            node[i].all = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> ( ; r &lt; node[i].r; ++r)</span><br><span class="line">                <span class="built_in">update</span>(r + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> ( ; r &gt; node[i].r; --r)</span><br><span class="line">                <span class="built_in">update</span>(r, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> ( ; l &lt; node[i].l; ++l)</span><br><span class="line">                <span class="built_in">update</span>(l, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> ( ; l &gt; node[i].l; --l)</span><br><span class="line">                <span class="built_in">update</span>(l - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> x = ans - (node[i].r - node[i].l + <span class="number">1</span>),</span><br><span class="line">                y = (<span class="keyword">long</span> <span class="keyword">long</span>)(node[i].r - node[i].l + <span class="number">1</span>) * (node[i].r - node[i].l),</span><br><span class="line">                g = <span class="built_in">gcd</span>(x, y);</span><br><span class="line">            node[i].ok = x / g, node[i].all = y / g;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(node + <span class="number">1</span>, node + m + <span class="number">1</span>, comp2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>, node[i].ok, node[i].all);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>货车运输</title>
    <url>/2019/01/05/%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1967">货车运输</a> 理论上树链剖分好写一些，然而蒟蒻只能用倍增+LCA… 思路：注意到小边没用，直接贪心求出最大生成树，最优答案一定在最大生成树上 建出新树，求一下重心（其实并不需要… 以重心为树根跑LCA，同时用数组$mincost[x][i]$记录从点x开始向上走$2^i$步能走到的距离内边的最小值。它与LCA用到的数组可以同时求出 于是每次询问，先用最小生成树用到的并查集判断两点是否联通，然后求两点LCA，顺便计算出答案即可 还是有坑的：这题的图不一定联通，需要for一遍全部处理。每次更新答案要在改变点的位置之前，返回前再更新一次…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123&#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">0</span>;<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))a=c==<span class="string">&#x27;-&#x27;</span>?<span class="number">0</span>:<span class="number">1</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))b=b*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> a?b:-b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e4</span>+<span class="number">233</span>,MAXM=MAXN*<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="comment">// 旧图</span></span><br><span class="line">        <span class="keyword">int</span> from,to,c;</span><br><span class="line">    &#125;edge[MAXM];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> Edge &amp;x, <span class="keyword">const</span> Edge &amp;y)</span></span>&#123;<span class="keyword">return</span> x.c&gt;y.c;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">G</span>&#123;</span> <span class="comment">// 新树</span></span><br><span class="line">        <span class="keyword">int</span> to,nxt,c;</span><br><span class="line">    &#125;g[MAXM*<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN],tot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">        g[++tot].to=y,g[tot].nxt=head[x],g[tot].c=z;</span><br><span class="line">        head[x]=tot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fa[MAXN]; <span class="comment">// 并查集</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAXN;++i)</span><br><span class="line">            fa[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work_m</span><span class="params">()</span></span>&#123; <span class="comment">// 求最大生成树</span></span><br><span class="line">        n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=<span class="built_in">rd</span>(),y=<span class="built_in">rd</span>(),z=<span class="built_in">rd</span>();</span><br><span class="line">            edge[i].from=x,edge[i].to=y,edge[i].c=z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(edge+<span class="number">1</span>,edge+m+<span class="number">1</span>,comp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=<span class="built_in">find</span>(edge[i].from),y=<span class="built_in">find</span>(edge[i].to);</span><br><span class="line">            <span class="keyword">if</span>(x!=y)&#123;</span><br><span class="line">                fa[x]=y;</span><br><span class="line">                <span class="built_in">add</span>(edge[i].from,edge[i].to,edge[i].c);</span><br><span class="line">                <span class="built_in">add</span>(edge[i].to,edge[i].from,edge[i].c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min_tree=<span class="number">1</span>&lt;&lt;<span class="number">30</span>,pos,size[MAXN];</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">// 求重心（其实没用。。。</span></span><br><span class="line">        size[x]=vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max_part=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=g[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> y=g[i].to;</span><br><span class="line">            <span class="keyword">if</span>(!vis[y])&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(y);</span><br><span class="line">                size[x]+=size[y];</span><br><span class="line">                max_part=<span class="built_in">max</span>(max_part,size[y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max_part=<span class="built_in">max</span>(max_part,n-size[x]);</span><br><span class="line">        <span class="keyword">if</span>(max_part&lt;min_tree)&#123;</span><br><span class="line">            min_tree=max_part;</span><br><span class="line">            pos=x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dep[MAXN],f[MAXN][<span class="number">21</span>],max_dep,min_edge[MAXN][<span class="number">21</span>];</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; <span class="comment">// LCA询问</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line">        <span class="keyword">if</span>(dep[x]&lt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=max_dep;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dep[f[x][i]]&gt;=dep[y])&#123;</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,min_edge[x][i]);</span><br><span class="line">                x=f[x][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x==y) <span class="keyword">return</span> ans; <span class="comment">// 这里不用再更新，上面更新过了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=max_dep;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[x][i]!=f[y][i])&#123;</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,<span class="built_in">min</span>(min_edge[x][i],min_edge[y][i]));</span><br><span class="line">                x=f[x][i];</span><br><span class="line">                y=f[y][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里记得再更新一次</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(ans,<span class="built_in">min</span>(min_edge[x][<span class="number">0</span>],min_edge[y][<span class="number">0</span>])); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123; <span class="comment">// LCA预处理</span></span><br><span class="line">        max_dep=<span class="built_in">log2</span>(m)+<span class="number">1</span>;</span><br><span class="line">        que.<span class="built_in">push</span>(s);dep[s]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> x=que.<span class="built_in">front</span>();que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x],y=g[i].to;i;i=g[i].nxt,y=g[i].to)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dep[y])&#123;</span><br><span class="line">                    dep[y]=dep[x]+<span class="number">1</span>;</span><br><span class="line">                    f[y][<span class="number">0</span>]=x; min_edge[y][<span class="number">0</span>]=g[i].c;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=max_dep;++j)&#123;</span><br><span class="line">                        f[y][j]=f[f[y][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">                        min_edge[y][j]=<span class="built_in">min</span>(min_edge[y][j<span class="number">-1</span>],min_edge[f[y][j<span class="number">-1</span>]][j<span class="number">-1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    que.<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work_q</span><span class="params">()</span></span>&#123; <span class="comment">// 回答问题</span></span><br><span class="line">        <span class="keyword">int</span> q=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=<span class="built_in">rd</span>(),y=<span class="built_in">rd</span>();</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)!=<span class="built_in">find</span>(y)) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">ask</span>(x,y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">work_m</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">                min_tree=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">                <span class="built_in">lca</span>(pos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">work_q</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>Update：学完树剖来补个 效率对比（开启O2）：</p>
<blockquote>
<p>树链剖分：375ms 倍增：275ms</p>
</blockquote>
<p>虽然树剖慢，但是这题树剖不需要思考（（（代码难度彼此彼此吧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kai586123 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span>? <span class="number">0</span>: <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> a? b: -b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e4</span> + <span class="number">2333</span>, MAXM = MAXN * <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OG</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> from, to, c;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> OG &amp;gg) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> c &gt; gg.c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; og[MAXM * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">G</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> to, nxt, c;</span><br><span class="line">    &#125; g[MAXM * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], tot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        g[++tot].to = y, g[tot].nxt = head[x], g[tot].c = z;</span><br><span class="line">        head[x] = tot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fa[MAXN];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f[MAXN], son[MAXN], dep[MAXN], size[MAXN], num, w[MAXN], wt[MAXN], id[MAXN], top[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fat)</span> </span>&#123;</span><br><span class="line">        f[x] = fat, dep[x] = dep[fat] + <span class="number">1</span>, size[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxson = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y = g[i].to; i; i = g[i].nxt, y = g[i].to) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y != fat) &#123;</span><br><span class="line">                <span class="built_in">dfs1</span>(y, x);</span><br><span class="line">                w[y] = g[i].c, size[x] += size[y];</span><br><span class="line">                <span class="keyword">if</span> (size[y] &gt; maxson) son[x] = y, maxson = size[y];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line">        id[x] = ++num, wt[num] = w[x], top[x] = topf;</span><br><span class="line">        <span class="keyword">if</span> (!son[x]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(son[x], topf);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y = g[i].to; i; i = g[i].nxt, y = g[i].to)</span><br><span class="line">            <span class="keyword">if</span> (y != f[x] &amp;&amp; y != son[x])</span><br><span class="line">                <span class="built_in">dfs2</span>(y, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SegTree</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> l, r, v;</span><br><span class="line">    &#125; t[MAXN * <span class="number">4</span>];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls(p) p &lt;&lt; 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs(p) p &lt;&lt; 1  1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        t[p].l = l, t[p].r = r;</span><br><span class="line">        <span class="keyword">if</span> (l == r) t[p].v = wt[l];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">build</span>(<span class="built_in">ls</span>(p), l, mid);</span><br><span class="line">            <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">            t[p].v = <span class="built_in">min</span>(t[<span class="built_in">ls</span>(p)].v, t[<span class="built_in">rs</span>(p)].v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) <span class="keyword">return</span> t[p].v;</span><br><span class="line">        <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>, ans = INF;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r));</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">query</span>(<span class="built_in">rs</span>(p), l, r));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query_range</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(x) != <span class="built_in">find</span>(y)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = INF;</span><br><span class="line">        <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">query</span>(<span class="number">1</span>, id[top[x]], id[x]));</span><br><span class="line">            x = f[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dep[x] &lt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, <span class="built_in">query</span>(<span class="number">1</span>, id[y] + <span class="number">1</span>, id[x])); <span class="comment">// +1不取上面那条边</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="built_in">rd</span>(), M = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>(), z = <span class="built_in">rd</span>();</span><br><span class="line">            og[i].from = x, og[i].to = y, og[i].c = z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(og + <span class="number">1</span>, og + M + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++i) fa[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = og[i].from, y = og[i].to, c = og[i].c, xx = <span class="built_in">find</span>(x), yy = <span class="built_in">find</span>(y);</span><br><span class="line">            <span class="keyword">if</span> (xx != yy) &#123;</span><br><span class="line">                fa[xx] = yy;</span><br><span class="line">                <span class="built_in">addedge</span>(x, y, c);</span><br><span class="line">                <span class="built_in">addedge</span>(y, x, c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(w, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(w));</span><br><span class="line">        <span class="built_in">memset</span>(wt, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(wt));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!id[i]) &#123;</span><br><span class="line">                <span class="built_in">dfs1</span>(i, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">dfs2</span>(i, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, N);</span><br><span class="line">        <span class="keyword">int</span> Q = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query_range</span>(x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    kai586123::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>被虐垫底测试（4）</title>
    <url>/2019/08/05/%E8%A2%AB%E8%99%90%E5%9E%AB%E5%BA%95%E6%B5%8B%E8%AF%95%EF%BC%884%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://baka.online/wp-content/uploads/2019/08/cssyzday1.doc.pdf">题目在这里</a> 花了一个多小时rush了$284$分，没想到炸成了$300-284$分，自闭了。。。</p>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>最水的题。考虑到乘法顺序无关，可以先把行的算完，再算列的。进一步观察，每一列都可以表示为第一列加一个数（等差数列）。这就好办了。</p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>用线段树维护，每个节点维护一个数组，$nxt[i]$表示$x$为$i$，走过这一段是什么（其实就是置换） 置换明显是满足结合律的，可以矩乘。 这题放一下代码吧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cerr;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt[N];</span><br><span class="line">&#125; t[N * <span class="number">4</span>], tmp1, tmp2;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(p) p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(p) p &lt;&lt; 1  1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(Node &amp;x, Node &amp;y, Node &amp;z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        tmp1.nxt[i] = y.nxt[i];</span><br><span class="line">        tmp2.nxt[i] = z.nxt[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        x.nxt[i] = tmp2.nxt[tmp1.nxt[i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> to = L == m ? <span class="number">1</span> : L + <span class="number">1</span>,</span><br><span class="line">                x = i == <span class="number">1</span> ? n : i - <span class="number">1</span>,</span><br><span class="line">                y = i,</span><br><span class="line">                z = i == n ? <span class="number">1</span> : i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> val = std::<span class="built_in">max</span>(std::<span class="built_in">max</span>(a[x][to], a[y][to]), a[z][to]);</span><br><span class="line">            <span class="keyword">if</span> (val == a[x][to])</span><br><span class="line">                t[p].nxt[i] = x;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (val == a[y][to])</span><br><span class="line">                t[p].nxt[i] = y;</span><br><span class="line">            <span class="keyword">else</span> t[p].nxt[i] = z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(p), L, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">pushup</span>(t[p], t[<span class="built_in">ls</span>(p)], t[<span class="built_in">rs</span>(p)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> w, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> to = L == m ? <span class="number">1</span> : L + <span class="number">1</span>,</span><br><span class="line">                x = i == <span class="number">1</span> ? n : i - <span class="number">1</span>,</span><br><span class="line">                y = i,</span><br><span class="line">                z = i == n ? <span class="number">1</span> : i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> val = std::<span class="built_in">max</span>(std::<span class="built_in">max</span>(a[x][to], a[y][to]), a[z][to]);</span><br><span class="line">            <span class="keyword">if</span> (val == a[x][to])</span><br><span class="line">                t[p].nxt[i] = x;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (val == a[y][to])</span><br><span class="line">                t[p].nxt[i] = y;</span><br><span class="line">            <span class="keyword">else</span> t[p].nxt[i] = z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (w &lt;= mid)</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">ls</span>(p), w, L, mid);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">rs</span>(p), w, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">pushup</span>(t[p], t[<span class="built_in">ls</span>(p)], t[<span class="built_in">rs</span>(p)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="comment">//  cerr &lt;&lt;  p &lt;&lt; &quot; &quot; &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R)</span><br><span class="line">        <span class="keyword">return</span> t[p];</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid &amp;&amp; r &gt; mid) &#123;</span><br><span class="line">        Node ret, la, ra;</span><br><span class="line">        la = <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r, L, mid);</span><br><span class="line">        ra = <span class="built_in">query</span>(<span class="built_in">rs</span>(p), l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">        <span class="built_in">pushup</span>(ret, la, ra);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &lt;= mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r, L, mid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(p), l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">fpow</span><span class="params">(Node x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    Node ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ret.nxt[i] = i;</span><br><span class="line">    <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">pushup</span>(ret, ret, x);</span><br><span class="line">        <span class="built_in">pushup</span>(x, x, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;data.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            a[i][j] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line">    q = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">10</span>]; Node node;</span><br><span class="line">    <span class="keyword">int</span> nowx = <span class="number">1</span>, nowy = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;m&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="built_in">rd</span>();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, nowy, nowx);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nowx + k - <span class="number">1</span> &lt;= m) &#123;</span><br><span class="line">                nowy = <span class="built_in">query</span>(<span class="number">1</span>, nowx, nowx + k - <span class="number">1</span>, <span class="number">1</span>, m).nxt[nowy];</span><br><span class="line">                nowx = nowx + k;</span><br><span class="line">                <span class="keyword">if</span> (nowx &gt; m) nowx -= m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= m - nowx + <span class="number">1</span>;</span><br><span class="line">                nowy = <span class="built_in">query</span>(<span class="number">1</span>, nowx, m, <span class="number">1</span>, m).nxt[nowy];</span><br><span class="line">                nowx = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (k / m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    node = <span class="built_in">fpow</span>(t[<span class="number">1</span>], k / m);</span><br><span class="line">                    nowy = node.nxt[nowy];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (k % m != <span class="number">0</span>)</span><br><span class="line">                    nowy = <span class="built_in">query</span>(<span class="number">1</span>, nowx, nowx + (k % m) - <span class="number">1</span>, <span class="number">1</span>, m).nxt[nowy];</span><br><span class="line">                nowx = nowx + (k % m);</span><br><span class="line">                <span class="keyword">if</span> (nowx &gt; m) nowx -= m;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, nowy, nowx);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>(), v = <span class="built_in">rd</span>();</span><br><span class="line">            a[x][y] = v;</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, y == <span class="number">1</span> ? m : y - <span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>$84$分做法： 询问的是$[l,r]$，那么就找到$[l,r]$中的最大最小值。再找到这两个值之间所有值，出现位置最左最右的位置。循环，直到不再变化。 $100$分做法： 点这里。 <a href="https://baka.online/cerc2017intrinsic-interval-tarjan%e7%ba%bf%e6%ae%b5%e6%a0%91%e5%bb%ba%e5%9b%be/">[CERC2017]Intrinsic Interval [Tarjan][线段树建图]</a></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>赛道修建</title>
    <url>/2019/01/12/%E8%B5%9B%E9%81%93%E4%BF%AE%E5%BB%BA/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P5021">赛道修建</a> NOIp2018 Day1 T3，考试的时候太弱只打了40分暴力，还错了20分。。。痛失1=。。。 言归正传，这题要在树上选M段链，使得它们之间没有公共边，求出最短边最大值。 DP求出直径长度为二分上界，二分一个值出来，然后在树上统计有多少满足条件的边。 统计方法很有放在NOIp题里很有思维难度了，不过认真画一画还是能画出来的。</p>
<hr>
<p><img src="https://baka.online/wp-content/uploads/2019/01/20170410133259616.png"> 这是一棵树（出处见水印）。我们定义根为1，把无根树变为有根树，假设这棵树上可以找到三条满足条件的链：5-7，6-11，9-10。 发现对于每一条链，都可以找到一个点x，使这条链过点x，且不过点x向上的所有边（即在x子树上）。三条链的x：1，3，4。可以想到，运用类似点分治的思想，考虑以每个点为根的子树。 进一步观察，对于个点，如果经过它的祖先的链用到了它到子节点的边，那么只能用一条边。如第一条链里包括1-3-6，3到子节点的边只用了3-6。此结论显然，却十分有用。 也就是说，考虑x节点y，z，那么x-y的边只有三种情况：不使用，在y-x-z的链上，在x祖先-x-y链上。 算法初步成形：在每个子树上，尝试用一条或两条边拼出满足条件的链，把剩下的链中最长的一条传回给父亲，让父亲到自己这条边的长度加上传回去的长度作为新的边。 有一点点分治的感觉呢qwq（于是把点分治的标签加上了）。</p>
<hr>
<p>那么问题就集中在“尝试用一条或两条边拼出满足条件的链”的算法了。如果给定一个数组，用里面的数拼&gt;=K，选最大然后从小向大扫即可，复杂度O(N)。然而这里是行不通的，因为要让拼出最多链的情况下，传回去的边也尽可能的长。 改用从小向大扫描，发现复杂度变为O(N^2)。不过，变形不等式$x + y \geq K$，得到$y \geq K - x$，快速找出一个满足条件的y即可降低复杂度，用multiset维护（好写），复杂度降为O(NlogN)。 个人认为总复杂度是：O(NlogNlogL)，其中L为直径长度。</p>
<hr>
<p>Code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">2333</span>, INF = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>) + <span class="number">5201314</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">G</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt, c;</span><br><span class="line">&#125; g[MAXN * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAXN], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    g[++tot].to = y, g[tot].nxt = head[x],</span><br><span class="line">    g[tot].c = c, head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> max_dis, dp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_maxdis</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to, c = g[i].c;</span><br><span class="line">        <span class="keyword">if</span> (vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">get_maxdis</span>(y);</span><br><span class="line">        max_dis = <span class="built_in">max</span>(max_dis, dp[x] + dp[y] + c);</span><br><span class="line">        dp[x] = <span class="built_in">max</span>(dp[x], dp[y] + c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DFS</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt, edge;</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="keyword">int</span> _cnt, <span class="keyword">int</span> _edge) &#123; cnt = _cnt, edge = _edge; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">DFS <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, edge = <span class="number">0</span>;</span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = g[i].to, c = g[i].c;</span><br><span class="line">        <span class="keyword">if</span> (y == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        DFS d = <span class="built_in">dfs</span>(y, x, K);</span><br><span class="line">        <span class="keyword">if</span> (c + d.edge &gt;= K)</span><br><span class="line">            ++cnt;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ms.<span class="built_in">insert</span>(c + d.edge);</span><br><span class="line">        cnt += d.cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &gt;= M)</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!ms.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        multiset&lt;<span class="keyword">int</span>&gt;::iterator t = ms.<span class="built_in">upper_bound</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> xt = *t;</span><br><span class="line">        ms.<span class="built_in">erase</span>(t);</span><br><span class="line">        t = ms.<span class="built_in">lower_bound</span>(K - xt);</span><br><span class="line">        <span class="keyword">if</span> (t == ms.<span class="built_in">end</span>())</span><br><span class="line">            edge = xt;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ms.<span class="built_in">erase</span>(t);</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &gt;= M)</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">233</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DFS</span>(cnt, edge);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    N = <span class="built_in">rd</span>(), M = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>(), c = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">addedge</span>(x, y, c);</span><br><span class="line">        <span class="built_in">addedge</span>(y, x, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get_maxdis</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = max_dis, mid, ans, ok;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        ok = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            ok = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">            ans = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>跳舞</title>
    <url>/2019/03/28/%E8%B7%B3%E8%88%9E/</url>
    <content><![CDATA[<p>话说我在跳舞的时候，舞王cwy也在跳舞，于是我过了上一道题，他过了这道题o_O。 <a href="https://www.luogu.org/problemnew/show/P2029">跳舞</a> 这个跳舞不是网络流，是DP大水题。我们就让$f[i][j]$表示跳到第$i$个，连跳了$j$次。然后初值就是一直没跳，$f[i][j]=max(f[i-1][j]-s[i],f[i-1][j-1]+s[i])$，当跳够$T$倍数次的时候加上奖励$f[i][j]=max(f[i-1][j]-s[i],f[i-1][j-1]+s[i]+b[i])$，暴力转移就行了。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>负载平衡问题</title>
    <url>/2019/01/05/%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4016">负载平衡问题</a> 这题在网络流24题里，是个费用流的板子题，不过数学解法也能做</p>
<h2 id="网络流解法"><a href="#网络流解法" class="headerlink" title="网络流解法"></a>网络流解法</h2><p>（下面用(f, c)表示一条边的流量，费用）： 求出平均数avg，从s向低于avg的点连(avg-a, 0)，从高于avg的点向t连(a-avg, 0) 相邻两条边之间连(INF, 1)，表示可以互相传递，注意1和n之间也要连边 跑最小费用最大流即可</p>
<h2 id="数学解法"><a href="#数学解法" class="headerlink" title="数学解法"></a>数学解法</h2><p>我们把搬运货物的方向固定（可正可负），如从1开始搬运向n，那么1和n之间不存在搬运（已经搬完了) 所以，令$sum$为减去$avg$之后的前缀和数组，从1开始搬运的$ans=\Sigma ∣sum[i]∣$ 如果换为从k开始的话，$ans=\Sigma ∣sum[i]-sum[k]∣$，当$sum[k]$取中位数时，$ans$最小，所以排序求出中位数即可解决本题 核心代码： （Ps：最近因为变量名冲突开始用namespace了，所以main是void类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        a[i]=<span class="built_in">rd</span>(),sum+=a[i];</span><br><span class="line">    avg=sum/n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        a[i]-=avg;</span><br><span class="line">        c[i]=c[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(c+<span class="number">1</span>,c+n+<span class="number">1</span>);</span><br><span class="line">    mid=c[(<span class="number">1</span>+n)/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        ans+=<span class="built_in">abs</span>(c[i]-mid);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>跳楼机</title>
    <url>/2019/06/12/%E8%B7%B3%E6%A5%BC%E6%9C%BA/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3403">跳楼机</a> 这玩意做法叫同余最短路。 $ax+by+cz=k,k\in [1,h],x,y,z\geq 0$，求有多少$k$能被表示。 求出用$by+cz$表示的，$\mod a \in [0,a-1]$的各数最小是多少，就可以求答案了。 这玩意其实是个图论的最短路。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL h, a, b, c, ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">LL dis[N];</span><br><span class="line">priority_queue&lt;pair&lt;LL, <span class="keyword">int</span>&gt; &gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = que.<span class="built_in">top</span>().second;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (dis[(x + b) % a] &gt; dis[x] + b) &#123;</span><br><span class="line">            dis[(x + b) % a] = dis[x] + b;</span><br><span class="line">            que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-dis[(x + b) % a], (x + b) % a));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dis[(x + c) % a] &gt; dis[x] + c) &#123;</span><br><span class="line">            dis[(x + c) % a] = dis[x] + c;</span><br><span class="line">            que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-dis[(x + c) % a], (x + c) % a));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; h &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">if</span> (a &gt; c) <span class="built_in">swap</span>(a, c);</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; h &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a; ++i)</span><br><span class="line">        <span class="keyword">if</span> (dis[i] &lt;= h)</span><br><span class="line">            ans += (h - dis[i]) / a + <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>车站分级</title>
    <url>/2019/01/12/%E8%BD%A6%E7%AB%99%E5%88%86%E7%BA%A7/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1983">车站分级</a> 并不裸的拓扑排序题。。每条输入给定一个区间内车开过去必须停的车站。不管它们内部权值如何，它们的权值一定高于区间内未停靠的车站。 所以可以从未停靠车站向停靠车站连一条的有向边，全输入完之后，deg为0的车站权值就是1，它们连着的车站就是2。以此类推，拓扑排序找到深度最大是多少就行了。 优化：暴力连边空间会炸，记录哪些点之间已经连过边了。实际上可以建一个虚点，把O(N^2)的连边数优化到O(N)。不过后面统计答案比暴力难写一点。。。 Code木有，因为太丑了QAQ</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>轨道 反演DP</title>
    <url>/2019/09/21/%E8%BD%A8%E9%81%93-%E5%8F%8D%E6%BC%94dp/</url>
    <content><![CDATA[<p>貌似是jzoj的题… <a href="https://baka.online/wp-content/uploads/2019/09/TIM%E6%88%AA%E5%9B%BE20190921211152.png">题截了个图因为会在主页显示很违和就放链接里了点这里可以看</a> 很有意思的一个题，之前看过一次DP状态设计，自己yy了一个反演… 首先是个DP。$(v,k)=1$，说明$(\prod a_i,k)=k$。令$f_{i,j}$为前$i$个，和$k$的最大公约数为$j$。发现这个状态太大了，把$j$改成第$j$个因子。 $$f_{i,j}=\sum f_{i-1,k_1}f_{1,k_2}$$ 其中，$k_1$是枚举的，$k_2$是算出来的，$k_1k_2$两个因子的积为因子$j$。 问题就在于如何求出$f_{1,x}$ $$f_{1,x} = \sum_{i=1}^m [gcd(i,k) = x]$$ 题解里说是容斥，蒟蒻不会容斥，，，搞了个反演 令$f(x)$为$\sum_{i=1}^m [gcd(i,k) = x]$，$F(x)$为$\sum_{i=1}^m [x \mid gcd(i,k)]$ $$F(x) = \sum_{i=1}^m [x \mid gcd(i,k)] = \lfloor \frac{m}{x} \rfloor [x \mid k]$$ $$f(x) = \sum_{x \mid d} \mu(\frac{d}{x}) F(d) = \sum_{T=1}^{\lfloor \frac{m}{x} \rfloor} \mu(T) F(xT)$$ 化简一下，得到这个式子： $$f(x) = \sum_{T=1}^{\lfloor \frac{m}{x} \rfloor} \mu(T) [xT \mid k] \lfloor \frac{m}{xT} \rfloor$$ 然而，还不能整除分块。两个问题，首先本题$m$的范围是$10^9$，其次，$[xT \mid k]$如何处理。 不过实际上，$k$的范围是$10^7$。也就是说，我们只需要处理到$10^7$就可以了。这可以用一个naive的线性筛随便搞定。至于$[xT \mid k]$，把它乘进$\mu$里即可。 因为用vector被卡常了（悲</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC target(<span class="meta-string">&quot;sse&quot;</span>,<span class="meta-string">&quot;sse2&quot;</span>,<span class="meta-string">&quot;sse3&quot;</span>,<span class="meta-string">&quot;sse4&quot;</span>,<span class="meta-string">&quot;avx&quot;</span>,<span class="meta-string">&quot;avx2&quot;</span>,<span class="meta-string">&quot;popcnt&quot;</span>) </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">7000</span>, M = <span class="number">1e7</span> + <span class="number">233</span>, P = <span class="number">10007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> part[N], tot;</span><br><span class="line"><span class="keyword">int</span> pri[M], vis[M], tt;</span><br><span class="line"><span class="keyword">int</span> mu[M];</span><br><span class="line"><span class="keyword">int</span> qaq[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    part[++tot] = mu[<span class="number">1</span>] = <span class="number">1</span>; qaq[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k % i == <span class="number">0</span>)</span><br><span class="line">            part[++tot] = i, qaq[i] = tot;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">            pri[++tt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * pri[j] &lt;= k; ++j) &#123;</span><br><span class="line">            vis[i * pri[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i * pri[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i * pri[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">        mu[i] = mu[i - <span class="number">1</span>] + (k % i == <span class="number">0</span>) * mu[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N / <span class="number">2</span>][N];</span><br><span class="line">std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; mul[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= x; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = x / (x / l);</span><br><span class="line">        ret += (mu[std::<span class="built_in">min</span>(k, r)] - mu[std::<span class="built_in">min</span>(k, l - <span class="number">1</span>)]) * (x / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m / part[i] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        f[<span class="number">1</span>][i] = <span class="built_in">calc</span>(m / part[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)part[i] * part[j] &gt; k)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> qwq = part[i] * part[j];</span><br><span class="line">            <span class="keyword">if</span> (qaq[qwq])</span><br><span class="line">                mul[qaq[qwq]].<span class="built_in">push_back</span>(&#123; i, j &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; ++j) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> y : mul[j]) &#123;</span><br><span class="line">                sum += f[i - <span class="number">1</span>][y.first] * f[<span class="number">1</span>][y.second];</span><br><span class="line">            &#125;</span><br><span class="line">            f[i][j] = (f[i][j] + sum) % P;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; f[n][tot] &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="built_in">init1</span>();</span><br><span class="line">    <span class="built_in">init2</span>();</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>运输计划</title>
    <url>/2019/01/06/%E8%BF%90%E8%BE%93%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2680">运输计划</a> 这题正解应该是树链剖分，要删的边一定在最长路径上，枚举路径上每一条边然后用max(最长路径-这条边, 不经过这条边的最长路径)更新答案。 然而蒟蒻用了二分判定，被疯狂卡常，开了O2才在Luogu上过掉（大约当年NOIp是会被卡一个点的…） 预处理所有路径的长度，LCA。因为答案只要求一个数字，二分这个答案，然后把所有&gt;这个长度的路径树上差分加在树上，求出每一条边经过多少次。求出被加上的所有路径经过，且最长的一条边。用最长链-这条边长度，判定是否&lt;=二分答案。 卡常还是很恶心的，一开始用了倍增求路径长度，即一条路径要跑两次LCA（一次求点，一次求距离），TLE。优化常数的同时，把求两点间距离方式改成了dep[x] + dep[y] - 2 * dep[lca(x, y)]，O2卡过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 21, stdin), p1 == p2)? EOF: *p1++)</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span> &lt;&lt; <span class="number">21</span>], *p1 = buf, *p2 = buf;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span>? <span class="number">0</span>: <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a? b: -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e5</span> + <span class="number">23333</span>;</span><br><span class="line"><span class="keyword">int</span> N, M, lg[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Task</span> &#123;</span> <span class="keyword">int</span> x, y, dis, lca; &#125; t[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> Task &amp;a, <span class="keyword">const</span> Task &amp;b)</span> </span>&#123; <span class="keyword">return</span> a.dis &gt; b.dis; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">G</span> &#123;</span> <span class="keyword">int</span> to, nxt, c; &#125; g[MAXN * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAXN], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    g[++tot].to = y, g[tot].c = c, g[tot].nxt = head[x];</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[MAXN][<span class="number">20</span>], tp, dep[MAXN], dis[MAXN];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init_lca</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="number">1</span>), dep[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y = g[i].to; i; i = g[i].nxt, y = g[i].to) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[y]) <span class="keyword">continue</span>;</span><br><span class="line">            dep[y] = dep[x] + <span class="number">1</span>, fa[y][<span class="number">0</span>] = x, dis[y] = dis[x] + g[i].c;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tp; ++j)</span><br><span class="line">                fa[y][j] = fa[fa[y][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">            que.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query_lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &lt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tp; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (dep[fa[x][i]] &gt;= dep[y]) &#123;</span><br><span class="line">            x = fa[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tp; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (fa[x][i] != fa[y][i])</span><br><span class="line">            x = fa[x][i], y = fa[y][i];</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y = g[i].to; i; i = g[i].nxt, y = g[i].to)</span><br><span class="line">        <span class="keyword">if</span> (dep[y] == dep[x] + <span class="number">1</span>) &#123;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, <span class="built_in">dfs</span>(y, cnt)), sum[x] += sum[y];</span><br><span class="line">            <span class="keyword">if</span> (sum[y] == cnt) mx = <span class="built_in">max</span>(mx, g[i].c);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(sum));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">        <span class="keyword">if</span> (t[i].dis &gt; ans)</span><br><span class="line">            ++cnt, ++sum[t[i].x], ++sum[t[i].y], sum[t[i].lca] -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="built_in">dfs</span>(<span class="number">1</span>, cnt);</span><br><span class="line">    <span class="keyword">if</span> (t[<span class="number">1</span>].dis - tmp &gt; ans) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = <span class="built_in">rd</span>(), M = <span class="built_in">rd</span>(), tp = <span class="built_in">log2</span>(N) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>(), z = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">addedge</span>(x, y, z), <span class="built_in">addedge</span>(y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init_lca</span>();</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, R = <span class="number">0</span>, ans = <span class="number">233</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">        t[i].x = <span class="built_in">rd</span>(), t[i].y = <span class="built_in">rd</span>(),</span><br><span class="line">        t[i].lca = <span class="built_in">query_lca</span>(t[i].x, t[i].y),</span><br><span class="line">        t[i].dis = dis[t[i].x] + dis[t[i].y] - <span class="number">2</span> * dis[t[i].lca],</span><br><span class="line">        R = <span class="built_in">max</span>(R, t[i].dis);</span><br><span class="line">    <span class="built_in">sort</span>(t + <span class="number">1</span>, t + M + <span class="number">1</span>, comp);</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">judge</span>(mid)) ans = mid, R = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> L = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>重返现世 广义MinMax容斥</title>
    <url>/2020/01/15/%E9%87%8D%E8%BF%94%E7%8E%B0%E4%B8%96-%E5%B9%BF%E4%B9%89minmax%E5%AE%B9%E6%96%A5/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4707">重返现世</a> 就在这里系统复习一下这类内容好了。 下面式子都是Min求Max，因为貌似用Min求Max比较多，反过来也行。</p>
<h3 id="Min-Max容斥："><a href="#Min-Max容斥：" class="headerlink" title="Min Max容斥："></a>Min Max容斥：</h3><p>$$\min(S) = \sum_{T \subseteq S} (-1)^{T - 1} \max(T) $$</p>
<h3 id="广义Min-Max容斥："><a href="#广义Min-Max容斥：" class="headerlink" title="广义Min Max容斥："></a>广义Min Max容斥：</h3><p>$${\rm kthmax}(S) = \sum_{T \subseteq S} (-1)^{T - k} \binom{T - 1}{k - 1} \min(T) $$ 只证明这个好了… 令系数为$f(T)$。钦定一个第$x$大的元素，考虑她对答案的贡献。容易发现和$x$有关的系数和是： $$\sum_{i=0}^{n-x} \binom{n - x}{i} f(i+1) = [n - x = k - 1]$$ 那么换个元 $$\sum_{i=0}^{m-1} \binom{m - 1}{i} f(i+1) = [m - 1 = k - 1]$$ 二项式反演得到 $$f(m) = \sum_{i=0}^{m-1} \binom{m - 1}{i} [i - 1 = k - 1] (-1)^{m - k + 1} $$ $$f(m) = \binom{m - 1}{k - 1} (-1)^{m - k} $$</p>
<hr>
<p>回到这题，题求的是min，$k \rightarrow n - k + 1$换成max 设选了一个集合，概率和为$p/m$，显然期望次数是$m/p$，于是只需要知道$\sum p$ 设计一个反正我想不出来的神仙DP： $f_{i,j,k}$表示前$i$个数，概率和是$j$，是$K=k$大 那么有转移如下： $$f_{i,j,k} = f_{i-1,j,k} + f_{i-1,j-p_i,k-1} - f_{i-1,j-p_i,k}$$ 后面那个部分很迷惑，解释是这样的： 加了一个元素，容斥系数有一些变化。发现$\binom{T-1}{k-1} = \binom{T - 2}{k - 1} + \binom{T - 2}{k - 2}$，代进去就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>, M = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, K, m, p[N], f[<span class="number">2</span>][M][<span class="number">11</span>], now, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  x += y;</span><br><span class="line">  <span class="keyword">if</span> (x &gt;= P)</span><br><span class="line">    x -= P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( ; y; y &gt;&gt;= <span class="number">1</span>, x = <span class="number">1ll</span> * x * x % P)</span><br><span class="line">    <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = <span class="number">1ll</span> * ret * x % P;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;K, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, p + i);</span><br><span class="line">  K = n - K + <span class="number">1</span>;</span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    now ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= K; ++k)</span><br><span class="line">        f[now][j][k] = f[now ^ <span class="number">1</span>][j][k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = p[i]; j &lt;= m; ++j)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= K; ++k) &#123;</span><br><span class="line">        <span class="built_in">add</span>(f[now][j][k], f[now ^ <span class="number">1</span>][j - p[i]][k - <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">add</span>(f[now][j][k], P - f[now ^ <span class="number">1</span>][j - p[i]][k]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    <span class="built_in">add</span>(ans, <span class="number">1ll</span> * f[now][i][K] * <span class="built_in">fpow</span>(i, P - <span class="number">2</span>) % P);</span><br><span class="line">  std::cout &lt;&lt; <span class="number">1ll</span> * ans * m % P &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>金坷垃</title>
    <url>/2019/01/05/%E9%87%91%E5%9D%B7%E5%9E%83/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P5035">Luogu P5035 金坷垃</a> 数学题，给出k，求第k个用自身减去除本身的一个因数，重复过程可以得到1的数 我：打表可知，满足的数必为$2^x$（确信 众：数学论证，请 我： 若有$b a$，且$a - b = 1$，可知$a = 2, b = 1$ 进一步，若$b a$，且$a - b = 2$，可知$a = 4, b = 2$ 运用数学归纳法得答案 $Q.E.D$（论 证 有 力</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y, <span class="keyword">long</span> <span class="keyword">long</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = ans * x % z;</span><br><span class="line">        x = x * x % z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> k;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">fpow</span>(<span class="number">2LL</span>, k - <span class="number">1</span>, <span class="number">123456789LL</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>长链剖分 学习笔记</title>
    <url>/2019/11/11/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>某套CSP模拟题里有道题用到了长链剖分的思想,补习一下,要是CSP没有挂以后肯定有用(所以不要挂啊OAO!!!) 众所周知树链剖分主要有重,长,实链剖分三种.重的全世界都会,实链剖分就是LCT那个 长链剖分,顾名思义,要选最长的链.在dfs的时候,选择最深的儿子即可</p>
<hr>
<h3 id="O-1-求k级祖先"><a href="#O-1-求k级祖先" class="headerlink" title="O(1)求k级祖先"></a>O(1)求k级祖先</h3><p>这一部分先咕了,考完再说 <strong>update 2020：</strong> 准退役，但是至少没退役，来更新一下 长链剖分有一个极好的性质：任何一个点$k$级祖先，在的链长$ \geq k$。 证明：一条链显然。不在一条链，如果不足$k$，剖分时就会选这条$k$的链。 于是可以用以下步骤完成： 记录每个数的最高位$1$，记录每个点向上$2^k$到哪，记录每条长为$k$的链的链头向上或向下$k$个点。 询问的时候先把询问最高位跳上去，发现所在链长度一定$ &gt; $剩下没跳的部分，就可以找到了。</p>
<hr>
<h3 id="维护贪心"><a href="#维护贪心" class="headerlink" title="维护贪心"></a>维护贪心</h3><p>模拟赛里见到的就是类似这个题的…</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3252">bzoj3252 攻略</a> 我们可以发现贪心选最优是正确的,把长链剖分的深度改称链权值和剖分,贪心选$k$大即可</p>
<h3 id="优化深度有关DP"><a href="#优化深度有关DP" class="headerlink" title="优化深度有关DP"></a>优化深度有关DP</h3><p>如果维护的信息只和深度有关,那么可以用长链剖分做到$O(n)$ 具体来说,就是继承重儿子的信息,暴力合并轻儿子,然后每个节点只会被算一次 实现上,可以用指针实现,具体看代码.</p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p><a href="https://www.luogu.org/problem/CF1009F">CF1009F Dominant Indices</a> 我们令$f_{x,i}$表示$x$子树内距离为$i$点数 $$f_{x,i} = \sum f_{y,i-1}$$ 我们发现$f_x$是$f_y$平移了一下得到的,所以可以长链剖分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, dep[N], son[N], *f[N], tmp[N], *pt = tmp, ans[N];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y : G[x]) <span class="keyword">if</span> (y != fa) &#123;</span><br><span class="line">    <span class="built_in">dfs1</span>(y, x);</span><br><span class="line">    <span class="keyword">if</span> (dep[y] &gt; dep[son[x]])</span><br><span class="line">      son[x] = y;</span><br><span class="line">  &#125;</span><br><span class="line">  dep[x] = dep[son[x]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  f[x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (son[x]) &#123;</span><br><span class="line">    f[son[x]] = f[x] + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], x);</span><br><span class="line">    ans[x] = ans[son[x]] + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y : G[x]) <span class="keyword">if</span> (y != fa &amp;&amp; y != son[x]) &#123;</span><br><span class="line">    f[y] = pt; pt += dep[y];</span><br><span class="line">    <span class="built_in">dfs2</span>(y, x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= dep[y]; ++j) &#123;</span><br><span class="line">      f[x][j] += f[y][j - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> ((j &lt; ans[x] &amp;&amp; f[x][j] &gt;= f[x][ans[x]])</span><br><span class="line">           (j &gt; ans[x] &amp;&amp; f[x][j] &gt; f[x][ans[x]]))</span><br><span class="line">        ans[x] = j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (f[x][ans[x]] == <span class="number">1</span>)</span><br><span class="line">    ans[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">    G[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    G[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  f[<span class="number">1</span>] = pt;</span><br><span class="line">  pt += dep[<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.luogu.org/problem/P3565">[POI2014]HOT-Hotels</a> 考虑在三个点LCA计算贡献. 我们先统计两个点,再加入一个点即可进行计算 令$f_{x,i},g_{x,i}$分别表示距离$x$为$i$的点数,$x$子树内距离他们的$lca$距离为$d$,$lca$距离$x$距离为$d-i$的点对数量. 那么考虑$x$点扩展子树$y$,计算答案.答案可以由$x$内选一个/两个,$y$内选两个/一个点得到 $$ans += g_{x,0} + \sum f_{x,i}g_{y,i-1} + f_{y,i-1}g_{x,i}$$ $$g_{x,i}+ = g_{y,i+1} + f_{x,i} f_{y,i-1} $$ $$f_{x,i} += f_{y,i-1}$$ 实现细节很多,康代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, len[N], son[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125; G[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  G[++tot].to = y, G[tot].nxt = head[x],</span><br><span class="line">  head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = G[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = G[i].to;</span><br><span class="line">    <span class="keyword">if</span> (y != fa) &#123;</span><br><span class="line">      <span class="built_in">dfs1</span>(y, x);</span><br><span class="line">      <span class="keyword">if</span> (len[y] &gt; len[son[x]])</span><br><span class="line">        son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  len[x] = len[son[x]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> *f[N], *g[N], tmp[N * <span class="number">10</span>], *pt = tmp, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (son[x]) &#123;</span><br><span class="line">    f[son[x]] = f[x] + <span class="number">1</span>;</span><br><span class="line">    g[son[x]] = g[x] - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], x);</span><br><span class="line">  &#125;</span><br><span class="line">  f[x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  ans += g[x][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = G[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = G[i].to;</span><br><span class="line">    <span class="keyword">if</span> (y != fa &amp;&amp; y != son[x]) &#123;</span><br><span class="line">      f[y] = pt, pt += len[y] * <span class="number">2</span>;</span><br><span class="line">      g[y] = pt, pt += len[y] * <span class="number">2</span>;</span><br><span class="line">      <span class="built_in">dfs2</span>(y, x);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len[y]; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">          ans += f[x][j - <span class="number">1</span>] * g[y][j];</span><br><span class="line">        ans += g[x][j + <span class="number">1</span>] * f[y][j];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len[y]; ++j) &#123;</span><br><span class="line">        g[x][j + <span class="number">1</span>] += f[x][j + <span class="number">1</span>] * f[y][j];</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">          g[x][j - <span class="number">1</span>] += g[y][j];</span><br><span class="line">        f[x][j + <span class="number">1</span>] += f[y][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">addedge</span>(x, y);</span><br><span class="line">    <span class="built_in">addedge</span>(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  f[<span class="number">1</span>] = pt, pt += len[<span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">  g[<span class="number">1</span>] = pt, pt += len[<span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>被虐垫底测试（2）</title>
    <url>/2019/08/01/%E8%A2%AB%E8%99%90%E5%9E%AB%E5%BA%95%E6%B5%8B%E8%AF%95%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://baka.online/wp-content/uploads/2019/08/problem.pdf">题目在这里</a></p>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>线段树题。$26$个字母，所以维护一下$26$个字母的线段树。排序的时候一段一段改、 但是，据说这样会TLE。 热动分析一下，如果直接维护区间是否相等可不可行。 这个做法看似会被卡，但是实际上如果想构造一段能卡住的区间，需要很多次操作，但是一次操作就会把它变得很整齐。虽然不会证，但是直觉告诉我们，这样均摊是优秀的。 一种珂朵莉树的复杂度的感觉。。。</p>
<hr>
<p>Update：某不科学的复杂度证明 极度不科学，瞎眼勿入。。。 我们构造特殊数据来卡复杂度。一次操作不管操作的区间多长，最多把它变成$26$段字母段。考虑连续操作$k$次，使长度为$26k$的序列乱序，那么一次针对$26k$序列的排序操作，复杂度会变为被卡到枚举$26k$个线段树叶子的复杂度。 把这个复杂度均摊到打乱的操作上，相当于每次打乱操作的复杂度是$O(2 * 26)$。 实际上也就是说，这么做的复杂度，不会比在每个节点维护一个数组的复杂度劣。综合实际来看，在没有特殊构造的数据下，定是常数上更优秀的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">2333</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m; <span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> same[N * <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(p) p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(p) p &lt;&lt; 1  1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (same[<span class="built_in">ls</span>(p)] == same[<span class="built_in">rs</span>(p)])</span><br><span class="line">        same[p] = same[<span class="built_in">ls</span>(p)];</span><br><span class="line">    <span class="keyword">else</span> same[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (same[p])</span><br><span class="line">        same[<span class="built_in">ls</span>(p)] = same[<span class="built_in">rs</span>(p)] = same[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> (<span class="keyword">void</span>)(same[p] = str[L]);</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(p), L, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R) <span class="keyword">return</span> (<span class="keyword">void</span>)(same[p] = v);</span><br><span class="line">    <span class="built_in">pushdown</span>(p); <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">change</span>(<span class="built_in">ls</span>(p), l, r, v, L, mid);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) <span class="built_in">change</span>(<span class="built_in">rs</span>(p), l, r, v, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> que[<span class="number">233</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; r &gt;= R &amp;&amp; same[p])</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>)(que[same[p]] += (R - L + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">pushdown</span>(p); <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">query</span>(<span class="built_in">ls</span>(p), l, r, L, mid);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) <span class="built_in">query</span>(<span class="built_in">rs</span>(p), l, r, mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> (<span class="keyword">void</span>)(<span class="built_in">putchar</span>(same[p]));</span><br><span class="line">    <span class="built_in">pushdown</span>(p); <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">write</span>(<span class="built_in">ls</span>(p), L, mid);</span><br><span class="line">    <span class="built_in">write</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>, &amp;n, &amp;m, str + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, x; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;z&#x27;</span>; ++i) que[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">query</span>(<span class="number">1</span>, l, r, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="string">&#x27;a&#x27;</span>, lst = l; i &lt;= <span class="string">&#x27;z&#x27;</span>; ++i) <span class="keyword">if</span> (que[i])</span><br><span class="line">                <span class="built_in">change</span>(<span class="number">1</span>, lst, lst + que[i] - <span class="number">1</span>, i, <span class="number">1</span>, n), lst = lst + que[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="string">&#x27;z&#x27;</span>, lst = l; i &gt;= <span class="string">&#x27;a&#x27;</span>; --i) <span class="keyword">if</span> (que[i])</span><br><span class="line">                <span class="built_in">change</span>(<span class="number">1</span>, lst, lst + que[i] - <span class="number">1</span>, i, <span class="number">1</span>, n), lst = lst + que[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>题目描述不清，出题人语文略差，cryx1。 不会做。暴力还TLE了。哭哭x2。 看题解看不懂，哭了x3。 自己理解了一波不知道对不对，以下照搬题解。。。。<a href="https://blog.bill.moe/yaliD3T2-matrix/">Orz这里的爷爷</a> 注意，本题非限定区间内并不能放$1$。 首先这题其实和行没关系，可以把行压扁成一行，按列考虑。 令$f[i][j]$表示前$i$列，有$j$列在右侧区间放了$1$的方案数。 为什么这样设状态呢？因为实际上随着位置的推进，左边放哪是不会受到限制的，右边才会。在推进的时候，如果跨越了一个左端点，那么可以随便选一个地方放$1$。 具体看代码吧。。。。反正我是想不出来。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3005</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, L[N], R[N], f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l, r; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        ++L[l]; ++R[r];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在列上做一个前缀和 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        L[i] += L[i - <span class="number">1</span>];</span><br><span class="line">        R[i] += R[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 对于这个新的i多出的一个放的位置，可以选择放j或者不放 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            f[i][j] = (f[i - <span class="number">1</span>][j] + (<span class="keyword">long</span> <span class="keyword">long</span>)f[i - <span class="number">1</span>][j - <span class="number">1</span>] * (R[i] - (j - <span class="number">1</span>))) % P;</span><br><span class="line">        <span class="comment">// 对于左边的，随便选一个地方放就行了 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = L[i - <span class="number">1</span>]; j &lt; L[i]; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= i; ++k)</span><br><span class="line">                f[i][k] = (<span class="keyword">long</span> <span class="keyword">long</span>)f[i][k] * (i - j - k) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[m][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>先分析一下题目中那个恶心的操作是什么。 $$(\lfloor \frac{2x}{2^n} \rfloor + 2x) \mod 2^n$$ $\lfloor \frac{2x}{2^n} \rfloor$是取最高位。 $2x$是左移一位。 最后把数字变成了和原来一样长。 这不就是把第一位移动到了最后嘛！！！ 把这个操作记做${\rm qwq}(x)$，记录前缀后缀异或和，再看看题目要求什么： $$\max_x \min_{i} {\rm qwq}(x \oplus pre_i) \oplus suf_{i+1}$$ 利用刚才发现的性质，可以知道，这个$\rm qwq$是可以拆开的。 $$\max_x \min_{i} {\rm qwq}(x) \oplus ( {\rm qwq}( pre_i) \oplus suf_{i+1} )$$ 这就很好了。 问题转化为，求一个$x$，使它与后面这一坨东西$\oplus$起来最小值最大。 把后面的东西插进一个Trie里面，DFS查询，记录最大值。 如果某节点有$0,1$两个儿子，那么，不管$x$取什么，都可以把这一位强行$\oplus$成$0$，这一位不变。如果只有一个儿子，显然可以把它$\oplus$成$1$，取上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) a = c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) b = b * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> a ? b : -b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">2333</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, num[N], pre[N], suf[N], trie[N * <span class="number">50</span>][<span class="number">2</span>], tot, ans1, ans2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>, now = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!trie[now][t]) trie[now][t] = ++tot;</span><br><span class="line">        now = trie[now][t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T2_bu_hui_zuo_wo_liang_le</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> k, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (trie[now][<span class="number">0</span>] &amp;&amp; trie[now][<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">T2_bu_hui_zuo_wo_liang_le</span>(trie[now][<span class="number">0</span>], k - <span class="number">1</span>, num);</span><br><span class="line">        <span class="built_in">T2_bu_hui_zuo_wo_liang_le</span>(trie[now][<span class="number">1</span>], k - <span class="number">1</span>, num);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (trie[now][<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="built_in">T2_bu_hui_zuo_wo_liang_le</span>(trie[now][<span class="number">0</span>], k - <span class="number">1</span>, num + (<span class="number">1</span> &lt;&lt; k));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (trie[now][<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">T2_bu_hui_zuo_wo_liang_le</span>(trie[now][<span class="number">1</span>], k - <span class="number">1</span>, num + (<span class="number">1</span> &lt;&lt; k));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; ans1) ans1 = num, ans2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num == ans1) ++ans2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        num[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        pre[i] = pre[i - <span class="number">1</span>] ^ ((<span class="number">2</span> * num[i] / (<span class="number">1</span> &lt;&lt; n) + <span class="number">2</span> * num[i]) % (<span class="number">1</span> &lt;&lt; n));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        suf[i] = suf[i + <span class="number">1</span>] ^ num[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">insert</span>(pre[i] ^ suf[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">T2_bu_hui_zuo_wo_liang_le</span>(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n&quot;</span>, ans1, ans2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>反素数</title>
    <url>/2019/01/05/%E5%8F%8D%E7%B4%A0%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1463">反素数</a> 一个数论+搜索题 我们可以知道，对于正整数$x$，可以质因数分解为： $b^{c_1}_1 \times b^{c_2}_2 \times … \times b^{c_k}_k$ 由乘法原理易知，a的约数个数 $g(x)=({c_1}+1) \times ({c_2}+1) \times … \times ({c_k}+1)$ 易知$c$的顺序并不影响$g(x)$的值 我们可以将${c_1},{c_2}…{c_k}$从大到小排序，求出此时的$x$，则$x$最小 我们枚举所有的$c$，当$g(x)&gt;maxg$时直接更新$ans$与$maxg$，当$g(x)=maxg,sum&lt;ans$时更新sum</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> max_g, ans;</span><br><span class="line"><span class="keyword">int</span> p[] = &#123; <span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">po</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= y; ++i) &#123;</span><br><span class="line">        a *= (<span class="keyword">long</span> <span class="keyword">long</span>)p[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> g, <span class="keyword">long</span> <span class="keyword">long</span> sum, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g&lt;<span class="number">0</span>  sum&lt;<span class="number">0</span>  sum&gt;n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (g&gt;max_g) ans = sum, max_g = g;</span><br><span class="line">    <span class="keyword">if</span> (g == max_g &amp;&amp; sum&lt;ans) ans = sum;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(g*(i + <span class="number">1</span>), sum*<span class="built_in">po</span>(k, i), k + <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">31</span>);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>黑匣子</title>
    <url>/2019/01/05/%E9%BB%91%E5%8C%A3%E5%AD%90/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1801">Luogu P1801 黑匣子_NOI导刊2010提高（06）</a> 题目要求一边插入，一边维护加入的元素中第i小的值，容易想到使用对顶堆 用了两个优先队列，一个放前i小的数，一个放更大的 直接放一下核心代码好了（懒懒懒</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> M,N,I=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> m[<span class="number">200100</span>],n;</span><br><span class="line">std::priority_queue&lt;<span class="keyword">int</span>&gt; less;</span><br><span class="line">std::priority_queue&lt;<span class="keyword">int</span>,std::vector&lt;<span class="keyword">int</span>&gt;,std::greater&lt;<span class="keyword">int</span>&gt; &gt; more;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M=<span class="built_in">read</span>(),N=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i) m[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=N;++i)&#123;</span><br><span class="line">        n=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;=n;++j)&#123;</span><br><span class="line">            less.<span class="built_in">push</span>(m[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(less.<span class="built_in">size</span>()&gt;I+<span class="number">1</span>)&#123;</span><br><span class="line">            more.<span class="built_in">push</span>(less.<span class="built_in">top</span>());</span><br><span class="line">            less.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!more.<span class="built_in">empty</span>() &amp;&amp; less.<span class="built_in">size</span>()&lt;I+<span class="number">1</span>)&#123;</span><br><span class="line">            less.<span class="built_in">push</span>(more.<span class="built_in">top</span>());</span><br><span class="line">            more.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ++I;</span><br><span class="line">        <span class="keyword">while</span>(!less.<span class="built_in">empty</span>() &amp;&amp; !more.<span class="built_in">empty</span>() &amp;&amp; less.<span class="built_in">top</span>()&gt;more.<span class="built_in">top</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> x=less.<span class="built_in">top</span>();</span><br><span class="line">            less.<span class="built_in">pop</span>();</span><br><span class="line">            less.<span class="built_in">push</span>(more.<span class="built_in">top</span>());</span><br><span class="line">            more.<span class="built_in">pop</span>();</span><br><span class="line">            more.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout&lt;&lt;less.<span class="built_in">top</span>()&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>杂题乱做2</title>
    <url>/2020/08/24/noi%E5%89%8D%E8%AE%AD%E7%BB%83%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>退役前给自己看的，删了一些东西放出来了，有兴趣可以看看</p>
<h3 id="Conquer-the-World"><a href="#Conquer-the-World" class="headerlink" title="Conquer the World"></a>Conquer the World</h3><p>题意：树上匹配，权是距离 模拟费用流。</p>
<h3 id="Gem-Island"><a href="#Gem-Island" class="headerlink" title="Gem Island"></a>Gem Island</h3><p>题意：一开始每个人都有1个绿宝石，每天选一个存在的绿宝石并分裂，求拥有前r大的人绿宝石个数期望 考虑任意一种方案被得到的概率：考虑方案数，为分配序列的排列，乘上$\prod a_i$。这是因为每一组都有很多个，可以任选一个。发现方案数和具体方案无关，那么答案就是总和/总方案数。 考虑DP，考虑分层DP，每次给上一次的子集+1。可以发现这样可以得到想要的答案。</p>
<h3 id="Single-Cut-of-Failure"><a href="#Single-Cut-of-Failure" class="headerlink" title="Single Cut of Failure"></a>Single Cut of Failure</h3><p>题意：方框内划线，切割所有线。 可以发现答案的上届是$2$。双指针可以判断是否可以是$1$。</p>
<h3 id="Triangles"><a href="#Triangles" class="headerlink" title="Triangles"></a>Triangles</h3><p>题意：数三角 考虑在三角一个顶点统计答案，可以发现，与另一条边有关。另一条边有一个控制范围，BIT维护。</p>
<h3 id="Black-and-White"><a href="#Black-and-White" class="headerlink" title="Black and White"></a>Black and White</h3><p>题意：路径贡献为左边的两种颜色差，求贡献为某个数的路径有多少 首先要注意，题意中的左边，指的是所有左边，不是挨着的点。。。。。。。。。。。。。。。。。。。。。。。。。。。那么钦定路径长度是偶数，如果不是，枚举最后一步改为偶数。 考虑两步为一个周期统计。发现只有走出拐形才有贡献。钦定两种一共走了$p$次，那么可以计算出需要各走多少次。之后排列一下就可以了。 关于走多少次怎么算：钦定各走了$i,j$次，则贡献为：$\frac{i+j+1}{2}-j$。</p>
<h3 id="Dirichlet-k-th-root"><a href="#Dirichlet-k-th-root" class="headerlink" title="Dirichlet k-th root"></a>Dirichlet k-th root</h3><p>$f^k \equiv g \pmod p$，已知$g,p$求$f$ 迪利克雷卷积也可以用费马小定理。</p>
<h3 id="Bags-of-Candies"><a href="#Bags-of-Candies" class="headerlink" title="Bags of Candies"></a>Bags of Candies</h3><p>题意：$[1,n]$的整数，如果gcd不为1就可以放在一组，一组最多两个，求最少分成多少组 考虑大于$n/2$的素数，显然只能一组。1只能一组。结论：除了它们，都能配对。 证明：考虑按每个数的最大质因子划分。最大质因子相同的显然可以匹配。如果有奇数个，匹配则不完全，那么把$2x$这个数单独留下不匹配，可以发现剩下的都有2，还能匹配。 那么只需求区间素数个数。min25即可。</p>
<h3 id="Contamination"><a href="#Contamination" class="headerlink" title="Contamination"></a>Contamination</h3><p>题意：给定不相交圆，钦定y坐标范围，给定两个点，求是否可以不碰圆走到。 因为不交，如果被阻拦，一定是一个圆从下边界顶到了上边界。扫描线即可</p>
<h3 id="Lighthouses"><a href="#Lighthouses" class="headerlink" title="Lighthouses"></a>Lighthouses</h3><p>题意：凸包，给定一些对角线，求一条不自交最长路。 倍长凸包，之后发现可以区间DP。</p>
<h3 id="Sum-of-Palindromes"><a href="#Sum-of-Palindromes" class="headerlink" title="Sum of Palindromes"></a>Sum of Palindromes</h3><p>题意：把一个数分解为若干回文数和，不超过25个 考虑构建一个回文串：只需取原数字一半，减1,再倍长。那么这样会让原数变短一半。</p>
<h3 id="leq-or-geq"><a href="#leq-or-geq" class="headerlink" title="leq or geq"></a>leq or geq</h3><p>题意：交互，给定10000个大小为10的栈，只知道栈顶，自己选一个数，题目给出一个符号，把和这个符号构成关系的都弹掉。50次弹空。 考虑势能：给每个数选一个势能，找一个数，使得无论是什么符号，势能都减少足够的值。 题解给出的做法是，令权值为$3^s$，找出一个数使得小于，大于它的都有一定数量，则弹后一定有一半除以3，势能下降到2/3。</p>
<h3 id="Stairways"><a href="#Stairways" class="headerlink" title="Stairways"></a>Stairways</h3><p>题意：一堆人走两个楼梯，经典问题 考虑DP，那么发现需要维护：区间+v，区间+i，区间min。分块+凸包维护。 注意斜率不要写错。。。。</p>
<h3 id="The-Halfwitters"><a href="#The-Halfwitters" class="headerlink" title="The Halfwitters"></a>The Halfwitters</h3><p>题意：三种操作，各有代价：交换序列相邻位置，反转序列，随机打乱。求把序列排成顺序的期望次数。 考虑直接求，交换次数就是逆序对（从1,2,3开始换），可以做。 一个排列两种决策：直接换，随机打乱。 考虑求随机的期望，那么把每种排列的代价排序，枚举断点，那么$x=\sum pre+sufx$，解方程解出来最优的</p>
<h3 id="To-argue-or-not-to-argue"><a href="#To-argue-or-not-to-argue" class="headerlink" title="To argue, or not to argue"></a>To argue, or not to argue</h3><p>题意：一张图，有些位置可以放，一对人不能放在一起，求方案数 考虑容斥，变成至少i对人放在一起，插头Dp即可</p>
<h3 id="无意识的石子堆-加强版"><a href="#无意识的石子堆-加强版" class="headerlink" title="无意识的石子堆 加强版"></a>无意识的石子堆 加强版</h3><p>题意：$nm$的矩阵，放$2n$个石子，每行每列最多$2$个，方案数 发现每一行都要放恰好$2$个。那么考虑枚举放了$2$个的列有多少。之后考虑方案数： 二分图，左边度数是$2$，右边一些是$1$一些是$2$。 首先考虑瞎连边，发现有可能两个点之间连了两条边，是错误的。所以容斥。连边的时候假设两条边有序，之后除掉，就可以做了。</p>
<h3 id="小-Q-的序列"><a href="#小-Q-的序列" class="headerlink" title="小 Q 的序列"></a>小 Q 的序列</h3><p>题意：序列权值为$\prod (a_i+i)$，对于输入序列所有子序列求权值和。 考虑一个DP：$f_{i,j}=f_{i-1,j-1}(A_i+j)+f_{i-1,j}$ 考虑优化：这个DP有些复杂，用$i-j$代替$j$：$f_{i,j}=f_{i-1,j}(A_i+i-j)+f_{i-1,j-1}$ 那么直接考虑组合含义：对于一个元素有三种选择：不选，贡献为$A_i+i$。放进原来的盒子里，或放进新的盒子里，不选的可以分治NTT，剩下的部分考虑DP：$g_{i,j}=-g_{i-1,j}j+g_{i-1,j-1}$把转移乘$-1$，组合意义变成了贡献是$(-1)^m$。 那么考虑生成函数：固定$j$，生成函数是有标号随便放，除以盒子排列。答案要对所有$g$求和，推一下发现是$e^{1-e^x}$</p>
<h3 id="Lucky-Tickets"><a href="#Lucky-Tickets" class="headerlink" title="Lucky Tickets"></a>Lucky Tickets</h3><p>题意略 重新注意一下比较系数求幂的方法。 其实有一个更简单的推倒方法： $$g=f^k$$ $$g’=kf’f^{k-1}$$ $$g’f=kf’g$$ 比较系数即可</p>
<h3 id="Many-Easy-Problems"><a href="#Many-Easy-Problems" class="headerlink" title="Many Easy Problems"></a>Many Easy Problems</h3><p>题意：一个点集会被能包含它的，最小的联通块覆盖。求每个大小的点集，覆盖所有这个大小的点集的联通块大小和。 考虑算一个点的贡献：如果贡献，那么在不同子树中出现。就可以做了</p>
<h3 id="一道数学题-加强版"><a href="#一道数学题-加强版" class="headerlink" title="一道数学题 加强版"></a>一道数学题 加强版</h3><p>考虑$f$的递推式：$f_{i}=2f_{i-1}+i^k-(i-1)^k$，令$g_{i}=2g_{i-1}-i^k+(i-1)^k$，则$f_i+g_i=2(f_{i-1}+g_{i-1})$。 $g$是一个$K-1$次多项式（原因待填 现在的问题是不知道$g_0$是多少。那么看作未知数，直接递推出$g_1,…,g_n$，再插值插出$g_0$即可。 原因Update： 看来需要补习数学知识啊。。 实际上，$f_i=2f_{i-1}+i^k-(i-1)^k$，是一个$k-1$次多项式。只不过问题是，因为它有$f_1=1$的限制，推出来的式子不满足这个限制，所以不可以直接求解。 那么下面来证明这样的式子是$k-1$次多项式： 实际上非常的简单。 考虑$x^k - (x-1)^k$。容易知道，这个式子是一个$k-1$次多项式。 考虑$f$的形状。它一定形如若干$k-1$次多项式之和，其中$i$是$0,n$之间的整数。 那么它就是$k-1$次多项式了。 至于怎么知道上面的式子因为$f_1=1$不满足了？这就又是一个坑了。目前并不会数学证明，只能考虑用等同于$g$的方法验证。 不过虽然不知道如何证明，却可以记一个技巧：看到这个式子很简单，那么大概率有天坑</p>
<h3 id="Beautiful-Bracket-Sequence-hard-version"><a href="#Beautiful-Bracket-Sequence-hard-version" class="headerlink" title="Beautiful Bracket Sequence (hard version)"></a>Beautiful Bracket Sequence (hard version)</h3><p>题意：括号序列，一些位置可以自己填，定义贡献为删掉一些后最长匹配，求所有方案之和 题目要求的是删掉一些后的括号匹配，那么直接从左到右，从右到左扫就好了。枚举中点，令两边恰好有某个个数的括号即可。 记一个Trick：$\binom nm m=\binom{n-1}{m-1}n$</p>
<h3 id="LCC"><a href="#LCC" class="headerlink" title="LCC"></a>LCC</h3><p>题意：一个点可以往两边走。定义答案为最小的相遇时间，求期望 之前做过。考虑枚举答案在哪里产生，求概率。那么它的概率就是，在某时刻后碰撞减去当前碰撞。 考虑如何求某时刻后碰撞的概率：把某时刻前可能碰撞的方案都删掉，之后DP一下。可以用线段树维护DP。</p>
<h3 id="Game-Relics"><a href="#Game-Relics" class="headerlink" title="Game Relics"></a>Game Relics</h3><p>题意：抽卡有代价，保底有代价，如果抽到已经有的，返钱。保底价格一定高于抽卡。求期望 可以发现因为抽卡更便宜，先抽一会比较优秀。我们无法控制抽卡的走向，于是计算每一种情况的贡献。 注意到抽卡越来越贵。那么求出每种状态（数量，和）的概率后，求它转移到多一个数量的期望。要么抽卡，要么把后面的全买上。全买不好表示，可以加一个平均数。因为后面都是买，就对了</p>
<h3 id="Mergesort-Strikes-Back"><a href="#Mergesort-Strikes-Back" class="headerlink" title="Mergesort Strikes Back"></a>Mergesort Strikes Back</h3><p>题意：归并排序，钦定了只能递归几层。求逆序对期望 考虑先把每一块求出来，之后算两块之间的贡献。 一块内的好算，只需要算两块。注意到两块的本质是划分成下降子段后，对段头排序。考虑随机状况下的期望：1/2。在新的排序方法下，还是随机的，只不过有特殊情况：一个点是max时，不可能有贡献。于是期望就是$\frac{1}{2}-\frac{1}{i+j}$。 注意到叶子只有两种，枚举就可以了</p>
<h3 id="Mr-Kitayuta’s-Gift"><a href="#Mr-Kitayuta’s-Gift" class="headerlink" title="Mr. Kitayuta’s Gift"></a>Mr. Kitayuta’s Gift</h3><p>题意：给一个串，长度是200。添加1e9个字符使得它是回文的，求方案，要求回文串本质不同 跪了。。注意到本质不同，那么考虑尽量把串往外匹配确保唯一 令$f_{l,r,i}$表示$l,r$没匹配，一共用了$i$个字符的方案数。 那么对两端是否相同分类讨论。可以DP。 考虑构造自动机，并DP。复杂度没变。 考虑压缩自动机：对两端是否相等的路径分类讨论。发现类型相同的点转移相同，于是顺序无关。那么本质不同的路径只有n条。压成n条路径。 发现复杂度还是很高，继续压缩：构造两排点，之间连边即可。把路径数放在两种点之间的边。矩乘。 注意到当幂是奇数时，最后一步如果要消去两个点，则不可能。所以奇数时再算一下减去即可。</p>
<h3 id="龙与地下城"><a href="#龙与地下城" class="headerlink" title="龙与地下城"></a>龙与地下城</h3><p>题意：正态分布，求期望。 考虑一种多项式做法：构造一个正态分布的函数，求幂即可。但是复杂度很高，考虑优化： 注意到正态分布两边的值很小，只需要每次把边界的数直接删掉即可。</p>
<h3 id="无意识之外的捉迷藏"><a href="#无意识之外的捉迷藏" class="headerlink" title="无意识之外的捉迷藏"></a>无意识之外的捉迷藏</h3><p>题意：DAG上博弈，一个人抓另一个人。两人操作是同时的。求抓住的期望时间 考虑DP：$f_{x,y,t}$。但是问题是，不一定存在最优解。因为操作同时，只能把策略变成更倾向于某一种操作。这个问题可以用线性规划解决，但是不会。</p>
<h3 id="国际象棋"><a href="#国际象棋" class="headerlink" title="国际象棋"></a>国际象棋</h3><p>考虑主元法：把上方2行，左边1行看作未知数，就可以表示每个格子了。</p>
<h3 id="RNG-and-XOR"><a href="#RNG-and-XOR" class="headerlink" title="RNG and XOR"></a>RNG and XOR</h3><p>题意：初始为0，每次有概率变成其它数，求变成每个数的期望次数。 列出高斯消元的式子，之后移项，发现求逆就可以。但是问题是有$0$，那么待定系数求解。</p>
<h3 id="Good-Contest"><a href="#Good-Contest" class="headerlink" title="Good Contest"></a>Good Contest</h3><p>题意：APIO那个DP题同款 根据套路，左闭右开离散化，之后DP就好了</p>
<h3 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h3><p>题意：初始坐标在$1500$内，走$1500$步，不能走到距离原点曼哈顿距离是$4$的地方，求方案数。 考虑求出$t$步，第一次碰到边界的方案数：考虑到合法的点只有$16$个，直接暴力设状态暴力转移即可。要解决的唯一问题就是，走若干步，从一个点走到另一个点的方案数。 考虑旋转坐标系，之后就转化为了两维独立，且每一维都要走。就可以算了</p>
<h3 id="Count-Modulo-2"><a href="#Count-Modulo-2" class="headerlink" title="Count Modulo 2"></a>Count Modulo 2</h3><p>题意：$200$种元素，选$1e18$个，使得和等于$s$。求方案数模$2$。 考虑记录每种元素选了多少。考虑模$2$：每种元素选的个数都要是$n$的子集，且不交。 那么枚举$n$的每一位，选一个数上来。 注意到，此时选的数$\geq 2^i$，那么说明比这一位低的位，必须在模意义下与$s$相同。也就是说，上一次DP出的结果，只有一部分可以转移到这一位。 那么在DP后，把符合条件的移一位就可以了。</p>
<h3 id="ColoringBalls"><a href="#ColoringBalls" class="headerlink" title="ColoringBalls"></a>ColoringBalls</h3><p>题意：给定操作序列，对空白序列染色。染色时，可以在之前的基础上染。但是特别的，蓝色不能在空白的上染。求最终序列数。 考虑合法序列条件：把相同颜色缩起来之后，用白色分割序列。每一段独立。 考虑一段有若干蓝色，那么一定形如RBRBRBRB…。要想染出这样的形状，需要一次红色一次蓝色，后面就可以任意了。 那么考虑DP这个蓝色数量。把70划分一下，发现方案数是不多的。贪心匹配即可。 考虑计算方案：首先多重排列，之后计算给定蓝色，对应多少合法序列： 考虑最简序列，之后在最简序列中插一些点进去。首先，有一些球已经钦定了，不能用。考虑去重后最长序列样式唯一。那么用剩下的球插出这个序列即可。</p>
<h3 id="Everything-on-It"><a href="#Everything-on-It" class="headerlink" title="Everything on It"></a>Everything on It</h3><p>题意：求子集族方案数，满足每个元素至少出现$2$次。 考虑容斥，钦定$i$个出现了$1$次。那么问题就变成了怎么求有多少出现了$1$次。 首先钦定一共分入了$j$个子集族。那么考虑加一个垃圾堆，就可以求出方案数。 剩下的$n-i$个数，瞎选有$2^{2^{n-i&#125;&#125;$种方案。考虑前面的$j$个子集族，子集可以随便往里面加，那么再乘$({2^{n-i&#125;&#125;)^j$。</p>
<h3 id="某个套路求和题"><a href="#某个套路求和题" class="headerlink" title="某个套路求和题"></a>某个套路求和题</h3><p>题意：n的约数的mu之积，求前缀和 考虑上面式子的含义：没有平方因子的才有值，并且值是1，特别的，质数是-1。那么求一下没有平方因子的，和质数有多少就可以了</p>
<h3 id="LOJ某比赛-求和"><a href="#LOJ某比赛-求和" class="headerlink" title="[LOJ某比赛] 求和"></a>[LOJ某比赛] 求和</h3><p>题意：求$\sum_{i=1}^n \sum_{j=1}^m \mu^2(gcd(i,j))$，数据范围$10^{13}$ 考虑枚举gcd，反演，就变成了$\sum_{i=1}^n \sum_{di} \mu^2(d)\mu(i/d)$ 考虑后面的式子：首先$i$的约数最多幂是$2$，否则就只能是$0$。 考虑幂是$2$的，一定是平均分配，对乘对贡献是$1$。 考虑幂是$1$的。把它拿出来，剩下的式子写出来，再考虑把它插回去。发现插在两边抵消了。 于是只有是完全平方数的时候才有值，就可以化简</p>
<h3 id="二分图染色"><a href="#二分图染色" class="headerlink" title="二分图染色"></a>二分图染色</h3><p>题意：完全二分图，可以空着或者染两种颜色，要求同色不共用点 考虑转化为网格图，之后就是一行一列只能放一种颜色。考虑两种方案分别算，乘一下，减去共用格子的。枚举共用格子容斥。 问题是如何求方案数：考虑$f_n$，新加入一行一列。只考虑行，向之前连边，如果已经有边就断开连列。那么方案唯一。对列也做一次。 问题是可能有重复，前面的每对点都有贡献，减去。 $$f_{n}=2nf_{n-1}-(n-1)^2f_{n-2}$$</p>
<h3 id="Misaka-Network-与求和"><a href="#Misaka-Network-与求和" class="headerlink" title="Misaka Network 与求和"></a>Misaka Network 与求和</h3><p>$\sum_{i=1}^n\sum_{j=1}^n f(gcd(i,j))^k$，其中$f$表示次大因子。 考虑一波反演，问题转化为了求$\sum_{dn}f(d)^k\mu(n/d)$。 考虑杜教筛：卷一个$I$，$\mu$就没了。问题转化为求$f(i)^k$前缀和。 考虑min25筛：$S(n,j)$表示因子不小于$j$。那么分类讨论贡献在哪里产生。 min25筛的时候，分类讨论：在状态$S(n,j)$，钦定第二大因子在这里产生的方案，就是比$p_j$大的质数乘$p_j$。剩下的直接加就好了。 以及，看freopen的博客冷静了一下，其实化简到一半的时候有个$\varphi$，直接筛也行…</p>
<h3 id="蒜头的奖杯"><a href="#蒜头的奖杯" class="headerlink" title="蒜头的奖杯"></a>蒜头的奖杯</h3><p>题意：$\sum_{i,j,k}A_iB_jC_kD_{(i,j)}E_{(j,k)}F_{(i,k)}$ 丧心病狂题。考虑先枚举$k$，顺便枚举$(j,k),(i,k)$。因为$k$的范围与$lcm$有关，就缩小到了能看的范围。 枚举两个gcd的gcd，后面可以算。经过大力推倒，可以得到一个复杂度与$x$或$y$有关的式子。那么钦定$x \leq y$，就可以大力枚举。 注意高维前缀和的技巧：枚举质数</p>
<h3 id="Ribbons-on-Tree"><a href="#Ribbons-on-Tree" class="headerlink" title="Ribbons on Tree"></a>Ribbons on Tree</h3><p>题意：树上点对配对，把路径染色。求整个树都有颜色方案 考虑容斥，枚举联通块，求方案数。方案数就是块内点两两配对，即$n!!$。 但是不能枚举，考虑优化过程：直接DP，并动态记录。注意到数据范围不大，可以考虑DP时记录当前联通块有多大。</p>
<h3 id="Two-Histograms"><a href="#Two-Histograms" class="headerlink" title="Two Histograms"></a>Two Histograms</h3><p>题意：行列可以贴着两个边界+1，求本质不同方案数。 之前做过，写了个**。 考虑什么时候会重复：两条顶住了。那么考虑钦定其中一种顶法有$i$条，剩下的随便，目标是把它容斥没。 考虑$i$条方案：$f_i=(m+1)^{n-i}(n+1)^{m-i}\binom{n}{i} \binom{m}{i}i!$</p>
<h3 id="「CodePlus-2018-4-月赛」Tommy-的结合"><a href="#「CodePlus-2018-4-月赛」Tommy-的结合" class="headerlink" title="「CodePlus 2018 4 月赛」Tommy 的结合"></a>「CodePlus 2018 4 月赛」Tommy 的结合</h3><p>题意：树上斜率优化。 做法：写的倍增飞了。。发现二分其实也挺好写的。。。 核心思想如下：考虑二分出弹栈弹到哪里。具体来说，二分最靠前的，不能用的位置，把它替换成新的。注意到这事实等价于两个操作：修改栈的一个位置，移动右端点。于是可以维护。询问也二分，二分最靠前的满足条件的位置即可。</p>
<h3 id="Hyperrectangle"><a href="#Hyperrectangle" class="headerlink" title="Hyperrectangle"></a>Hyperrectangle</h3><p>题意：超立方体，求和到原点$\leq s$的单纯性的体积 首先考虑没有每一维的限制的答案：考虑积分，首先二维可以求出。之后迭代的对每一维积分，可以发现答案是$\frac{1}{d!}s^d$ 那么每一维有限制，就考虑容斥。钦定一组超过限制，那么把$s$减去它们的和，求一下。这样的原因是我们需要减去多余的面积，那么钦定一些维超过，求得的面积就是多余的。 具体来说，令$f_i$表示，之后$f_i = f_i - f_{i-A}$，求容斥系数就可以了。</p>
<h3 id="Rigid-Frameworks"><a href="#Rigid-Frameworks" class="headerlink" title="Rigid Frameworks"></a>Rigid Frameworks</h3><p>题意：给一个网格，可以在每个格子加斜对角线，要求网格稳定。求方案数 考虑什么时候稳定：事实上和方向无关，只需每行每列都有就行了。于是转化为二分图，要求联通，方案数。根据套路枚举第一个点联通块即可</p>
<h3 id="World-of-Tank"><a href="#World-of-Tank" class="headerlink" title="World of Tank"></a>World of Tank</h3><p>题意：$2 \times n$的矩形，坦克从一端走到另一端，可以绕路可以开炮，炮有冷却，求方案 考虑到达一个点后有关的是当前冷却了多久，越久越好。注意到冷却完毕后，如果不绕路，应该立即开炮。那么在一行走哦的时候，可以把时间累加起来，高于冷却上限，但是转弯的时候必须求min。又注意到有用的点不多，离散DP就行了</p>
<h3 id="The-Tree"><a href="#The-Tree" class="headerlink" title="The Tree"></a>The Tree</h3><p>题意：三种操作，从白点染色，如果没染，递归子树。子树染白。单点询问 考虑操作分块：之后在虚树上暴力。或者树剖，一个点被染色，那么祖先存在一个点，权值到它比距离大。考虑子树推平：首先清零，之后如果祖先的max还会染到，把x点减少一些权值。</p>
<h3 id="Iron-Man"><a href="#Iron-Man" class="headerlink" title="Iron Man"></a>Iron Man</h3><p>题意：树，给若干路径，有时间，速度，起点终点。求最小相遇时间 考虑链怎么做：枚举，求交点。这个太慢，优化：如果两个线段相交，那么必然有它们的起点是相邻的。扫描线。树上树剖就行了</p>
<h3 id="Holy-Diver"><a href="#Holy-Diver" class="headerlink" title="Holy Diver"></a>Holy Diver</h3><p>题意：每次序列后push一个值，再给定l，r，求区间的子区间mex和。 维护右端点的mex：加入点后，受影响的是mex=a的区间。把它丢掉，之后更新。对于答案，用线段树维护。具体来说，$l,r$的答案=$r$版本线段树的答案。因为当前只有一段有效，一次修改，首先把上次的删掉，贡献为持续时间。之后更新当前区间，两种贡献：区间长度，区间长度乘起始时间。永久化标记解决。 描述一下怎么更新mex：考虑加入数字$a$，那么找出一个数满足大于$a$，且上一次出现位置在$r$之前。那么$[p,r]$的$mex$就是它。多次重复即可。</p>
<h3 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h3><p>题意：给定A点B点，定义路径权值为路径max-min，定义A点权值为它到B点的权值max。定义答案为A点权值min。现在可以反转一个A变成B，求最大答案 首先求出不反转的答案。考虑点分，之后拼接答案。因为只关心极值，所以直接记录子树的权值区间$[L,R]$，以及次优值。之后可以拼接。 考虑反转一个点，之后点分树上跑一下，更新答案。二分答案，判断反转后是否还存在小于答案的点。这个可以通过分类讨论得到。 代码没写，咕咕咕</p>
<h3 id="A-Sequence-of-Permutations"><a href="#A-Sequence-of-Permutations" class="headerlink" title="A Sequence of Permutations"></a>A Sequence of Permutations</h3><p>题意：给两个排列，定义递推，下一个是$f(p,q)$，表示第$p_i$个元素为$q_i$。 $a_{p_i}=q_i,a_{i}=q_ip^{-1}_i$。后面是找规律，这个我也没办法了</p>
<h3 id="Synchronized-Subsequence"><a href="#Synchronized-Subsequence" class="headerlink" title="Synchronized Subsequence"></a>Synchronized Subsequence</h3><p>题意：序列，只有$a,b$，数量相等，一对可以一起删，最大字典序。 考虑从两种相等的位置断开，考虑每一段：如果$a$开头，贪心选$ab$。如果$b$开头，考虑多选$b$肯定优秀，但是不一定每个$b$都要选：比如$bbbabbbbb$，那么不选第一个$b$比较好。假设知道了第一个$b$是谁，后面的$b$都要选，枚举判断。</p>
<h3 id="APIO2017-斑斓之地"><a href="#APIO2017-斑斓之地" class="headerlink" title="[APIO2017]斑斓之地"></a>[APIO2017]斑斓之地</h3><p>题意：网格图联通块 老套路：一个点-两个点+四个点。</p>
<h3 id="Distance-Sums"><a href="#Distance-Sums" class="headerlink" title="Distance Sums"></a>Distance Sums</h3><p>题意：给定每个点到其它点的最短路，复原这个树 首先最大值对应的是叶子，考虑求它连着的边。事实上是可以从一个点推出另一个点答案的。所以就推一下连着的点是多少，连上就行了。 注意最后要check一下答案。</p>
<h3 id="CF1336D-Yui-and-Mahjong-Set"><a href="#CF1336D-Yui-and-Mahjong-Set" class="headerlink" title="CF1336D Yui and Mahjong Set"></a>CF1336D Yui and Mahjong Set</h3><p>题意：交互，可以求$\sum \binom{a_i}{3}, \sum a_{i-1}a_ia_{i+1}$，可以单次$+1$，可以操作$n$次，求每个位置 考虑先把$3,n-1$操作一下，之后求出$1,2,3,4$，就知道答案了。进行$121$这样的操作即可。</p>
<h3 id="WC2018-战略游戏"><a href="#WC2018-战略游戏" class="headerlink" title="[WC2018] 战略游戏"></a>[WC2018] 战略游戏</h3><p>题意：交互，可以询问$(x,y)$，返回从$x$出发往$y$走第一个碰到的点。$nlogn$次确定答案 考虑如果走过，就跳到目标点。但是可能跳过，考虑一层一层的跳，点分树优化。动态点分即可，注意动态点分重构时，父亲会改变。</p>
<h3 id="势函数和鞅的停时定理"><a href="#势函数和鞅的停时定理" class="headerlink" title="势函数和鞅的停时定理"></a>势函数和鞅的停时定理</h3><p>我也不知道是啥，记个做法： 期望步数的题，对于状态记录势函数$\varphi(A_t)=\sum_i f(A_{t,i})$。考虑推出$A_{t+1}$。发现可以列一个等式。 势函数需要满足走一步值$-1$，通过这个，可以求出$f$的形式。</p>
<h3 id="数树"><a href="#数树" class="headerlink" title="数树"></a>数树</h3><p>题意：给定一个树，另一个不确定，求$\sum y^k$，其中k是交集大小。再求两个树都不确定的。 首先考虑钦定一个相同集合，再求方案。那么可能会有更多边相同。但是考虑钦定一个集合$s$，会被算多少：会被子集合$t$算到。考虑贡献：$\sum y^i \binom ni$，所以把$y-1$之后直接算就行了。 之后考虑DP：$f_{x,0/1}$表示集合内是否选了点。 两个的：钦定相同集合，大小一样的一起算。可以写成EXP的形式。$\sum_{\sum a_i=n} \prod a_i$这样的式子。</p>
<h3 id="随机立方体"><a href="#随机立方体" class="headerlink" title="随机立方体"></a>随机立方体</h3><p>题意：立方体，一个点是优秀的，则和它相交的三个平面上的值都小于他。求有恰好k个优秀点方案 考虑转化为至少，那么钦定k个点，并钦定一些数分给它的并集，再乘一下分配方案数 考虑分配方案数：把关键点从小到大放，发现放大关键点的时候，小关键点用到的值，都满足新的限制。于是可以转化为一个树，树的拓扑序方案就是全排列，除以每个子树大小的逆元</p>
<h3 id="氪金手游"><a href="#氪金手游" class="headerlink" title="氪金手游"></a>氪金手游</h3><p>题意：一个人有三种值，是随机的。选一个点概率是$w_i / w_{sum}$给一个树，边有方向，要求指向的比起点选中更晚，求方案 首先变成外向树并DP，对于其它方向，容斥掉 考虑一条链，则一个点在它后面之前被选概率，等于$w_i / w_{son}$，之后树形DP。</p>
<h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p>题意：给定串$S$，求有多少$T$，满足$T$复制无限份后，存在一个子串字典序比$S$小。 首先转化一下求不存在。考虑把$S$的KMP自动机搞出来，在上面跑。一个点的出边有一些是不能用的，具体来说，是fail树上的max。 有一个这样的性质：在跑无穷多次后，会循环，且循环节是$m$的约数。 证明：冷静了一下有一种简单的理解：考虑匹配到的是S的前缀，T的后缀。当长度为无穷的时候，加一个还是无穷，没有变化，所以循环长度不可能是倍数。 那么考虑不同的T串，走出的循环路一定不同，那么只需对循环计数。具体来说，令$f_{i,j}$，表示走$i$步，走到$j$的方案即可。 但是复杂度不太对劲，考虑优化：考虑每个点的出边，可以发现一定是前缀的max。那么也就是说，一个点最多有一个不跑回起点的出边，且一定存在。 考虑一个满足题目要求的T：它的路径是$\rho$形的。如果不经过根，考虑环：如果环的大小是$m$的约数，则贡献为环的大小。（考虑环的每种拆分，因为环是递增的，路径形如在根绕一会再出去，所以可行） 如果经过根，考虑一个环，是从x点走回根，再走回来，其中走回去的路不能碰到根。那么拆开DP即可。</p>
<h3 id="「JOISC-2017-Day-1」烟花棒"><a href="#「JOISC-2017-Day-1」烟花棒" class="headerlink" title="「JOISC 2017 Day 1」烟花棒"></a>「JOISC 2017 Day 1」烟花棒</h3><p>题意：每个人可以左右跑，两个人在一起的时候可以选择点燃另一个人，一开始一个人有火，T时间后熄灭，要把所有的都点着，求最小速度 二分速度后求解。考虑两个人相遇后，最优方案：应该是一个人熄灭的时候再点另一个人。那么发现原问题等价于碰到每个人时间+T，要碰每个人。那么考虑把人合并为若干对$(x,y)$，表示需要代价$x$才能进，出来后加$y$的时间。 合并后贪心，如果消完就没了，否则把序列剩下的全加上，把对看作需要退若干代价进去，出来后加一些，再贪心一次。</p>
<h3 id="APIO2018-选圆圈"><a href="#APIO2018-选圆圈" class="headerlink" title="[APIO2018] 选圆圈"></a>[APIO2018] 选圆圈</h3><p>题意：若干圆，每次操作选最大圆把相交的都删掉，求被谁删 正解的姿势：考虑可能消除一个圆的圆：最多有四个，且与这个圆四边界的直线相交。那么扫描线就行了。或者KD树？</p>
<h3 id="APIO2018-新家"><a href="#APIO2018-新家" class="headerlink" title="[APIO2018] 新家"></a>[APIO2018] 新家</h3><p>题意：每个东西有属性：类型，出现时间段，位置。询问某时间某位置，每种类型距离min的max 排序一下，上个二分答案：只需区间询问出现次数 考虑一种值在$[l,r]$如果没有出现，那么它在$r$后第一次出现的pre就$&lt;l$。于是维护min pre即可</p>
<h3 id="APIO2019-奇怪装置"><a href="#APIO2019-奇怪装置" class="headerlink" title="[APIO2019]奇怪装置"></a>[APIO2019]奇怪装置</h3><p>题意：给若干不相交区间，一个位置的值定义为$((t+\lfloor \frac{t}{B} \rfloor) \mod A, t \mod B)$，求有多少对 既然取模，那么循环了：手玩一下可以发现要满足$(B+1)k \equiv 0 \pmod A$，于是应该是$gcd(B+1,A)$。</p>
<h3 id="APIO2019-桥梁"><a href="#APIO2019-桥梁" class="headerlink" title="[APIO2019]桥梁"></a>[APIO2019]桥梁</h3><p>题意：修改边权，求一个点带权出发能到多少点。能到要满足权不大于边权 根号重构暴力DFS即可</p>
<h3 id="APIO2019-路灯"><a href="#APIO2019-路灯" class="headerlink" title="[APIO2019]路灯"></a>[APIO2019]路灯</h3><p>题意：序列$[l,r]$可行仅当区间都是$1$。操作反转或询问一开始到现在有多少时刻联通 直接维护点对答案，发现差分一下后矩形加即可。注意询问时如果还联通着，要减去当前时刻</p>
<h3 id="Easy-win"><a href="#Easy-win" class="headerlink" title="Easy win"></a>Easy win</h3><p>首先有个套路：把边的位置设为1，独立集就是无环图 动态插入的最大线性基的姿势：考虑插入一个新元素。如果能插进去就直接插。考虑维护一个集合，表示当前线性基是由哪些元素搞出来的。对于每个位置维护一下它是这个集合怎么组合出来的。 如果插不进去，考虑把最小的元素换掉。扫过一次之后，得到了当前元素能由哪些组合出来，枚举找一个最小的替换。那么我们可以理解我们用一个集合代替了之前的一个元素，于是枚举集合中的所有元素，xor上当前元素的集合。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">130</span>;</span><br><span class="line">std::bitset&lt;N&gt; A[N], B[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans, w[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">bool</span> ins[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(std::bitset&lt;N&gt; a, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  std::bitset&lt;N&gt; b;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">128</span>; ~i; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!a[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (!ins[i]) &#123;</span><br><span class="line">      ins[i] = <span class="number">1</span>;</span><br><span class="line">      ans += v;</span><br><span class="line">      w[++cnt] = v;</span><br><span class="line">      b[cnt] = <span class="number">1</span>;</span><br><span class="line">      A[i] = a;</span><br><span class="line">      B[i] = b;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      a ^= A[i];</span><br><span class="line">      b ^= B[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">    <span class="keyword">if</span> (b[i] &amp;&amp; (pos == <span class="number">-1</span>  (w[i] &lt; w[pos])))</span><br><span class="line">       pos = i;</span><br><span class="line">  <span class="keyword">if</span> (~pos &amp;&amp; v &gt; w[pos]) &#123;</span><br><span class="line">    ans += v - w[pos];</span><br><span class="line">    w[pos] = v;</span><br><span class="line">    b[pos] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">128</span>; ~i; --i)</span><br><span class="line">      <span class="keyword">if</span> (ins[i] &amp;&amp; B[i][pos])</span><br><span class="line">        B[i] ^= b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WC2019-I君的商店"><a href="#WC2019-I君的商店" class="headerlink" title="[WC2019]I君的商店"></a>[WC2019]I君的商店</h3><p>考虑权值相等的时候随便返回一个东西，其实就是把小于变成小于等于。 考虑如果已知序列形如11111…110000…000怎么做：直接二分分界点即可。 考虑不是这样怎么做：维护三个指针a,b,c，先比较一下令a&lt;=b，再比较a+b和c的大小：要么a=0，要么b&gt;=c。于是可以得到若干0和一条偏序链。二分即可</p>
<h3 id="NOI2019-I君的探险"><a href="#NOI2019-I君的探险" class="headerlink" title="[NOI2019]I君的探险"></a>[NOI2019]I君的探险</h3><p>考虑树，且父亲比自己小：二分mid，把之前的都改一下，查自己的值。整体二分即可 考虑一般图：随机排列做上面的操作即可。复杂度不太会证，反正能过</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>杂题乱做1</title>
    <url>/2020/08/24/%E6%9D%82%E9%A2%98%E4%B9%B1%E5%81%9A/</url>
    <content><![CDATA[<p>退役前给自己看的，删了一些东西放出来了，有兴趣可以看看</p>
<hr>
<h3 id="cf674g"><a href="#cf674g" class="headerlink" title="cf674g"></a>cf674g</h3><p>考虑维护出现次数超过一半的数的方法：维护当前数，当前数出现次数，遇到一样的+1，否则-1，次数变为0的时候改数。 这种方法可以推广到更多数。考虑维护一些这样的(数，次数)对，对于新数，如果在维护的集合内出现过，直接+1，否则如果集合大小&lt;k，把这个对加入集合，不然把集合内所有对-1，清空为0的对。 这种操作可以用线段树维护。合并两个节点，枚举其中一个集合插入另一个集合。如果某次减的操作会减出负数，就交换集合内最小的数和当前插入的数，然后把集合内最小的数插回来，这样一定没有负数。</p>
<h3 id="arc103-f"><a href="#arc103-f" class="headerlink" title="arc103_f"></a>arc103_f</h3><p>构造题。考虑找出重心，叶子的D最大，知道一个点的D可以求出父亲的D。注意构造完后用根check一下，因为构造过程不考虑父亲合法性。</p>
<h3 id="cf1270g"><a href="#cf1270g" class="headerlink" title="cf1270g"></a>cf1270g</h3><p>$i - n \leq a_i \leq i - 1$，即$ 1 \leq i - a_i \leq n $，$i - a_i$构成基环树，树上的环就是解。</p>
<h3 id="cf1270h"><a href="#cf1270h" class="headerlink" title="cf1270h"></a>cf1270h</h3><p>这个写这里了<a href="https://baka.online/cf1270h-number-of-components-%e7%ba%bf%e6%ae%b5%e6%a0%91/">https://baka.online/cf1270h-number-of-components-%e7%ba%bf%e6%ae%b5%e6%a0%91/</a></p>
<h3 id="AGC034F"><a href="#AGC034F" class="headerlink" title="AGC034F"></a>AGC034F</h3><p>令$f,p$分别为期望步数，概率，有： $$f_i = \sum_{j &lt; 2^n } p_j f_{i \oplus j} + 1 $$ 这个方程显然可以用高斯消元解，不过很慢… 把$+1$移到左边，写成集合幂级数： $$(f_0, f_1, … f_{2^n - 1}) \oplus (p_0, p_1, … ,p_{2^n - 1}) = (f_0 + 2^n - 1, f_1 - 1, f_2 - 1 , … , f_{2^n - 1} - 1)$$ 右边$f_0 - 1$的位置被换成了$f_{0} + 2^n - 1$，是因为在方程中没有定义。又因为$\sum p = 1$，可以知道左边和右边的$\sum f$相等。 那么可以推出： $$(f_0, f_1, … f_{2^n - 1}) \oplus (p_0 - 1, p_1, … ,p_{2^n - 1}) = ( 2^n - 1, -1, -1 , … , -1)$$ 考虑使用FWT求解。 $$\hat{f}<em>S = \sum</em>{T \subseteq S} f_T (-1)^{ S \cap T } $$ 那么观察到，等号右边的幂级数FWT后，第一项为$0$。这样是不行的。 不过注意到已知$f_0 = 0$，可以考虑假设右边的第一项为$0$，直接FWT求解，再把和$f_0$相差的大小补上即可。</p>
<h3 id="agc030d"><a href="#agc030d" class="headerlink" title="agc030d"></a>agc030d</h3><p>自己YY的DP又挂了。。。令$f_{i,j}$表示$A_i &lt; A_j$的概率，每次交换只影响$O(n)$个位置，就可以简单计算。</p>
<h3 id="cf1286c2"><a href="#cf1286c2" class="headerlink" title="cf1286c2"></a>cf1286c2</h3><p>不限制询问长度的话，就问$[1,n],[1,n-1]$就好了。 限制的时候，令$t= \lceil \frac{n}{2} \rceil$，询问$[1,t],[1,t-1]$，求出$[1,t]$。 考虑令数组$c_{i,j}$表示$i$，在长度为$j$的串中出现次数。对于整个串的前后的$j$个计数，则某元素出现次数为$c_{1,j}-(c_{i+1,j}-c_{i,j})$。那么就可以求出答案了。</p>
<h3 id="cf1286d"><a href="#cf1286d" class="headerlink" title="cf1286d"></a>cf1286d</h3><p>看了好久没看懂。。。最后有了中文题解才懂。。。 容易发现碰撞一定产生在相邻粒子间，那么枚举每对粒子，枚举碰撞方向，计算概率，就可以求出答案。 令$f_{i,0/1}$表示考虑前$i$个，它们不碰撞的概率。 一个Trick：如果某DP的某一维是$0,1$，考虑矩阵。 于是写成矩阵。一开始，所有转移的概率都是存在的，在过程中逐渐有一些转移法不可用了，在矩阵中去掉即可。 按时间排序。 $$E = \sum_{i} p_i t_i = \sum_i (t_i - t_{i - 1}) \sum_{ j \geq i }p_j$$ 线段树维护矩阵，矩阵的积就是$p$，前面的也可以算。 注意可能有根本不会碰撞的情况，最后减掉线段树上剩下的$f t$</p>
<h3 id="cf1284d"><a href="#cf1284d" class="headerlink" title="cf1284d"></a>cf1284d</h3><p>不用想那么多，直接排序，主席树+区间加+标记永久化。</p>
<h3 id="cf1284e"><a href="#cf1284e" class="headerlink" title="cf1284e"></a>cf1284e</h3><p>考虑统计五个点的集合，并求凸包，可以得出答案为$2x_3+x_4$，其中$x$是出现次数。可以求出$x_3+x_4+x_5$。考虑求$3x_3+4x_4+5x_5$，意义为凸包上的边数和。枚举边的一个点，极角排序双指针。</p>
<h3 id="agc035b"><a href="#agc035b" class="headerlink" title="agc035b"></a>agc035b</h3><p>求一棵树，把其它边随便定向，然后DFS树，对每一个点通过改变父亲方向使其合法。发现对于边为偶数，这样一定有解。</p>
<h3 id="agc035c"><a href="#agc035c" class="headerlink" title="agc035c"></a>agc035c</h3><p>$i = 2k, i \oplus i +1 = 1$，那么把$i,i+1,1,i,i+1$串成一条链，是合法的。奇数即得解。如果$n = 2 ^ k$，显然无解，否则一定存在$x \oplus y \oplus 1 = n$，串起来即可。</p>
<h3 id="agc035d"><a href="#agc035d" class="headerlink" title="agc035d"></a>agc035d</h3><p>这个题不是状压。。。我们考虑把删除改成插入，那么考虑在两张卡里插入一张卡，对答案的贡献就是这两张卡被算了多少次乘插入的值。 定义DP$f_{l,r,L,R}$，表示第一次插的是$l,r$这两张，各被算了$L,R$次。 $$f_{l,r,L,R} = \min \lbrace f_{l,k,L,L+R} + f_{k,r,L+R,R} + (L+R)A_k \rbrace$$ 观察可以发现，这个DP的状态数是$O(n^2 2^n)$的。转移复杂度$O(n^3 2^n)$</p>
<h3 id="agc035e"><a href="#agc035e" class="headerlink" title="agc035e"></a>agc035e</h3><p><a href="https://www.cnblogs.com/Tiw-Air-OAO/p/11795339.html">这里有一篇题解</a> 一个Trick：把问题转化为图。用图表示删除$x$后$y$就会被添加这样的关系，那么如果有环，一定不可以。 如果$2 \mid K$，可以发现只要不选超过$\frac{K}{2} $个连续同奇偶的即可。 如果$2 \nmid K$，可以把点按奇偶分成两部分，按照上面那篇题解中的样子摆好。可以发现，如果在左边，右边都选了点（连续环状），且超过$K + 1$个点，一定构成了环。有环是不可以的。 所以用DP求选点，且不构成环的方案数。令$f_{i,j,k,lj,lk}$表示考虑了前$i$层（以右边的数），左边选了$j$个，右边选了$k$个，左右分别有限制$lj,lk$，表示不能选到这个位置。 具体转移<a href="https://blog.csdn.net/qq_39972971/article/details/98472533">看这里</a>。。。彻底蒙了的说。。。</p>
<h3 id="agc035f"><a href="#agc035f" class="headerlink" title="agc035f"></a>agc035f</h3><p>如果存在$k_i = j - 1, l_j = i$，那么可以操作让$k_i + 1, l_j - 1$，结果不变。称不能这么变的为标准形式。 一个标准形式唯一对应一种答案。通过反证可以证明。一个Trick：讨论某种顺序枚举下第一个不同的位置。 然后枚举有几对是那样的，简单容斥就行了。。。</p>
<h3 id="JXOI2017-数列"><a href="#JXOI2017-数列" class="headerlink" title="[JXOI2017]数列"></a>[JXOI2017]数列</h3><p>正着DP，那么需要记录上界，下界，选了什么，然后用前后缀和优化。 但是对于位置$i$依赖于$i-1, &lt; i-1$的DP，可以考虑正着DP，那么就可以无视掉选了什么这一维。 从前向后求解答案，使用记忆化搜索。</p>
<h3 id="SCOI2014-方伯伯的商场之旅"><a href="#SCOI2014-方伯伯的商场之旅" class="headerlink" title="[SCOI2014]方伯伯的商场之旅"></a>[SCOI2014]方伯伯的商场之旅</h3><p>可以分析出，移动到一个位置最优，但是不确定是哪个位置。对于这种问题，可以先移动到一个位置，再进行平移，动态维护答案。</p>
<h3 id="cf1168d"><a href="#cf1168d" class="headerlink" title="cf1168d"></a>cf1168d</h3><p>猜一个结论：对于任意子数，每种字母在每条链上的$\max$之和（即要补充到的大小），不大于深度。可以按层归纳证明。然后简单DP即可。 考虑修改，发现只会在分叉的地方DP，有一个结论，把链缩起来，树深度是$\sqrt n$级别的（$1 + 2 + 3 + …$），所以暴力修改就行了。</p>
<h3 id="SHOI2017-寿司餐厅"><a href="#SHOI2017-寿司餐厅" class="headerlink" title="[SHOI2017]寿司餐厅"></a>[SHOI2017]寿司餐厅</h3><p>碰到选一个，必须选另一个，立马想最大权闭合子图！！！</p>
<h3 id="COCI2019-Quiz"><a href="#COCI2019-Quiz" class="headerlink" title="[COCI2019] Quiz"></a>[COCI2019] Quiz</h3><p>wqs二分，斜率优化优化DP。wqs二分处理整数问题时，可以通过只在整数上二分求答案。但是遇到小数后还是要实数二分的说。 wqs二分中，每次转移都$-mid$，计算答案$+K mid$</p>
<h3 id="SHOI2017-组合数问题"><a href="#SHOI2017-组合数问题" class="headerlink" title="[SHOI2017]组合数问题"></a>[SHOI2017]组合数问题</h3><p>$$\sum_{i} \binom{n}{ik+r} = \sum_i \binom{n}{i} [i \equiv r \pmod k] $$ 这种技巧还是要熟悉的。</p>
<h3 id="JLOI2016-侦查守卫"><a href="#JLOI2016-侦查守卫" class="headerlink" title="[JLOI2016]侦查守卫"></a>[JLOI2016]侦查守卫</h3><p>带权值的树上选点覆盖问题。令$f_{x,i},g_{x,i}$分别表示$x$点向上覆盖$i$，向下$i$还没有覆盖的最小值。注意此处是包含更小的状态的。 转移的时候先计算向上覆盖，方法是讨论选择的点在原来的子树还是新的子树内。然后计算向下覆盖，这个加上子树的即可。</p>
<h3 id="JLOI2016-成绩比较"><a href="#JLOI2016-成绩比较" class="headerlink" title="[JLOI2016]成绩比较"></a>[JLOI2016]成绩比较</h3><p>有难度的计数题。分数可以选，这个比较难处理，所以把分数分开。分别计算选人和排名的方案数，与分数分配的方案数。 令$f(x),g(x)$表示至少，正好$x$人被踩。 $$f(x) = \binom{n - 1}{x} \prod_i \binom{n - x - 1}{r_i - 1}$$ $$f(x) = \sum_{i=x}^{n-1} \binom{i}{x} g(x) $$ $$g(x) = \sum_{i=x}^{n-1} \binom{i}{x} (-1)^{i-x} f(x)$$ 在需要对集合选取一个子集，满足某种性质时，对于一个更大的集合包含的小集合，选取小集合的方案要乘上大集合元素中选一部分为小集合的方案。 计算分数，枚举B神的分数，对于每科分别计算乘起来就行。 $$\sum_{i=1}^{u} n^{n - r} (u-i)^{r-1} $$ 这个式子不用简化。因为次数不高，直接算$n+1$个值，然后拉格朗日插值即可。</p>
<h3 id="一道考试题"><a href="#一道考试题" class="headerlink" title="一道考试题"></a>一道考试题</h3><p><a href="https://blog.csdn.net/hzj1054689699/article/details/80051184">题在这里</a> 题目所求可以转化为减之前与之后所有数的积的期望差。 计算减之后的期望： $$\frac{ 1 }{n^k} \sum_{\sum b_i = k} \frac{k!}{b_i!} \prod(a_i - b_i) ) = \frac{k!}{n^k} \sum \prod \frac{a_i - b_i}{b_i!} $$ 这道题告诉我们，当一个式子长得像生成函数，那么她就是生成函数 定义指数生成函数$F_i(x)$ $$F_i(x) = \sum_{j=0} ^ {\infty} \frac{A_i - j}{j!} x^j = \sum \frac{A_i x^j}{j!} - x \frac{x^{j-1&#125;&#125;{(j-1)!} = e^x (A_i - x) $$ 可知答案为 $$ \frac{k!}{n^k} \sum_{i=0}^k (\prod F_i) [x^i] \frac{n^{k-i&#125;&#125;{(k-i)!} $$ 分治NTT求一下卷积，化一下式子。</p>
<h3 id="JZPTREE"><a href="#JZPTREE" class="headerlink" title="JZPTREE"></a>JZPTREE</h3><p>对于求$\sum n^k$的问题，可以考虑使用第二类斯特林数。 $$n^k = \sum_{i=0}^k S(k,i) n^{\underline i} $$ $$(x+1)^{\underline i} = (x-j+j+1)x^{\underline {i - 1&#125;&#125; = x^{\underline i} + i x^{\underline {i - 1&#125;&#125;$$</p>
<h3 id="SHOI2008-cactus仙人掌图"><a href="#SHOI2008-cactus仙人掌图" class="headerlink" title="[SHOI2008]cactus仙人掌图"></a>[SHOI2008]cactus仙人掌图</h3><p>对于仙人掌上问题，首先考虑圆方树。方点是和环有关的，对于一类与距离有关的题，可以把和方点边权设为和方点父亲的最长/最短距离。 一个月后的更新：然后做就行了。DP什么的。</p>
<h3 id="一道奥妙重重的计数题"><a href="#一道奥妙重重的计数题" class="headerlink" title="一道奥妙重重的计数题"></a>一道奥妙重重的计数题</h3><p>$n,m,k, m \leq k \leq n$，表示$1$到$n$的排列，考虑选$k$个元素的所有子集。把它们内部按元素大小排序，然后再按字典序排序，求： $$\sum A_{i,m} - A_{i+1,m} $$ 做法： 考虑相邻两个排列第一个不同的位置，发现肯定是$x$和$x+1$。 枚举$x$，再枚举$j$，表示这个位置在$j$。 把两个排列写出来，发现一定长这样： $$…,x,n-(k-j)+1,…,n$$ $$…,x+1,x+2,x+3,…$$ 分类讨论，当$j &lt; m$时，贡献由后面的差决定，当$j=m$时，贡献为$1$。可以求出答案的式子： $$\sum_{x=1}^n \sum_{j=1}^{m-1} \binom{x-1}{j-1} n-k-1-(x-j) + \sum_{x=1}^n \binom{x-1}{m-1}$$ 枚举$i=x-j$。后面那个$\sum$很好求，下面只考虑前半部分 因为$x-j=i,j=x-i \leq m - 1$，可以知道$x \leq m + i - 1$ $$\sum_{i=？}^{?？} n-k-1-i \sum_{x=i+1}^{m+i-1} \binom{x-1}{x-i-1} $$ $$\sum_{x=i+1}^{m+i-1} \binom{x-1}{x-i-1} = \sum_{x=0}^{m-2} \binom{x+i+1}{x} = \sum_{x=0}^{m-2} \binom{x+i+1}{i+1}$$ 运用组合恒等式： $$\binom{m+i-1}{m-2}$$ 那么上文中的$?$是多少呢？ 可以发现，为了使$\binom{x-1}{j-1}$有意义，有$x-j \geq 0$，且$x, j \geq 1$。注意到，$x$那个排列后面为一串递增的数，直到$n$，那么$x \leq n - k$。 所以，$0 \leq x - j \leq n - k - 1$。</p>
<h3 id="bzoj3864"><a href="#bzoj3864" class="headerlink" title="bzoj3864"></a>bzoj3864</h3><p>陈老师的DP套DP题。大概是这样的：一个DP可以读入一串东西，输出一个东西。现在要统计输出的这个东西对应的输入有多少。那么考虑把那个“一个DP”的DP状态，放进新的DP里面。 拿这个题举例子，两个串匹配。枚举T，那么可以定义DP$f_{i,j}$表示T和S分别匹配到了$i,j$。发现确定$i$，对于$j$的变化，$f$最多上升$15$次。那么状压这个差分数组，就相当于储存了DP的状态，做一个DP就行了。</p>
<h3 id="CF611H"><a href="#CF611H" class="headerlink" title="CF611H"></a>CF611H</h3><p>有一种很厉害的做法：在每种长度中钦定一个点做关键点，可以证明可以构造一种方案，关键点连通，剩下的点挂在关键点上。那么枚举关键点的形状，对剩下的部分做一个网络流。 不过还有一种更厉害的做法： 钦定1为根，考虑一个一个扩展。钦定从长度i扩展，找一个长度j，判断可不可以在i到j中间连一条边。 实际上如果题目输入了i，j这条边，就为答案提供了两种可能：两种方向。这个非常二分图。 考虑建一张二分图：左边为所有的连边方案（即i到j这样），右边为所有长度。如果存在完美匹配，则存在解。 判断ij这条边，先在二分图中删掉它，然后判断是否仍然存在完美匹配。用Hall定理。 貌似想明白了，做题。。然而发现貌似左边的点很多啊，不是很能枚举子集。相反右边很可枚举的样子。 观摩了代码，发现解决方法是：已知左边的流量=右边-1，那么右边的一个子集一定流量&lt;=左边，代表着可以匹配。那么枚举右边的子集判断就行了。 其实我不知道这个对不对。。。</p>
<h3 id="agc024f"><a href="#agc024f" class="headerlink" title="agc024f"></a>agc024f</h3><p>枚举子串，求出现次数。定义状态$(S,T)$表示已经匹配了$S$，还剩下没被匹配的部分是$T$，的方案数。 对于一个输入的串$T$，初始状态为$(\phi,T)$，最终要被匹配到$(S,\phi)$，则$T$对$S$产生了贡献。 直接DP出所有的$(S,\phi)$。本题代码很难写。。需要大量实现技巧，列举在下面： 状态是两个数，注意到两个数总长度不超过n，可以记录成一个大数加上一个分界点。 h[s]表示s的最高位1在哪里。h[0]=-1，h[s]=h[s&gt;&gt;1]+1。 需要预处理在$T$里匹配一个字符后到了哪里。注意到不同长度的状态二进制表示可能不同，需要在最高位上加一个1，表示长度。 令v=s和t拼接起来的状态。在转移的时候，从f[i][v]转移到f[t拼一个数的长度][新s拼新t] 注意到当转移0的时候，s后面接一个0，转移1的时候，s后面接1。而从v中取出t后要在t后面手动加上最高位来做。 那么可以转移0的时候给s加1，转移1的时候给s加0，和新的t直接xor，就可以抵消掉这一位。</p>
<h3 id="CF840C"><a href="#CF840C" class="headerlink" title="CF840C"></a>CF840C</h3><p>一件这样的事情：有$n$个球，有标号，需要选$i$对出来，每一对内是有序的，一个球可以被选两次，求方案数。 那么答案为 $$\frac{n!(n-1)!}{i!(n-i)!(n-1-i)!}$$ 理由： 考虑这$i$段一定有$i$个左端点，可以看作选了$i$个左端点出来，然后把这$i$个左端点随意排列，挨着它的就是右端点。 或者看作先选了$i$段，再把左端点填上。</p>
<h3 id="POI2014-RAJ-Rally"><a href="#POI2014-RAJ-Rally" class="headerlink" title="[POI2014]RAJ-Rally"></a>[POI2014]RAJ-Rally</h3><p>拓扑图求最长路是简单的。拓扑图有一个极好的性质：可以把图分成两部分，两部分之间只有单项边相连。实际上只需钦定一个位置，使得拓扑序比它大/小的在它一边就行了。 那么要求删一个点之后的最长路，可以考虑枚举这个划分，维护两个集合内的最长路，与跨中间的边的最长路。按照拓扑序每次把一个点放到另一个集合里，就可以动态维护删掉这个点的最长路了。</p>
<h3 id="CF582D"><a href="#CF582D" class="headerlink" title="CF582D"></a>CF582D</h3><p>考虑$n!$一共有多少$p$是因数：$\sum_{i=1} \lfloor \frac{n!}{p^i} \rfloor$，即$p$进制下，从高到低前缀和之和。 那么考虑$\binom{n+m}{n}$中，$p$的个数，发现如果$p$进制加法没进位，就是$0$，否则会$+1$。那么答案就是进位次数。 数位DP。一个蛋疼的东西：这个数位DP显然是从高到低考虑比较合适的，而不是从低转移到高，那么这种情况下直接递推比搜好。 令$f_{i,j,0/1，0/1}$表示考虑前$i$位，进位$j$次，第$i$位是否上届，第$i-1$位是否进位到$i$。转移即可。 有一个计数方面的Trick：需要求一个这样的式子的解数量：求有多少对$(x,y)$满足$0 \leq x+y-p \leq d - 1$。 做法是这样的：考虑再减一个$p$： $$-p \leq x - p + y - p \leq d - p - 1$$ $$p + d - 1 \leq p - x + p - y \leq p$$ $$cnt = \sum_{i=p + 1 - d}^p \sum_{1 \leq x \leq p, 1 \leq y \leq p} [x+ y =i]$$ $$= \sum_{i=p + 1 - d}^p i - 1$$ 那么算一下式子就行了</p>
<h3 id="agc004f"><a href="#agc004f" class="headerlink" title="agc004f"></a>agc004f</h3><p>首先，可以把题目改成把点两两配对，最短距离。 如果是树，那么只需考虑每条边被经过的次数，黑白染色，令两种点分别为$1,-1$，记子树和，答案即$\sums_i$ 显然，$s_r$必须为$0$。 如果有奇环，可以通过绕奇环一次把根的和$+-2$。判一下要多少次，把环上点都更新一下。 如果有偶环，考虑可以把偶环上一些边改成走被断开的环边，答案为$\sums-x+\sums+x+x$，$x$为走了几次。这个是中位数问题。</p>
<h3 id="arc083f"><a href="#arc083f" class="headerlink" title="arc083f"></a>arc083f</h3><p>看似是神题，其实是套路（？）题 因为一个机器人只能用一次，所以当出现拐角这样的形状时，就很捉急。 具体来说，可以考虑给每个点找一下它可能被哪个机器人干掉，其实只有两个是可能的 那么行列为点点为边建图，一定是基环数 考虑给每个点钦定一下它是被谁消掉的。显然就是给边定向。假设边$x,y$的意义是$(x,y)$的点被$y$消掉了。 那么就是一棵外向树。基环上的边有两种可能方向，枚举一下 考虑计数，当钦定了一个点被一个机器人消掉之后，发现如果一开始就走这个机器人，不一定能消掉这个点。也就是说存在一些关系，表示$x$必须在$y$之前选。连边。 这次连出来的是森林。满足题意的方案，一定是森林的合法拓扑序。数一下就OK了 注意多个基环树是独立的，要乘起来，并且还要乘一个多重集排列</p>
<h3 id="P4705"><a href="#P4705" class="headerlink" title="P4705"></a>P4705</h3><p>就是一个东西：快速求$\sum_{i=1}^n a_i^k$ 那么整个生成函数：$F(x)=\sum_{k=0}^{\infty} x^k \sum_{i=1}^n a_i^k=\sum_{i=1}^n \sum_{j=0}^{\infty} a_i^j x_j=\sum_{i=1}^n \frac{1}{1-a_ix}$ 因为$ln(1-a_ix)’=\frac{-a_i}{1-a_ix}$，令$G(x)=\sum_{i=1}^n ln(1-a_ix)’$，则$F(x)=-xG(x)+n$。 $G(x)=\sum_{i=1}^n ln(1-a_ix)’ = ln(\prod_{i=1}^n (1-a_ix))’$，分治NTT即可</p>
<h3 id="RC-02-开门大吉"><a href="#RC-02-开门大吉" class="headerlink" title="[RC-02] 开门大吉"></a>[RC-02] 开门大吉</h3><p>对于选$i$，就不能选$j+k$之前的的限制，直接从$i$到$j+k$连INF，最小割即可。</p>
<h3 id="HNOI2019-JOJO"><a href="#HNOI2019-JOJO" class="headerlink" title="[HNOI2019] JOJO"></a>[HNOI2019] JOJO</h3><p>KMP跳NEXT的时候，如果有周期，可以直接取模。但是要判断有没有周期，先暴力跳一下，把$x - p_x$即可能的周期存下来，第二次再跳的时候如果长度一样，就是周期，就可以取模了。</p>
<h3 id="CF1349A"><a href="#CF1349A" class="headerlink" title="CF1349A"></a>CF1349A</h3><p>LCM的GCD，考虑意义，就是第二大的因子。</p>
<h3 id="CF1349B"><a href="#CF1349B" class="headerlink" title="CF1349B"></a>CF1349B</h3><p>找规律题。 考虑存在$A \leq B$，且$A$为要变成的答案。可以证明，在$B$右边无论存在什么数，都可以做出答案。左边同理。</p>
<h3 id="CF1349C"><a href="#CF1349C" class="headerlink" title="CF1349C"></a>CF1349C</h3><p>发现如果两个块，颜色不同，且大小都不为$1$，那么永不影响。如果一个块大小$&gt; 1$，另一个大小为$1$，只需一步就可以传染到。所以就是一个最短路问题。</p>
<h3 id="CF1349D"><a href="#CF1349D" class="headerlink" title="CF1349D"></a>CF1349D</h3><p>首先令$E_i$表示$i$的答案，如果只有$i$满了才能结束游戏，就可以直接消元求了。 令$E_i’$表示满了才能结束游戏的期望，那么有： $$E_x = E_x’ - \sum_{i=1}^n [i \neq x] (P_iC + E_i) $$ 其中$C$是全部转移的期望。就是考虑提前结束在哪里。 那么考虑计算$E_x’,C$，发现其实是一回事，就是要求已经有了一些，之后期望多少步win。 那么令$f_i$表示还需要$i$个才能win的期望。根据题解的说法，直接列式子会除$0$，所以考虑差分，令$g_i=f_i-f_{i-1}$。 那么$g_i$的实际意义，就是现在差$i$个，期望几次可以获得一个。</p>
<h3 id="AGC020D"><a href="#AGC020D" class="headerlink" title="AGC020D"></a>AGC020D</h3><p>热动分析一下：首先最长段一定是$K = \max \lbrace \lceil \frac{A}{B+1} \rceil , \lceil \frac{B}{A+1} \rceil \rbrace$ 那么可以得到答案一定长成$AAAAABAAAAAB…A…BBBBBBBA…$这样。 考虑一个位置，如果可以作为分界点，设前面放好之后剩下的$A,B$分别有$a,b$个，可以知道：$aK \geq b$。那么可以二分边界。 之后有一个问题：再变为$BBBBBBA$之前，会有一段可以多放一些$A$的位置。具体来说，因为后面有$aK &lt; b$，可以多放一些$A$，到正好满足的地方。 知道这些就可以做了。</p>
<h3 id="AGC020F"><a href="#AGC020F" class="headerlink" title="AGC020F"></a>AGC020F</h3><p>神仙题。。需要很多步操作。。 首先，环不好处理，考虑变成链。钦定最长的一根为在起点，那么其它的都无法超过它，就可以做了。 注意到一件这样的事情：（在很多题都很重要！！） 输入都是整数。 那么有一种做法：令某段的起点位置为$s_i$，则可以分解为$p_i+f_i$。其中$p$是整数，$f$是小数。 因为线段长度都是整数，所以两条是否相交，和$f$是多少无关，只和$f$相对大小关系有关。 又因为是随机的，$f$相同的概率可以看做$0$。那么枚举大小关系。 只关心大小关系的话，问题就可以离散了。可能的起点有$nC= 300$个。 做一个DP：$f_{i,j,s}$表示前$i$个位置存在线段，最长覆盖到了$j$，并且用过的线段是$s$。 转移只需要讨论某位置放不放。注意到已经钦定了大小关系的顺序，实际上对于一个位置，可以算出下一个小数部分是多少，也就是转移是唯一的。DP一下就做完了。 得到了方案数，除以总数。总数是枚举的排列数量，乘上可能的起点位置。$C$的任何一个位置都可能是起点，并且钦定了一个线段，考虑了$n-1$个。所以是$C^{n-1}$。</p>
<h3 id="bzoj-4245"><a href="#bzoj-4245" class="headerlink" title="bzoj 4245"></a>bzoj 4245</h3><p>大概是说给一个序列，要你先分段m段再求值，值是每一段的xor和的or和。求最小值。 那么有一个Trick：$a \oplus b b = a b$。分类讨论可知。 于是考虑做一个前缀xor和，答案就是选一些数使得or最大。贪心即可。注意最后一个必须选。</p>
<h3 id="CF1286E"><a href="#CF1286E" class="headerlink" title="CF1286E"></a>CF1286E</h3><p>只需要求出每次插入一个元素后，串的border即可。可以知道可能的border只有$O(n)$种。那么只需要维护。 考虑一个border，位置为$i$，如果插入字符$c$后还是border，那么$str_{i+1}=c$。 于是考虑一种做法：维护每个串后面的字符是什么。但是这个每次修改的量是$O(n)$。 可以这样维护：对于每个border，记录第一个和它颜色不同的祖先。这样跳着删就行了。 考虑正确性：新插入一个字符后，border集合的结束位置都变了。但是不需要重新计算每个位置的祖先，因为之前都算过了。只需要维护新插入的点的祖先，它就会自动跳到我们想得到的链上。 用单调栈维护区间$min$，用$map$维护每种串。每次插入一个元素后，把所有比新大小大的串都删掉。可以发现是$O(nlogn)$的。</p>
<h3 id="SDOI2017-龙与地下城"><a href="#SDOI2017-龙与地下城" class="headerlink" title="[SDOI2017]龙与地下城"></a>[SDOI2017]龙与地下城</h3><p>FFT的时候，把两侧比较小的数直接丢掉，可以快速得到近似解</p>
<h3 id="NOI2017-泳池"><a href="#NOI2017-泳池" class="headerlink" title="[NOI2017]泳池"></a>[NOI2017]泳池</h3><p>DP什么的不写了..记一个$O(n^2)$多项式取模：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mod</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n * <span class="number">2</span>; i &gt;= n; --i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j)</span><br><span class="line">      A[i + j - n] = (A[i + j - n] + P - <span class="number">1ll</span> * A[i] * B[j] % P) % P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SDOI2017-遗忘的集合"><a href="#SDOI2017-遗忘的集合" class="headerlink" title="[SDOI2017]遗忘的集合"></a>[SDOI2017]遗忘的集合</h3><p>面对多项式连乘不要怕，微笑着面对它！消除连乘的最好办法就是求LN！</p>
<h3 id="ZJOI2015-地震后的幻想乡"><a href="#ZJOI2015-地震后的幻想乡" class="headerlink" title="[ZJOI2015]地震后的幻想乡"></a>[ZJOI2015]地震后的幻想乡</h3><p>期望时间和期望排名是可以互相转化的。</p>
<h3 id="HAOI2017-新型城市化"><a href="#HAOI2017-新型城市化" class="headerlink" title="[HAOI2017]新型城市化"></a>[HAOI2017]新型城市化</h3><p>两个团意味着反图是二分图</p>
<h3 id="ZJOI2017-树状数组"><a href="#ZJOI2017-树状数组" class="headerlink" title="[ZJOI2017]树状数组"></a>[ZJOI2017]树状数组</h3><p>树状数组的操作反向之后，就是后缀操作。 考虑贡献，是一对点相同的概率。 用最暴力的方法维护：直接维护点对的答案，二维数据结构。</p>
<h3 id="ZJOI2017-仙人掌"><a href="#ZJOI2017-仙人掌" class="headerlink" title="[ZJOI2017]仙人掌"></a>[ZJOI2017]仙人掌</h3><p>加边后是仙人掌-&gt;删掉环后的树，在上面加边，使得每条边最多覆盖一次-&gt;假装没覆盖的是被重边覆盖-&gt;一般通过DP</p>
<h3 id="SDOI2017-天才黑客"><a href="#SDOI2017-天才黑客" class="headerlink" title="[SDOI2017]天才黑客"></a>[SDOI2017]天才黑客</h3><p>有一件事：多个点的LCP，建图优化，要考虑怎么建才不会让LCP变大（漏）</p>
<h3 id="ZJOI2016-线段树"><a href="#ZJOI2016-线段树" class="headerlink" title="[ZJOI2016]线段树"></a>[ZJOI2016]线段树</h3><p>一般通过DP：考虑一个点能对哪里贡献：是一个区间。钦定$f_{v,i,l,r}$，表示$v$，$i$次操作，$[l,r]$没它大，$l-1,r+1$比它大。 那么对于一个位置，方案和就是所有包含它的区间。$f$就是答案$\leq v$的，减一下就是$=$了，记为$h$。 $ans=\sum (h_v - h_{v+1})val_v $。因为数据随机，跑得很快。 一类套路优化：考虑对答案的贡献，发现状态这么具体没用，只需要记录$\sum h_i (val_i - val_{i+1})$。</p>
<h3 id="ZJOI2017-线段树"><a href="#ZJOI2017-线段树" class="headerlink" title="[ZJOI2017]线段树"></a>[ZJOI2017]线段树</h3><p>根据套路，线段树查询到的点，就是$-1,+1$到根的右/左儿子。（zkw那个） 于是树上维护一个点到根的信息，这个是可减的。分类讨论即可。</p>
<h3 id="ZJOI2019-线段树"><a href="#ZJOI2019-线段树" class="headerlink" title="[ZJOI2019]线段树"></a>[ZJOI2019]线段树</h3><p>每次进行线段树的复制，维护个数比较烦，考虑维护概率。那么一个点有三种情况：有值，祖先有值，祖先无值。 一个点有四种被影响的可能：在查询路径上，被覆盖，是被覆盖的孩子，是某个路过点的另一个儿子。矩阵维护。</p>
<h3 id="AGC036-D"><a href="#AGC036-D" class="headerlink" title="[AGC036]D"></a>[AGC036]D</h3><p>无负环-&gt;最短路存在-&gt;每个点有一个距离-&gt;存在一些$i&lt;j, d_i - d_j \geq 1$或者符号相反的东西-&gt;差分之后，区间和$\leq 1, \geq 1$-&gt;观察发现差分数组只能是$0/1$ -&gt;设计DP，$f_{i,j}$表示最后两个$1$的位置。 冷静分析一下，$f_{i,j}$从$f_{j,k}$转移来。那么$j,k$之间的，以及一段在$k,j$，一段在$i,n$的一些可以留下。二维前缀和。</p>
<h3 id="HDU6427"><a href="#HDU6427" class="headerlink" title="HDU6427"></a>HDU6427</h3><p>首先恶补一下置换套路：一个环旋转和翻转是独立的。因为如果先旋转再反转或者反过来这样，可以化简为一次翻转。 这个题又要移动又要做上面的操作，可以考虑分开求。总置换数是$2nm$。 考虑翻转+移动： 如果$n$是奇数，不能移动，可以在顶点上转。 如果$n$是偶数，并且在顶点上转，那么不能移动。否则如果$m$是偶数，可以转$m/2$。 考虑旋转+移动： 转了，动了分别$i,j$次。旋转次数是$lcm(i,n)$。移动循环节是$lcm(j,m)$ 那么必须有$lcm(j,m) lcm(i, n)$。 所以式子是$\sum_{i \leq n} m^{gcd(n,i)} \sum_{j \leq m} [lcm(j,m) lcm(i, n)]$</p>
<h3 id="CF1286F"><a href="#CF1286F" class="headerlink" title="CF1286F"></a>CF1286F</h3><p>序列上两个点一起操作，考虑连边。那么发现对于树，可以节省一次操作。问题就是划分成尽可能多的树。 考虑一棵树：先假装没有$+1$的操作。把点划分为两组，如果它们的差为$0$，那么一定可以，接在一起就行了。加上$+1$后，可以加减不超过$n$，并且奇偶性要相同。 之后做一个DP就好了。用一个玄学剪枝：只通过枚举不能被表示的集合转移。速度会非常优秀。</p>
<h3 id="循环之美"><a href="#循环之美" class="headerlink" title="循环之美"></a>循环之美</h3><p>主要是记录一个Trick：推式子的时候在恰当的时候，把式子中的一部分用函数表示，可以大幅度减少工作量。 还有，就是注意观察有没有重复出现的部分。如果有，可以设函数递归。</p>
<h3 id="怎样跑得更快"><a href="#怎样跑得更快" class="headerlink" title="怎样跑得更快"></a>怎样跑得更快</h3><p>不可以高斯消元的话，考虑反演。还是上面那个话：恰当的时机，表示为函数。</p>
<h3 id="Gosha-is-hunting"><a href="#Gosha-is-hunting" class="headerlink" title="Gosha is hunting"></a>Gosha is hunting</h3><p>WQS可以套WQS</p>
<h3 id="好图计数-Count"><a href="#好图计数-Count" class="headerlink" title="好图计数 / Count"></a>好图计数 / Count</h3><p>本题用到的方法和有根树计数是类似的。 考虑令$f,g$分别表示不要求联通，一定联通的方案数。冷静一下可以发现$g=f/2$。那么考虑计算$f$。令生成函数$F$，考虑计算。 $$F(x)=\prod_{k \geq 1} (\sum_{i\geq 0} x^{ki})^{g_k} =\prod_{k \geq 1} (1-x^k)^{-g_k}$$ 这个式子的含义，是考虑集合的划分，划分为若干联通子图。里面的$\sum$考虑了选几个，外面的幂给出了方案数。 求对数再求导： $$\frac{F’(x)}{F(x)} = \sum_{k \geq 1} g_k \frac{kx^{k-1&#125;&#125;{1-x^k}$$ $$[x^n]F’(x) = (n+1)f_{n+1}=…$$ 后面的$…$是一坨卷积，最高次是$n$。那么就可以推出来$f_{n+1}$了</p>
<h3 id="Serval-and-Bonus-Problem"><a href="#Serval-and-Bonus-Problem" class="headerlink" title="Serval and Bonus Problem"></a>Serval and Bonus Problem</h3><p>实数上瞎选，可以看做等分线段后离散的做。</p>
<h3 id="显而易见的数论"><a href="#显而易见的数论" class="headerlink" title="显而易见的数论"></a>显而易见的数论</h3><p>不会做，就是记一下，$\sum <a href="i-1,n">(i,n)=1</a>$是积性的。</p>
<h3 id="文艺计算姬"><a href="#文艺计算姬" class="headerlink" title="文艺计算姬"></a>文艺计算姬</h3><p>考虑prufer序列，因为是二分图，考虑式子：$\sum_l + n = \sum_r + m,\sum_l + \sum_r = n - 2$。就可以解出$\sum$是多少了。快速幂即可。</p>
<h3 id="CF453E"><a href="#CF453E" class="headerlink" title="CF453E"></a>CF453E</h3><p>每次修改，区间推平的操作，线段树维护，复杂度是很好的。</p>
<h3 id="CF833D"><a href="#CF833D" class="headerlink" title="CF833D"></a>CF833D</h3><p>两个数的比在$0.5,1$之间，可以转化为小的比大的在，进一步转化为互相的二倍关系</p>
<h3 id="毒瘤"><a href="#毒瘤" class="headerlink" title="毒瘤"></a>毒瘤</h3><p>虚树树形DP，考虑链的贡献，把一个点表示为$af0+bf1$，可以向上推</p>
<h3 id="CF1363F"><a href="#CF1363F" class="headerlink" title="CF1363F"></a>CF1363F</h3><p>冷静分析一下：题目中的旋转操作的实质，就是选一个数，从后面丢到前面。 那么考虑如何匹配：首先后缀的lcs是可以删掉的。删掉后的两个串的尾，是不同的。 那么考虑把$s$的尾巴拿起来，丢到前面。之后继续匹配。假设不同的位置是$i$，那么就是要求$S_{i-1},T_i$需要多少次才能匹配。此处的匹配就是可以空位置的匹配。显然空位置匹配后，丢进去就行。 那么考虑令$f_{i,j}$，表示$S_{1,i},T_{1,j}$匹配需要多少次。显然此处$i \leq j$。考虑转移： 把$i$拿起来，让剩下的匹配，再把$i$找个位置丢进去：$f_{i,j}=f_{i-1,j}+1$ 如果两个位置相同，直接匹配：$f_{i,j}=f_{i-1,j-1}$ 考虑$c=T_j$，如果在$S_{1,i}$出现次数更少，那么可以从后面移动一个$c$到前面匹配$j$：$f_{i,j}=f_{i,j-1}$这里没有加，是因为这里的从后面移动相当于后面的向前丢，是匹配的，只在后面计算就可以了。</p>
<h2 id="美团杯部分题解"><a href="#美团杯部分题解" class="headerlink" title="美团杯部分题解"></a>美团杯部分题解</h2><h3 id="半前缀计数"><a href="#半前缀计数" class="headerlink" title="半前缀计数"></a>半前缀计数</h3><p>考虑如果两个串是本质相同的：那么一定是$s,t$有一些公共部分。考虑在$s_{i+1}!=t_1$的位置统计答案。SAM维护。</p>
<h3 id="平行四边形"><a href="#平行四边形" class="headerlink" title="平行四边形"></a>平行四边形</h3><p>直接上原根。</p>
<h3 id="114514"><a href="#114514" class="headerlink" title="114514"></a>114514</h3><p>发现$4$前面一定是$1$，贪心匹配一波。就转化为了求$1A5A$。按顺序扫，遇到$1$加一个新的，遇到$A$优先匹配$1$。</p>
<h3 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a>汉明距离</h3><p>考虑一个随机游走问题：数轴上正负走n次后，期望距离的平方是什么。列一个DP式子，可以发现，走n次的期望是n。 考虑随机一个数列，权值为+-1。考虑对输入的序列和它点积一次，原序列点积一次，求一下两个值差的平方。发现和上面那个问题是等价的，所以期望就是题目所求的东西。多随机几个打个表就行了</p>
<h3 id="版本答案"><a href="#版本答案" class="headerlink" title="版本答案"></a>版本答案</h3><p>热动分析一下：不可能一方同时有两个没盾的。于是考虑DP，记录双方活着几个，进攻的有没有盾，防御的是否存在没盾的。手推一下，发现一些转移有环。解方程可以解出来</p>
<h3 id="AGC001F-amp-amp-HNOI2015-菜肴制作"><a href="#AGC001F-amp-amp-HNOI2015-菜肴制作" class="headerlink" title="AGC001F &amp;&amp; [HNOI2015]菜肴制作"></a>AGC001F &amp;&amp; [HNOI2015]菜肴制作</h3><p>一类为拓扑序标号的问题。综合思想：正序拓扑最小，等价于拓扑反序后最大，反序后贪心。证明大约和某种对偶性质有关？ 回到AGC的题：$j-i \geq K, P_i - P_j = 1$，建立反排列$Q$后得到：$Q_j - Q_i \geq K, j - i = 1$。就是相邻的。 那么考虑如果两个数满足小于，永远不可能交换顺序。其它的都可以换。 于是回到原题，就是向周围$K$个内满足某种条件的连边。之后跑拓扑标号。 冷静分析一下优化复杂度：拓扑排序-&gt;入度为0-&gt;入度为0的条件是它是区间极值-&gt;用堆维护点，优先取出靠后的，线段树上删掉-&gt;检查左右两边最大的点，并检查这些点是否是区间极值，插入堆。</p>
<h3 id="CF446D"><a href="#CF446D" class="headerlink" title="CF446D"></a>CF446D</h3><p>看到高斯消元就蛋疼。。考虑钦定一个起点，求走到其它点的概率。那么令$f_i$表示这个概率，$f_i$就等于从挨着的点走过来的概率和。特别的，$i=s$的时候，加上$1$。 考虑如何设置起点：我们要求从一个黑点走到另一个黑点的概率。那么考虑先从这个黑点走出来，再走。那么周围的点各获得一个度数的概率。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
</search>
